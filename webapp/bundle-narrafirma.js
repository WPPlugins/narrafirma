define('js/nls/applicationMessages',["require", "exports"], function (require, exports) {
    "use strict";
    var messages = {
        root: {
            // Do not translate text in double braces since they are identifiers looked up and replaced by the program at runtime
            // For example: {{total}} should stay the same in the translation
            dashboard_status_label: "reminders:",
            question_not_yet_answered: "(Not Yet Entered)",
            // Translation of buttons
            button_home: "Home",
            button_home_title: "Go home to main dashboard",
            button_previousPage: "Previous Page",
            button_nextPage: "Next Page",
            button_loadLatest: "Load latest",
            button_loadVersion: "Load version",
            button_save: "Save",
            button_debug: "Debug",
            button_importExport: "Import/Export",
            // Grid buttons
            button_OK: "OK",
            button_Cancel: "Cancel",
            button_Done: "Done",
            button_View: "View",
            button_Add: "Add",
            button_Remove: "Remove",
            button_Edit: "Edit",
            button_Duplicate: "Duplicate",
            button_Up: "Move Up",
            button_Down: "Move Down",
            button_navigateStart: "[<<",
            button_navigatePrevious: "<",
            button_navigateNext: ">",
            button_navigateEnd: ">>]",
            // Story browser button
            button_Filter: "Filter -- show only stories where both questions have the selected values",
            // Used for test of survey in main.js
            "surveySubmit": "Submit Survey",
            "surveyCancel": "Cancel",
            "button_tellAnotherStory": "Tell another story",
            "button_dontTellAnotherStory": "Done with adding stories",
            // select widgets
            selection_has_not_been_made: " -- select -- ",
            // calculations
            calculate_quizScoreResult_template: "{{total}} of {{possibleTotal}} ({{percent}}%)",
            // other
            copyDraftPNIQuestion_template: "Copied {{copiedAnswersCount}} answers.\n\n(Note that blank draft answers are not copied, and non-blank final answers are not replaced.)",
            no_questions_answered_on_page: "(No questions answered on this page)",
            // Used for boolean choice widget
            boolean_choice_yes: "yes",
            boolean_choice_no: "no",
            // Used for graph browser
            updateGraph: "Update Graph",
            // Used for templates
            button_chooseATemplateToInsert: "Choose a template to insert...",
            title_chooseATemplate: "Choose a template",
            // eliciting or questions
            "category::shortName": "Category",
            "id::shortName": "ID",
            "shortName::shortName": "Short name",
            "text::shortName": "Text",
            "type::shortName": "Type",
            "options::shortName": "Options",
            "category::prompt": "Category",
            "id::prompt": "ID",
            "shortName::prompt": "Short name",
            "text::prompt": "Text",
            "type::prompt": "Type",
            "options::prompt": "Options",
            // activities
            "name::shortName": "Name",
            // duplicated above for questions: "type::shortName": "type",
            "plan::shortName": "Plan",
            "optionalParts::shortName": "Optional parts",
            "duration::shortName": "Duration",
            "recording::shortName": "Recording",
            "materials::shortName": "Materials",
            "spaces::shortName": "Spaces",
            "facilitation::shortName": "Facilitation",
            "name::prompt": "Name",
            // duplicated above for questions: "type::prompt": "type",
            "plan::prompt": "Plan",
            "optionalParts::prompt": "Optional parts",
            "duration::prompt": "Duration",
            "recording::prompt": "Recording",
            "materials::prompt": "Materials",
            "spaces::prompt": "Spaces",
            "facilitation::prompt": "Facilitation",
            "button_UseTemplate": "Use template",
            // use for recommendations table
            button_showRecommendationsTable: "Show recommendations table",
            title_recommendationsTable: "Recommendations table",
            // For clustering diagram
            clusterDiagramSource_titleID: "Cluster Diagram Source",
            clusterDiagramSource_okButtonID: "Update",
            // For project import/export dialog
            projectImportExportDialog_title: "Project Design Import/Export",
            projectImportExportDialog_okButtonText: "Import",
            // For theming
            button_addTheme: "Add theme",
            // For general recommendations:
            "participantGroup_status::shortName": "Status",
            "participantGroup_confidence::shortName": "Self-confidence",
            "participantGroup_time::shortName": "Free time",
            "participantGroup_education::shortName": "Education level",
            "participantGroup_physicalDisabilities::shortName": "Physical disabilities",
            "participantGroup_emotionalImpairments::shortName": "Emotional impairments",
            "participantGroup_performing::shortName": "Performance",
            "participantGroup_conforming::shortName": "Conformance",
            "participantGroup_promoting::shortName": "Self-promotion",
            "participantGroup_venting::shortName": "Speaking out",
            "participantGroup_interest::shortName": "Motivated",
            "participantGroup_feelings_project::shortName": "Feelings about project",
            "participantGroup_feelings_facilitator::shortName": "Feelings about you",
            "participantGroup_feelings_stories::shortName": "Feelings about stories",
            "participantGroup_topic_feeling::shortName": "Feelings about topic",
            "participantGroup_topic_private::shortName": "Privacy of topic",
            "participantGroup_topic_articulate::shortName": "How articulate",
            "participantGroup_topic_timeframe::shortName": "Timeframe",
            "aboutYou_experience::shortName": "Your experience with PNI",
            "aboutYou_help::shortName": "Your available help",
            "aboutYou_tech::shortName": "Your technology experience",
            // For interventions recommendations
            "outcomes_peopleFeltHeard::shortName": "Felt heard",
            "outcomes_peopleFeltInvolved::shortName": "Felt involved",
            "outcomes_peopleLearnedAboutCommOrg::shortName": "Learned about community",
            "outcomes_peopleWantedToTellMoreStories::shortName": "Wanted to tell more",
            "outcomes_peopleWantedToShareMoreStoriesWithEachOther::shortName": "Wanted to share more",
            "outcomes_peopleFeltStoriesNeededToBeHeard::shortName": "Felt that stories needed to be heard",
            "outcomes_peopleFeltNobodyCares::shortName": "Felt that nobody cares",
            "outcomes_peopleFeltNobodyCanMeetNeeds::shortName": "Needs could not be met",
            "outcomes_peopleFeltTheyNeedNewStories::shortName": "Needed to tell themselves new stories",
            "outcomes_peopleWantedToKeepExploring::shortName": "Wanted more exploration",
            "outcomes_crisisPointsWereFound::shortName": "Crisis points",
            "outcomes_issuesWereBeyondWords::shortName": "Beyond words",
            "outcomes_peopleLearnedAboutTopic::shortName": "Learned about topic",
            "outcomes_issuesNewMembersStruggleWith::shortName": "New members needed help",
            "outcomes_foundInfoWithoutUnderstanding::shortName": "Had more information than understanding",
            "outcomes_foundOverConfidence::shortName": "Had more confidence than skill",
            "outcomes_peopleCuriousAboutStoryWork::shortName": "Wanted to learn about story work"
        }
    };
    return messages;
});

define('js/panelBuilder/browser',["require", "exports"], function (require, exports) {
    "use strict";
    // launchApplication function inspired by: http://stackoverflow.com/questions/528671/javascript-window-open-only-if-the-window-does-not-already-exist
    var openedWindows = {};
    function launchApplication(url, windowName) {
        var openedWindowInfo = openedWindows[windowName];
        if (openedWindowInfo && !openedWindowInfo.window.closed) {
            if (openedWindowInfo.url !== url) {
                openedWindowInfo.window.location.replace(url);
            }
        }
        if (typeof openedWindowInfo === 'undefined' || openedWindowInfo.window.closed) {
            var width = Math.round(((screen.availWidth || 600) - 100) / 1.3);
            var height = Math.round(((screen.availHeight || 600) - 150) / 1.1);
            var windowOpenParams = 'status=1,resizable=1,scrollbars=1,toolbar=yes,left=100,top=150,width=' + width + ',height=' + height;
            var openedWindow = window.open(url, windowName, windowOpenParams);
            // Not sure if moveTo and resizeTo is really needed, since works without them in Firefox
            openedWindow.moveTo(100, 150);
            openedWindow.resizeTo(width, height);
            openedWindowInfo = { window: openedWindow, url: url };
            openedWindows[windowName] = openedWindowInfo;
        }
        else {
            openedWindowInfo.window.focus();
        }
    }
    exports.launchApplication = launchApplication;
});

!function() {
  var d3 = {
    version: "3.5.5"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.zip = function() {
    if (!(n = arguments.length)) return [];
    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {
      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {
        zip[j] = arguments[j][i];
      }
    }
    return zips;
  };
  function d3_zipLength(d) {
    return d.length;
  }
  d3.transpose = function(matrix) {
    return d3.zip.apply(d3, matrix);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: "http://www.w3.org/1999/xhtml",
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0) {
        prefix = name.slice(0, i);
        name = name.slice(i + 1);
      }
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
            exitNodes[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
          keyValues[i] = keyValue;
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = nodes;
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged && d3.event.target === target);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
    var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ρ;
    function interpolate(t) {
      var s = t * S;
      if (dr) {
        var coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      }
      return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * s) ];
    }
    interpolate.duration = S * 1e3;
    return interpolate;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: +_
      };
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      });
      center0 = null;
    }
    function mousedowned() {
      var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged && d3.event.target === target);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else translate0 = location(center0 = center || d3.mouse(this)), 
      d3_selection_interrupt.call(this), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/i.exec(format);
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format.toLowerCase())) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      f: false,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  };
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now();
    d3_timer_active = d3_timer_queueHead;
    while (d3_timer_active) {
      if (now >= d3_timer_active.t) d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
      d3_timer_active = d3_timer_active.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.f) {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      } else {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("w" in d && ("W" in d || "U" in d)) {
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransform(a, b) {
    var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
    if (ta[0] != tb[0] || ta[1] != tb[1]) {
      s.push("translate(", null, ",", null, ")");
      q.push({
        i: 1,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: 3,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    } else {
      s.push("");
    }
    if (ra != rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(s.pop() + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(s.pop() + "rotate(" + rb + ")");
    }
    if (wa != wb) {
      q.push({
        i: s.push(s.pop() + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(s.pop() + "skewX(" + wb + ")");
    }
    if (ka[0] != kb[0] || ka[1] != kb[1]) {
      n = s.push(s.pop() + "scale(", null, ",", null, ")");
      q.push({
        i: n - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: n - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] != 1 || kb[1] != 1) {
      s.push(s.pop() + "scale(" + kb + ")");
    }
    n = q.length;
    return function(t) {
      var i = -1, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: (x - x0) / k
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight / (t.weight + s.weight));
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) alpha = x; else alpha = 0;
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        d3.timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = 0;
      root.y = 0;
      root.dx = size[0];
      root.dy = size[1];
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, 
      Math.floor), e;
      return function(d) {
        return d / pow(f(log(d) + e)) <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
        if (x1 != null) {
          var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.join("L");
  }
  function d3_svg_lineLinearClosed(points) {
    return d3_svg_lineLinear(points) + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, active;
      if ((lock = this[ns]) && (active = lock[lock.active])) {
        if (--lock.count) delete lock[lock.active]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id];
    if (!transition) {
      var time = inherit.time;
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
      d3.timer(function(elapsed) {
        var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
        timer.t = delay + time;
        if (delay <= elapsed) return start(elapsed - delay);
        timer.c = start;
        function start(elapsed) {
          if (lock.active > id) return stop();
          var active = lock[lock.active];
          if (active) {
            --lock.count;
            delete lock[lock.active];
            active.event && active.event.interrupt.call(node, node.__data__, active.index);
          }
          lock.active = id;
          transition.event && transition.event.start.call(node, node.__data__, i);
          transition.tween.forEach(function(key, value) {
            if (value = value.call(node, node.__data__, i)) {
              tweened.push(value);
            }
          });
          ease = transition.ease;
          duration = transition.duration;
          d3.timer(function() {
            timer.c = tick(elapsed || 1) ? d3_true : tick;
            return 1;
          }, 0, time);
        }
        function tick(elapsed) {
          if (lock.active !== id) return 1;
          var t = elapsed / duration, e = ease(t), n = tweened.length;
          while (n > 0) {
            tweened[--n].call(node, e);
          }
          if (t >= 1) {
            transition.event && transition.event.end.call(node, node.__data__, i);
            return stop();
          }
        }
        function stop() {
          if (--lock.count) delete lock[id]; else delete node[ns];
          return 1;
        }
      }, 0, time);
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = arguments;
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (typeof define === "function" && define.amd) define('d3',d3); else if (typeof module === "object" && module.exports) module.exports = d3;
  this.d3 = d3;
}();
define('js/pointrel20150417/generateRandomUuid',["require", "exports"], function (require, exports) {
    "use strict";
    function generateRandomUuid(className) {
        // summary:
        //        This function generates random UUIDs, meaning "version 4" UUIDs.
        // description:
        //        A typical generated value would be something like this:
        //        "3b12f1df-5232-4804-897e-917bf397618a"
        //
        //        For more information about random UUIDs, see sections 4.4 and
        //        4.5 of RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.4
        //
        //        This generator function is designed to be small and fast,
        //        but not necessarily good.
        //
        //        Small: This generator has a small footprint. Once comments are
        //        stripped, it's only about 25 lines of code, and it doesn't
        //        dojo.require() any other modules.
        //
        //        Fast: This generator can generate lots of new UUIDs fairly quickly
        //        (at least, more quickly than the other dojo UUID generators).
        //
        //        Not necessarily good: We use Math.random() as our source
        //        of randomness, which may or may not provide much randomness.
        // examples:
        //        var string = dojox.uuid.generateRandomUuid();
        var HEX_RADIX = 16;
        function _generateRandomEightCharacterHexString() {
            // Make random32bitNumber be a randomly generated floating point number
            // between 0 and (4,294,967,296 - 1), inclusive.
            var random32bitNumber = Math.floor((Math.random() % 1) * Math.pow(2, 32));
            var eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);
            while (eightCharacterHexString.length < 8) {
                eightCharacterHexString = "0" + eightCharacterHexString;
            }
            return eightCharacterHexString; // for example: "3B12F1DF"
        }
        var hyphen = "-";
        var versionCodeForRandomlyGeneratedUuids = "4"; // 8 == binary2hex("0100")
        var variantCodeForDCEUuids = "8"; // 8 == binary2hex("1000")
        var a = _generateRandomEightCharacterHexString();
        var b = _generateRandomEightCharacterHexString();
        b = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);
        var c = _generateRandomEightCharacterHexString();
        c = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);
        var d = _generateRandomEightCharacterHexString();
        var returnValue = a + hyphen + b + hyphen + c + d;
        returnValue = returnValue.toLowerCase();
        return className + "_" + returnValue; // String
    }
    return generateRandomUuid;
});

define('js/panelBuilder/PanelSpecificationCollection',["require", "exports"], function (require, exports) {
    "use strict";
    var PanelSpecificationCollection = (function () {
        function PanelSpecificationCollection() {
            // TODO: Think about whether can refactor to remove need for allFieldSpecifications array and/or map
            // Keep all questions together for use by things like calculating derived values from options for quiz score results
            this.allFieldSpecifications = [];
            this.fieldIDToFieldSpecificationMap = {};
            this.allPanels = [];
            this.panelIDToPanelSpecificationMap = {};
            this.allPages = [];
            this.pageIDToPageSpecificatiomMap = {};
            this.childPageIDListForHeaderID = {};
            this.modelClassToModelFieldSpecificationsMap = {};
            // For use while building pages; this assumes pages are added in some linear order where headers are added before child pages
            this.lastHeader = null;
        }
        // TODO: Maybe should remove this function? Currently only used by one test
        PanelSpecificationCollection.prototype.addPanelSpecificationFromJSONText = function (panelSpecificationJSONText) {
            var panelSpecification = JSON.parse(panelSpecificationJSONText);
            this.addPanelSpecification(panelSpecification);
            return panelSpecification;
        };
        PanelSpecificationCollection.prototype.addPanelSpecification = function (panelSpecification) {
            // console.log("addPanelSpecification", panelSpecification);
            // TODO: Maybe should copy panelSpecification to ensure it won't change if changed latar by caller?
            this.allPanels.push(panelSpecification);
            this.panelIDToPanelSpecificationMap[panelSpecification.id] = panelSpecification;
            if (panelSpecification.displayType === "page") {
                this.allPages.push(panelSpecification);
                this.pageIDToPageSpecificatiomMap[panelSpecification.id] = panelSpecification;
                if (!panelSpecification.isHeader) {
                    var list = this.childPageIDListForHeaderID[this.lastHeader] || [];
                    list.push(panelSpecification.id);
                    this.childPageIDListForHeaderID[this.lastHeader] = list;
                }
                else {
                    this.lastHeader = panelSpecification.id;
                }
            }
            var modelClass = panelSpecification.modelClass;
            if (modelClass) {
                var model = this.modelClassToModelFieldSpecificationsMap[modelClass];
                if (!model) {
                    model = [];
                    this.modelClassToModelFieldSpecificationsMap[modelClass] = model;
                }
            }
            // console.log("about to loop over panelFields", panelSpecification.panelFields.length);
            for (var i = 0; i < panelSpecification.panelFields.length; i++) {
                var fieldSpecification = panelSpecification.panelFields[i];
                // console.log("about to call addFieldSpecification", fieldSpecification);
                this.addFieldSpecification(modelClass, fieldSpecification);
            }
        };
        PanelSpecificationCollection.prototype.addFieldSpecification = function (modelClass, fieldSpecification) {
            // console.log("addFieldSpecification called", modelClass, fieldSpecification);
            var model = this.modelClassToModelFieldSpecificationsMap[modelClass];
            // console.log("adding field specification", modelClass, fieldSpecification, model);
            // TODO: Is this modelClass line still needed?
            fieldSpecification.modelClass = modelClass;
            this.allFieldSpecifications.push(fieldSpecification);
            this.fieldIDToFieldSpecificationMap[fieldSpecification.id] = fieldSpecification;
            if (model)
                model.push(fieldSpecification);
        };
        PanelSpecificationCollection.prototype.addFieldSpecificationToPanelSpecification = function (panelSpecification, fieldSpecification) {
            panelSpecification.panelFields.push(fieldSpecification);
            // Assumes the model has already been created if needed when the panel was added
            this.addFieldSpecification(panelSpecification.modelClass, fieldSpecification);
        };
        PanelSpecificationCollection.prototype.initialDataForField = function (fieldSpecification) {
            var valueType = fieldSpecification.valueType;
            if (valueType === "string")
                return "";
            if (valueType === "array")
                return [];
            if (valueType === "dictionary")
                return {};
            if (valueType === "object")
                return {};
            if (valueType === "boolean")
                return false;
            if (valueType === "set")
                return {};
            console.log("ERROR: Unsupported model field valueType", valueType, fieldSpecification);
            throw new Error("Unsupported model field valueType: " + valueType + " for field: " + fieldSpecification.id);
        };
        // This builds a specific model based on the name of the model, using data from one or more pages or panels that define that model
        PanelSpecificationCollection.prototype.buildModel = function (modelName) {
            // console.log("buildModel request", modelName);
            var model = { __type: modelName };
            var modelFieldSpecifications = this.modelClassToModelFieldSpecificationsMap[modelName];
            if (!modelFieldSpecifications) {
                console.log("ERROR: No model defined for model name", modelName);
                throw new Error("No model defined for model name: " + modelName);
            }
            for (var i = 0; i < modelFieldSpecifications.length; i++) {
                var fieldSpecification = modelFieldSpecifications[i];
                if (!fieldSpecification.valueType)
                    console.log("WARNING: Missing valueType for fieldSpecification", fieldSpecification);
                if (fieldSpecification.valueType && fieldSpecification.valueType !== "none") {
                    model[fieldSpecification.id] = this.initialDataForField(fieldSpecification);
                }
            }
            // console.log("buildModel result", modelName, model);
            return model;
        };
        // This ignores the model type for the page or panel and just puts all the model fields into the supplied model
        PanelSpecificationCollection.prototype.addFieldsToModel = function (model, fieldSpecifications) {
            // console.log("addFieldsToModel request", fieldSpecifications);
            for (var i = 0; i < fieldSpecifications.length; i++) {
                var fieldSpecification = fieldSpecifications[i];
                if (!fieldSpecification.valueType)
                    console.log("WARNING: Missing valueType for fieldSpecification", fieldSpecification);
                if (fieldSpecification.valueType && fieldSpecification.valueType !== "none") {
                    model[fieldSpecification.id] = this.initialDataForField(fieldSpecification);
                }
            }
            // console.log("addFieldsToModel result", model);
            return model;
        };
        PanelSpecificationCollection.prototype.buildListOfPages = function () {
            return this.allPages;
        };
        PanelSpecificationCollection.prototype.buildListOfPanels = function () {
            return this.allPanels;
        };
        PanelSpecificationCollection.prototype.getPageSpecificationForPageID = function (pageID) {
            return this.pageIDToPageSpecificatiomMap[pageID];
        };
        PanelSpecificationCollection.prototype.getPanelSpecificationForPanelID = function (panelID) {
            return this.panelIDToPanelSpecificationMap[panelID];
        };
        PanelSpecificationCollection.prototype.getFieldSpecificationForFieldID = function (fieldID) {
            return this.fieldIDToFieldSpecificationMap[fieldID];
        };
        PanelSpecificationCollection.prototype.getChildPageIDListForHeaderID = function (fieldID) {
            return this.childPageIDListForHeaderID[fieldID];
        };
        return PanelSpecificationCollection;
    })();
    return PanelSpecificationCollection;
});

define('js/panelBuilder/translate',["require", "exports"], function (require, exports) {
    "use strict";
    // Messages used by pages and created from design
    var pageMessages = {};
    // Messages specific to the editing application
    var applicationMessages = {};
    // Dynamically added extra translations like for survey questions
    var extraTranslations = {};
    var debugTranslations = false;
    function lookupTranslation(id) {
        var result = pageMessages[id];
        if (!result && result !== "")
            result = applicationMessages[id];
        if (!result && result !== "")
            result = extraTranslations[id];
        return result;
    }
    // if the tag field has a leading "#", it is parsed into an id and a default string by splitting at the first pipe
    function translate(tag, defaultText) {
        if (defaultText === void 0) { defaultText = undefined; }
        if (debugTranslations)
            console.log("translating", tag);
        if (tag === undefined || tag === "#undefined::prompt")
            throw new Error("bad translation tag using undefined which is likely a programming error");
        // if (debugTranslations && tag.charAt(0) !== "#") throw new Error("translation tag should have leading #  for: " + tag);
        // Kludge for extra domain translations for testing
        if (!tag) {
            if (debugTranslations)
                console.log("translating with no tag, so returning defaultText or empty string", defaultText);
            return defaultText || "";
        }
        if (tag.charAt(0) !== "#") {
            var translation = lookupTranslation(tag);
            if (translation)
                return translation;
            if (debugTranslations)
                console.log("no translation available for:", tag);
            if (defaultText !== null && typeof defaultText !== 'undefined')
                return defaultText;
            return tag;
        }
        // Special translation is done if tag starts with a hash mark, where can also supply optional translation string at end
        var id = tag.substring(1);
        var suppliedText = "";
        var splitPoint = id.indexOf("|");
        if (splitPoint !== -1) {
            suppliedText = id.substring(splitPoint + 1);
            id = id.substring(0, splitPoint);
        }
        var result = lookupTranslation(id);
        if (result === undefined) {
            if (suppliedText) {
                result = suppliedText;
            }
            else if (defaultText !== null && typeof defaultText !== 'undefined') {
                result = defaultText;
            }
            else {
                // Just return the tag, which starts with a # which should indicate an issue
                var error = "ERROR: missing text for: " + tag;
                console.log("translate problem", error);
                if (debugTranslations) {
                    result = error;
                }
                else {
                    result = tag;
                }
            }
        }
        if (debugTranslations)
            console.log("translating result: ", result, tag);
        return result;
    }
    function configure(pageMessagesNew, applicationMessagesNew) {
        pageMessages = pageMessagesNew;
        applicationMessages = applicationMessagesNew;
    }
    function addExtraTranslation(id, text) {
        extraTranslations[id] = text;
    }
    // Adding these to function just so can keep previous code the same as direct call to translate module
    translate["configure"] = configure;
    translate["addExtraTranslation"] = addExtraTranslation;
    return translate;
});

var m = (function app(window, undefined) {
	var OBJECT = "[object Object]", ARRAY = "[object Array]", STRING = "[object String]", FUNCTION = "function";
	var type = {}.toString;
	var parser = /(?:(^|#|\.)([^#\.\[\]]+))|(\[.+?\])/g, attrParser = /\[(.+?)(?:=("|'|)(.*?)\2)?\]/;
	var voidElements = /^(AREA|BASE|BR|COL|COMMAND|EMBED|HR|IMG|INPUT|KEYGEN|LINK|META|PARAM|SOURCE|TRACK|WBR)$/;
	var noop = function() {}

	// caching commonly used variables
	var $document, $location, $requestAnimationFrame, $cancelAnimationFrame;

	// self invoking function needed because of the way mocks work
	function initialize(window){
		$document = window.document;
		$location = window.location;
		$cancelAnimationFrame = window.cancelAnimationFrame || window.clearTimeout;
		$requestAnimationFrame = window.requestAnimationFrame || window.setTimeout;
	}

	initialize(window);


	/**
	 * @typedef {String} Tag
	 * A string that looks like -> div.classname#id[param=one][param2=two]
	 * Which describes a DOM node
	 */

	/**
	 *
	 * @param {Tag} The DOM node tag
	 * @param {Object=[]} optional key-value pairs to be mapped to DOM attrs
	 * @param {...mNode=[]} Zero or more Mithril child nodes. Can be an array, or splat (optional)
	 *
	 */
	function m() {
		var args = [].slice.call(arguments);
		var hasAttrs = args[1] != null && type.call(args[1]) === OBJECT && !("tag" in args[1] || "view" in args[1]) && !("subtree" in args[1]);
		var attrs = hasAttrs ? args[1] : {};
		var classAttrName = "class" in attrs ? "class" : "className";
		var cell = {tag: "div", attrs: {}};
		var match, classes = [];
		if (type.call(args[0]) != STRING) throw new Error("selector in m(selector, attrs, children) should be a string")
		while (match = parser.exec(args[0])) {
			if (match[1] === "" && match[2]) cell.tag = match[2];
			else if (match[1] === "#") cell.attrs.id = match[2];
			else if (match[1] === ".") classes.push(match[2]);
			else if (match[3][0] === "[") {
				var pair = attrParser.exec(match[3]);
				cell.attrs[pair[1]] = pair[3] || (pair[2] ? "" :true)
			}
		}

		var children = hasAttrs ? args.slice(2) : args.slice(1);
		if (children.length === 1 && type.call(children[0]) === ARRAY) {
			cell.children = children[0]
		}
		else {
			cell.children = children
		}
		
		for (var attrName in attrs) {
			if (attrs.hasOwnProperty(attrName)) {
				if (attrName === classAttrName && attrs[attrName] != null && attrs[attrName] !== "") {
					classes.push(attrs[attrName])
					cell.attrs[attrName] = "" //create key in correct iteration order
				}
				else cell.attrs[attrName] = attrs[attrName]
			}
		}
		if (classes.length > 0) cell.attrs[classAttrName] = classes.join(" ");
		
		return cell
	}
	function build(parentElement, parentTag, parentCache, parentIndex, data, cached, shouldReattach, index, editable, namespace, configs) {
		//`build` is a recursive function that manages creation/diffing/removal of DOM elements based on comparison between `data` and `cached`
		//the diff algorithm can be summarized as this:
		//1 - compare `data` and `cached`
		//2 - if they are different, copy `data` to `cached` and update the DOM based on what the difference is
		//3 - recursively apply this algorithm for every array and for the children of every virtual element

		//the `cached` data structure is essentially the same as the previous redraw's `data` data structure, with a few additions:
		//- `cached` always has a property called `nodes`, which is a list of DOM elements that correspond to the data represented by the respective virtual element
		//- in order to support attaching `nodes` as a property of `cached`, `cached` is *always* a non-primitive object, i.e. if the data was a string, then cached is a String instance. If data was `null` or `undefined`, cached is `new String("")`
		//- `cached also has a `configContext` property, which is the state storage object exposed by config(element, isInitialized, context)
		//- when `cached` is an Object, it represents a virtual element; when it's an Array, it represents a list of elements; when it's a String, Number or Boolean, it represents a text node

		//`parentElement` is a DOM element used for W3C DOM API calls
		//`parentTag` is only used for handling a corner case for textarea values
		//`parentCache` is used to remove nodes in some multi-node cases
		//`parentIndex` and `index` are used to figure out the offset of nodes. They're artifacts from before arrays started being flattened and are likely refactorable
		//`data` and `cached` are, respectively, the new and old nodes being diffed
		//`shouldReattach` is a flag indicating whether a parent node was recreated (if so, and if this node is reused, then this node must reattach itself to the new parent)
		//`editable` is a flag that indicates whether an ancestor is contenteditable
		//`namespace` indicates the closest HTML namespace as it cascades down from an ancestor
		//`configs` is a list of config functions to run after the topmost `build` call finishes running

		//there's logic that relies on the assumption that null and undefined data are equivalent to empty strings
		//- this prevents lifecycle surprises from procedural helpers that mix implicit and explicit return statements (e.g. function foo() {if (cond) return m("div")}
		//- it simplifies diffing code
		//data.toString() might throw or return null if data is the return value of Console.log in Firefox (behavior depends on version)
		try {if (data == null || data.toString() == null) data = "";} catch (e) {data = ""}
		if (data.subtree === "retain") return cached;
		var cachedType = type.call(cached), dataType = type.call(data);
		if (cached == null || cachedType !== dataType) {
			if (cached != null) {
				if (parentCache && parentCache.nodes) {
					var offset = index - parentIndex;
					var end = offset + (dataType === ARRAY ? data : cached.nodes).length;
					clear(parentCache.nodes.slice(offset, end), parentCache.slice(offset, end))
				}
				else if (cached.nodes) clear(cached.nodes, cached)
			}
			cached = new data.constructor;
			if (cached.tag) cached = {}; //if constructor creates a virtual dom element, use a blank object as the base cached node instead of copying the virtual el (#277)
			cached.nodes = []
		}

		if (dataType === ARRAY) {
			//recursively flatten array
			for (var i = 0, len = data.length; i < len; i++) {
				if (type.call(data[i]) === ARRAY) {
					data = data.concat.apply([], data);
					i-- //check current index again and flatten until there are no more nested arrays at that index
					len = data.length
				}
			}
			
			var nodes = [], intact = cached.length === data.length, subArrayCount = 0;

			//keys algorithm: sort elements without recreating them if keys are present
			//1) create a map of all existing keys, and mark all for deletion
			//2) add new keys to map and mark them for addition
			//3) if key exists in new list, change action from deletion to a move
			//4) for each key, handle its corresponding action as marked in previous steps
			var DELETION = 1, INSERTION = 2 , MOVE = 3;
			var existing = {}, shouldMaintainIdentities = false;
			for (var i = 0; i < cached.length; i++) {
				if (cached[i] && cached[i].attrs && cached[i].attrs.key != null) {
					shouldMaintainIdentities = true;
					existing[cached[i].attrs.key] = {action: DELETION, index: i}
				}
			}
			
			var guid = 0
			for (var i = 0, len = data.length; i < len; i++) {
				if (data[i] && data[i].attrs && data[i].attrs.key != null) {
					for (var j = 0, len = data.length; j < len; j++) {
						if (data[j] && data[j].attrs && data[j].attrs.key == null) data[j].attrs.key = "__mithril__" + guid++
					}
					break
				}
			}
			
			if (shouldMaintainIdentities) {
				var keysDiffer = false
				if (data.length != cached.length) keysDiffer = true
				else for (var i = 0, cachedCell, dataCell; cachedCell = cached[i], dataCell = data[i]; i++) {
					if (cachedCell.attrs && dataCell.attrs && cachedCell.attrs.key != dataCell.attrs.key) {
						keysDiffer = true
						break
					}
				}
				
				if (keysDiffer) {
					for (var i = 0, len = data.length; i < len; i++) {
						if (data[i] && data[i].attrs) {
							if (data[i].attrs.key != null) {
								var key = data[i].attrs.key;
								if (!existing[key]) existing[key] = {action: INSERTION, index: i};
								else existing[key] = {
									action: MOVE,
									index: i,
									from: existing[key].index,
									element: cached.nodes[existing[key].index] || $document.createElement("div")
								}
							}
						}
					}
					var actions = []
					for (var prop in existing) actions.push(existing[prop])
					var changes = actions.sort(sortChanges);
					var newCached = new Array(cached.length)
					newCached.nodes = cached.nodes.slice()

					for (var i = 0, change; change = changes[i]; i++) {
						if (change.action === DELETION) {
							clear(cached[change.index].nodes, cached[change.index]);
							newCached.splice(change.index, 1)
						}
						if (change.action === INSERTION) {
							var dummy = $document.createElement("div");
							dummy.key = data[change.index].attrs.key;
							parentElement.insertBefore(dummy, parentElement.childNodes[change.index] || null);
							newCached.splice(change.index, 0, {attrs: {key: data[change.index].attrs.key}, nodes: [dummy]})
							newCached.nodes[change.index] = dummy
						}

						if (change.action === MOVE) {
							if (parentElement.childNodes[change.index] !== change.element && change.element !== null) {
								parentElement.insertBefore(change.element, parentElement.childNodes[change.index] || null)
							}
							newCached[change.index] = cached[change.from]
							newCached.nodes[change.index] = change.element
						}
					}
					cached = newCached;
				}
			}
			//end key algorithm

			for (var i = 0, cacheCount = 0, len = data.length; i < len; i++) {
				//diff each item in the array
				var item = build(parentElement, parentTag, cached, index, data[i], cached[cacheCount], shouldReattach, index + subArrayCount || subArrayCount, editable, namespace, configs);
				if (item === undefined) continue;
				if (!item.nodes.intact) intact = false;
				if (item.$trusted) {
					//fix offset of next element if item was a trusted string w/ more than one html element
					//the first clause in the regexp matches elements
					//the second clause (after the pipe) matches text nodes
					subArrayCount += (item.match(/<[^\/]|\>\s*[^<]/g) || [0]).length
				}
				else subArrayCount += type.call(item) === ARRAY ? item.length : 1;
				cached[cacheCount++] = item
			}
			if (!intact) {
				//diff the array itself
				
				//update the list of DOM nodes by collecting the nodes from each item
				for (var i = 0, len = data.length; i < len; i++) {
					if (cached[i] != null) nodes.push.apply(nodes, cached[i].nodes)
				}
				//remove items from the end of the array if the new array is shorter than the old one
				//if errors ever happen here, the issue is most likely a bug in the construction of the `cached` data structure somewhere earlier in the program
				for (var i = 0, node; node = cached.nodes[i]; i++) {
					if (node.parentNode != null && nodes.indexOf(node) < 0) clear([node], [cached[i]])
				}
				if (data.length < cached.length) cached.length = data.length;
				cached.nodes = nodes
			}
		}
		else if (data != null && dataType === OBJECT) {
			var views = [], controllers = []
			while (data.view) {
				var view = data.view.$original || data.view
				var controllerIndex = m.redraw.strategy() == "diff" && cached.views ? cached.views.indexOf(view) : -1
				var controller = controllerIndex > -1 ? cached.controllers[controllerIndex] : new (data.controller || noop)
				var key = data && data.attrs && data.attrs.key
				data = pendingRequests == 0 || (cached && cached.controllers && cached.controllers.indexOf(controller) > -1) ? data.view(controller) : {tag: "placeholder"}
				if (data.subtree === "retain") return cached;
				if (key) {
					if (!data.attrs) data.attrs = {}
					data.attrs.key = key
				}
				if (controller.onunload) unloaders.push({controller: controller, handler: controller.onunload})
				views.push(view)
				controllers.push(controller)
			}
			if (!data.tag && controllers.length) throw new Error("Component template must return a virtual element, not an array, string, etc.")
			if (!data.attrs) data.attrs = {};
			if (!cached.attrs) cached.attrs = {};

			var dataAttrKeys = Object.keys(data.attrs)
			var hasKeys = dataAttrKeys.length > ("key" in data.attrs ? 1 : 0)
			//if an element is different enough from the one in cache, recreate it
			if (data.tag != cached.tag || dataAttrKeys.sort().join() != Object.keys(cached.attrs).sort().join() || data.attrs.id != cached.attrs.id || data.attrs.key != cached.attrs.key || (m.redraw.strategy() == "all" && (!cached.configContext || cached.configContext.retain !== true)) || (m.redraw.strategy() == "diff" && cached.configContext && cached.configContext.retain === false)) {
				if (cached.nodes.length) clear(cached.nodes);
				if (cached.configContext && typeof cached.configContext.onunload === FUNCTION) cached.configContext.onunload()
				if (cached.controllers) {
					for (var i = 0, controller; controller = cached.controllers[i]; i++) {
						if (typeof controller.onunload === FUNCTION) controller.onunload({preventDefault: noop})
					}
				}
			}
			if (type.call(data.tag) != STRING) return;

			var node, isNew = cached.nodes.length === 0;
			if (data.attrs.xmlns) namespace = data.attrs.xmlns;
			else if (data.tag === "svg") namespace = "http://www.w3.org/2000/svg";
			else if (data.tag === "math") namespace = "http://www.w3.org/1998/Math/MathML";
			
			if (isNew) {
				if (data.attrs.is) node = namespace === undefined ? $document.createElement(data.tag, data.attrs.is) : $document.createElementNS(namespace, data.tag, data.attrs.is);
				else node = namespace === undefined ? $document.createElement(data.tag) : $document.createElementNS(namespace, data.tag);
				cached = {
					tag: data.tag,
					//set attributes first, then create children
					attrs: hasKeys ? setAttributes(node, data.tag, data.attrs, {}, namespace) : data.attrs,
					children: data.children != null && data.children.length > 0 ?
						build(node, data.tag, undefined, undefined, data.children, cached.children, true, 0, data.attrs.contenteditable ? node : editable, namespace, configs) :
						data.children,
					nodes: [node]
				};
				if (controllers.length) {
					cached.views = views
					cached.controllers = controllers
					for (var i = 0, controller; controller = controllers[i]; i++) {
						if (controller.onunload && controller.onunload.$old) controller.onunload = controller.onunload.$old
						if (pendingRequests && controller.onunload) {
							var onunload = controller.onunload
							controller.onunload = noop
							controller.onunload.$old = onunload
						}
					}
				}
				
				if (cached.children && !cached.children.nodes) cached.children.nodes = [];
				//edge case: setting value on <select> doesn't work before children exist, so set it again after children have been created
				if (data.tag === "select" && "value" in data.attrs) setAttributes(node, data.tag, {value: data.attrs.value}, {}, namespace);
				parentElement.insertBefore(node, parentElement.childNodes[index] || null)
			}
			else {
				node = cached.nodes[0];
				if (hasKeys) setAttributes(node, data.tag, data.attrs, cached.attrs, namespace);
				cached.children = build(node, data.tag, undefined, undefined, data.children, cached.children, false, 0, data.attrs.contenteditable ? node : editable, namespace, configs);
				cached.nodes.intact = true;
				if (controllers.length) {
					cached.views = views
					cached.controllers = controllers
				}
				if (shouldReattach === true && node != null) parentElement.insertBefore(node, parentElement.childNodes[index] || null)
			}
			//schedule configs to be called. They are called after `build` finishes running
			if (typeof data.attrs["config"] === FUNCTION) {
				var context = cached.configContext = cached.configContext || {};

				// bind
				var callback = function(data, args) {
					return function() {
						return data.attrs["config"].apply(data, args)
					}
				};
				configs.push(callback(data, [node, !isNew, context, cached]))
			}
		}
		else if (typeof data != FUNCTION) {
			//handle text nodes
			var nodes;
			if (cached.nodes.length === 0) {
				if (data.$trusted) {
					nodes = injectHTML(parentElement, index, data)
				}
				else {
					nodes = [$document.createTextNode(data)];
					if (!parentElement.nodeName.match(voidElements)) parentElement.insertBefore(nodes[0], parentElement.childNodes[index] || null)
				}
				cached = "string number boolean".indexOf(typeof data) > -1 ? new data.constructor(data) : data;
				cached.nodes = nodes
			}
			else if (cached.valueOf() !== data.valueOf() || shouldReattach === true) {
				nodes = cached.nodes;
				if (!editable || editable !== $document.activeElement) {
					if (data.$trusted) {
						clear(nodes, cached);
						nodes = injectHTML(parentElement, index, data)
					}
					else {
						//corner case: replacing the nodeValue of a text node that is a child of a textarea/contenteditable doesn't work
						//we need to update the value property of the parent textarea or the innerHTML of the contenteditable element instead
						if (parentTag === "textarea") parentElement.value = data;
						else if (editable) editable.innerHTML = data;
						else {
							if (nodes[0].nodeType === 1 || nodes.length > 1) { //was a trusted string
								clear(cached.nodes, cached);
								nodes = [$document.createTextNode(data)]
							}
							parentElement.insertBefore(nodes[0], parentElement.childNodes[index] || null);
							nodes[0].nodeValue = data
						}
					}
				}
				cached = new data.constructor(data);
				cached.nodes = nodes
			}
			else cached.nodes.intact = true
		}

		return cached
	}
	function sortChanges(a, b) {return a.action - b.action || a.index - b.index}
	function setAttributes(node, tag, dataAttrs, cachedAttrs, namespace) {
		for (var attrName in dataAttrs) {
			var dataAttr = dataAttrs[attrName];
			var cachedAttr = cachedAttrs[attrName];
			if (!(attrName in cachedAttrs) || (cachedAttr !== dataAttr)) {
				cachedAttrs[attrName] = dataAttr;
				try {
					//`config` isn't a real attributes, so ignore it
					if (attrName === "config" || attrName == "key") continue;
					//hook event handlers to the auto-redrawing system
					else if (typeof dataAttr === FUNCTION && attrName.indexOf("on") === 0) {
						node[attrName] = autoredraw(dataAttr, node)
					}
					//handle `style: {...}`
					else if (attrName === "style" && dataAttr != null && type.call(dataAttr) === OBJECT) {
						for (var rule in dataAttr) {
							if (cachedAttr == null || cachedAttr[rule] !== dataAttr[rule]) node.style[rule] = dataAttr[rule]
						}
						for (var rule in cachedAttr) {
							if (!(rule in dataAttr)) node.style[rule] = ""
						}
					}
					//handle SVG
					else if (namespace != null) {
						if (attrName === "href") node.setAttributeNS("http://www.w3.org/1999/xlink", "href", dataAttr);
						else if (attrName === "className") node.setAttribute("class", dataAttr);
						else node.setAttribute(attrName, dataAttr)
					}
					//handle cases that are properties (but ignore cases where we should use setAttribute instead)
					//- list and form are typically used as strings, but are DOM element references in js
					//- when using CSS selectors (e.g. `m("[style='']")`), style is used as a string, but it's an object in js
					else if (attrName in node && !(attrName === "list" || attrName === "style" || attrName === "form" || attrName === "type" || attrName === "width" || attrName === "height")) {
						//#348 don't set the value if not needed otherwise cursor placement breaks in Chrome
						if (tag !== "input" || node[attrName] !== dataAttr) node[attrName] = dataAttr
					}
					else node.setAttribute(attrName, dataAttr)
				}
				catch (e) {
					//swallow IE's invalid argument errors to mimic HTML's fallback-to-doing-nothing-on-invalid-attributes behavior
					if (e.message.indexOf("Invalid argument") < 0) throw e
				}
			}
			//#348 dataAttr may not be a string, so use loose comparison (double equal) instead of strict (triple equal)
			// PDF fix for issue #701 https://github.com/lhorie/mithril.js/issues/701
            //#348 dataAttr may not be a string, so use loose comparison (double equal) instead of strict (triple equal)
            // PDF updates per Mithril issue #691 and Issue #701
			else if (attrName === "value" && (tag === "input" || tag === "textarea") && node.value != dataAttr) {
			    node[attrName] = dataAttr;
			}
			// The below fixes seem to break selects (the "selected" parts) so backing it all out for now, except for the textarea addition above
			/*
			else if (attrName === "checked" || attrName === "selected") node[attrName] = !!dataAttr; 
			else if (node[attrName] != dataAttr) node[attrName] = dataAttr;
			*/
			/*
            else if (attrName === "value" && (tag === "input" || tag === "textarea" || tag === "select") && node.value != dataAttr) {
                node.value = dataAttr;
            }
            else if (attrName === "checked" && (tag === "input") && node.checked != dataAttr) {
                // TODO: Maybe this case should be more selective to checkbox and radio?
                node.checked = !!dataAttr;
            }
            else if (attrName === "selected" && (tag === "option") && node.selected != dataAttr) {
                node.selected = !!dataAttr;
            }
            else if (attrName === "selectionStart" && (tag === "input" || tag === "textarea") && node.selectionStart != dataAttr) {
                node.selectionStart = dataAttr;
            }
            else if (attrName === "selectionEnd" && (tag === "input" || tag === "textarea") && node.selectionEnd != dataAttr) {
                node.selectionEnd = dataAttr;
            }
            else if (attrName === "selectionDirection" && (tag === "input" || tag === "textarea") && node.selectionDirection != dataAttr) {
                node.selectionDirection = dataAttr;
            }
            else if (attrName === "scrollTop" && node.scrollTop != dataAttr) {
                // TODO: Maybe this case should be more selective?
                node.scrollTop = dataAttr;
            }
            else if (tag === "keygen") {
                throw new Error("keygen support unfininshed");
            }
            */
		}
		return cachedAttrs
	}
	function clear(nodes, cached) {
		for (var i = nodes.length - 1; i > -1; i--) {
			if (nodes[i] && nodes[i].parentNode) {
				try {nodes[i].parentNode.removeChild(nodes[i])}
				catch (e) {} //ignore if this fails due to order of events (see http://stackoverflow.com/questions/21926083/failed-to-execute-removechild-on-node)
				cached = [].concat(cached);
				if (cached[i]) unload(cached[i])
			}
		}
		if (nodes.length != 0) nodes.length = 0
	}
	function unload(cached) {
		if (cached.configContext && typeof cached.configContext.onunload === FUNCTION) {
			cached.configContext.onunload();
			cached.configContext.onunload = null
		}
		if (cached.controllers) {
			for (var i = 0, controller; controller = cached.controllers[i]; i++) {
				if (typeof controller.onunload === FUNCTION) controller.onunload({preventDefault: noop});
			}
		}
		if (cached.children) {
			if (type.call(cached.children) === ARRAY) {
				for (var i = 0, child; child = cached.children[i]; i++) unload(child)
			}
			else if (cached.children.tag) unload(cached.children)
		}
	}
	function injectHTML(parentElement, index, data) {
		var nextSibling = parentElement.childNodes[index];
		if (nextSibling) {
			var isElement = nextSibling.nodeType != 1;
			var placeholder = $document.createElement("span");
			if (isElement) {
				parentElement.insertBefore(placeholder, nextSibling || null);
				placeholder.insertAdjacentHTML("beforebegin", data);
				parentElement.removeChild(placeholder)
			}
			else nextSibling.insertAdjacentHTML("beforebegin", data)
		}
		else parentElement.insertAdjacentHTML("beforeend", data);
		var nodes = [];
		while (parentElement.childNodes[index] !== nextSibling) {
			nodes.push(parentElement.childNodes[index]);
			index++
		}
		return nodes
	}
	function autoredraw(callback, object) {
		return function(e) {
			e = e || event;
			m.redraw.strategy("diff");
			m.startComputation();
			try {return callback.call(object, e)}
			finally {
				endFirstComputation()
			}
		}
	}

	var html;
	var documentNode = {
		appendChild: function(node) {
			if (html === undefined) html = $document.createElement("html");
			if ($document.documentElement && $document.documentElement !== node) {
				$document.replaceChild(node, $document.documentElement)
			}
			else $document.appendChild(node);
			this.childNodes = $document.childNodes
		},
		insertBefore: function(node) {
			this.appendChild(node)
		},
		childNodes: []
	};
	var nodeCache = [], cellCache = {};
	m.render = function(root, cell, forceRecreation) {
		var configs = [];
		if (!root) throw new Error("Ensure the DOM element being passed to m.route/m.mount/m.render is not undefined.");
		var id = getCellCacheKey(root);
		var isDocumentRoot = root === $document;
		var node = isDocumentRoot || root === $document.documentElement ? documentNode : root;
		if (isDocumentRoot && cell.tag != "html") cell = {tag: "html", attrs: {}, children: cell};
		if (cellCache[id] === undefined) clear(node.childNodes);
		if (forceRecreation === true) reset(root);
		cellCache[id] = build(node, null, undefined, undefined, cell, cellCache[id], false, 0, null, undefined, configs);
		for (var i = 0, len = configs.length; i < len; i++) configs[i]()
	};
	function getCellCacheKey(element) {
		var index = nodeCache.indexOf(element);
		return index < 0 ? nodeCache.push(element) - 1 : index
	}

	m.trust = function(value) {
		value = new String(value);
		value.$trusted = true;
		return value
	};

	function gettersetter(store) {
		var prop = function() {
			if (arguments.length) store = arguments[0];
			return store
		};

		prop.toJSON = function() {
			return store
		};

		return prop
	}

	m.prop = function (store) {
		//note: using non-strict equality check here because we're checking if store is null OR undefined
		if (((store != null && type.call(store) === OBJECT) || typeof store === FUNCTION) && typeof store.then === FUNCTION) {
			return propify(store)
		}

		return gettersetter(store)
	};

	var roots = [], components = [], controllers = [], lastRedrawId = null, lastRedrawCallTime = 0, computePreRedrawHook = null, computePostRedrawHook = null, prevented = false, topComponent, unloaders = [];
	var FRAME_BUDGET = 16; //60 frames per second = 1 call per 16 ms
	function parameterize(component, args) {
		var controller = function() {
			return (component.controller || noop).apply(this, args) || this
		}
		var view = function(ctrl) {
			if (arguments.length > 1) args = args.concat([].slice.call(arguments, 1))
			return component.view.apply(component, args ? [ctrl].concat(args) : [ctrl])
		}
		view.$original = component.view
		var output = {controller: controller, view: view}
		if (args[0] && args[0].key != null) output.attrs = {key: args[0].key}
		return output
	}
	m.component = function(component) {
		return parameterize(component, [].slice.call(arguments, 1))
	}
	m.mount = m.module = function(root, component) {
		if (!root) throw new Error("Please ensure the DOM element exists before rendering a template into it.");
		var index = roots.indexOf(root);
		if (index < 0) index = roots.length;
		
		var isPrevented = false;
		var event = {preventDefault: function() {
			isPrevented = true;
			computePreRedrawHook = computePostRedrawHook = null;
		}};
		for (var i = 0, unloader; unloader = unloaders[i]; i++) {
			unloader.handler.call(unloader.controller, event)
			unloader.controller.onunload = null
		}
		if (isPrevented) {
			for (var i = 0, unloader; unloader = unloaders[i]; i++) unloader.controller.onunload = unloader.handler
		}
		else unloaders = []
		
		if (controllers[index] && typeof controllers[index].onunload === FUNCTION) {
			controllers[index].onunload(event)
		}
		
		if (!isPrevented) {
			m.redraw.strategy("all");
			m.startComputation();
			roots[index] = root;
			if (arguments.length > 2) component = subcomponent(component, [].slice.call(arguments, 2))
			var currentComponent = topComponent = component = component || {controller: function() {}};
			var constructor = component.controller || noop
			var controller = new constructor;
			//controllers may call m.mount recursively (via m.route redirects, for example)
			//this conditional ensures only the last recursive m.mount call is applied
			if (currentComponent === topComponent) {
				controllers[index] = controller;
				components[index] = component
			}
			endFirstComputation();
			return controllers[index]
		}
	};
	var redrawing = false
	m.redraw = function(force) {
		if (redrawing) return
		redrawing = true
		//lastRedrawId is a positive number if a second redraw is requested before the next animation frame
		//lastRedrawID is null if it's the first redraw and not an event handler
		if (lastRedrawId && force !== true) {
			//when setTimeout: only reschedule redraw if time between now and previous redraw is bigger than a frame, otherwise keep currently scheduled timeout
			//when rAF: always reschedule redraw
			if ($requestAnimationFrame === window.requestAnimationFrame || new Date - lastRedrawCallTime > FRAME_BUDGET) {
				if (lastRedrawId > 0) $cancelAnimationFrame(lastRedrawId);
				lastRedrawId = $requestAnimationFrame(redraw, FRAME_BUDGET)
			}
		}
		else {
			redraw();
			lastRedrawId = $requestAnimationFrame(function() {lastRedrawId = null}, FRAME_BUDGET)
		}
		redrawing = false
	};
	m.redraw.strategy = m.prop();
	function redraw() {
		if (computePreRedrawHook) {
			computePreRedrawHook()
			computePreRedrawHook = null
		}
		for (var i = 0, root; root = roots[i]; i++) {
			if (controllers[i]) {
				var args = components[i].controller && components[i].controller.$$args ? [controllers[i]].concat(components[i].controller.$$args) : [controllers[i]]
				m.render(root, components[i].view ? components[i].view(controllers[i], args) : "")
			}
		}
		//after rendering within a routed context, we need to scroll back to the top, and fetch the document title for history.pushState
		if (computePostRedrawHook) {
			computePostRedrawHook();
			computePostRedrawHook = null
		}
		lastRedrawId = null;
		lastRedrawCallTime = new Date;
		m.redraw.strategy("diff")
	}

	var pendingRequests = 0;
	m.startComputation = function() {pendingRequests++};
	m.endComputation = function() {
		pendingRequests = Math.max(pendingRequests - 1, 0);
		if (pendingRequests === 0) m.redraw()
	};
	var endFirstComputation = function() {
		if (m.redraw.strategy() == "none") {
			pendingRequests--
			m.redraw.strategy("diff")
		}
		else m.endComputation();
	}

	m.withAttr = function(prop, withAttrCallback) {
		return function(e) {
			e = e || event;
			var currentTarget = e.currentTarget || this;
			withAttrCallback(prop in currentTarget ? currentTarget[prop] : currentTarget.getAttribute(prop))
		}
	};

	//routing
	var modes = {pathname: "", hash: "#", search: "?"};
	var redirect = noop, routeParams, currentRoute, isDefaultRoute = false;
	m.route = function() {
		//m.route()
		if (arguments.length === 0) return currentRoute;
		//m.route(el, defaultRoute, routes)
		else if (arguments.length === 3 && type.call(arguments[1]) === STRING) {
			var root = arguments[0], defaultRoute = arguments[1], router = arguments[2];
			redirect = function(source) {
				var path = currentRoute = normalizeRoute(source);
				if (!routeByValue(root, router, path)) {
					if (isDefaultRoute) throw new Error("Ensure the default route matches one of the routes defined in m.route")
					isDefaultRoute = true
					m.route(defaultRoute, true)
					isDefaultRoute = false
				}
			};
			var listener = m.route.mode === "hash" ? "onhashchange" : "onpopstate";
			window[listener] = function() {
				var path = $location[m.route.mode]
				if (m.route.mode === "pathname") path += $location.search
				if (currentRoute != normalizeRoute(path)) {
					redirect(path)
				}
			};
			computePreRedrawHook = setScroll;
			window[listener]()
		}
		//config: m.route
		else if (arguments[0].addEventListener || arguments[0].attachEvent) {
			var element = arguments[0];
			var isInitialized = arguments[1];
			var context = arguments[2];
			var vdom = arguments[3];
			element.href = (m.route.mode !== 'pathname' ? $location.pathname : '') + modes[m.route.mode] + vdom.attrs.href;
			if (element.addEventListener) {
				element.removeEventListener("click", routeUnobtrusive);
				element.addEventListener("click", routeUnobtrusive)
			}
			else {
				element.detachEvent("onclick", routeUnobtrusive);
				element.attachEvent("onclick", routeUnobtrusive)
			}
		}
		//m.route(route, params, shouldReplaceHistoryEntry)
		else if (type.call(arguments[0]) === STRING) {
			var oldRoute = currentRoute;
			currentRoute = arguments[0];
			var args = arguments[1] || {}
			var queryIndex = currentRoute.indexOf("?")
			var params = queryIndex > -1 ? parseQueryString(currentRoute.slice(queryIndex + 1)) : {}
			for (var i in args) params[i] = args[i]
			var querystring = buildQueryString(params)
			var currentPath = queryIndex > -1 ? currentRoute.slice(0, queryIndex) : currentRoute
			if (querystring) currentRoute = currentPath + (currentPath.indexOf("?") === -1 ? "?" : "&") + querystring;

			var shouldReplaceHistoryEntry = (arguments.length === 3 ? arguments[2] : arguments[1]) === true || oldRoute === arguments[0];

			if (window.history.pushState) {
				computePreRedrawHook = setScroll
				computePostRedrawHook = function() {
					window.history[shouldReplaceHistoryEntry ? "replaceState" : "pushState"](null, $document.title, modes[m.route.mode] + currentRoute);
				};
				redirect(modes[m.route.mode] + currentRoute)
			}
			else {
				$location[m.route.mode] = currentRoute
				redirect(modes[m.route.mode] + currentRoute)
			}
		}
	};
	m.route.param = function(key) {
		if (!routeParams) throw new Error("You must call m.route(element, defaultRoute, routes) before calling m.route.param()")
		return routeParams[key]
	};
	m.route.mode = "search";
	function normalizeRoute(route) {
		return route.slice(modes[m.route.mode].length)
	}
	function routeByValue(root, router, path) {
		routeParams = {};

		var queryStart = path.indexOf("?");
		if (queryStart !== -1) {
			routeParams = parseQueryString(path.substr(queryStart + 1, path.length));
			path = path.substr(0, queryStart)
		}

		// Get all routes and check if there's
		// an exact match for the current path
		var keys = Object.keys(router);
		var index = keys.indexOf(path);
		if(index !== -1){
			m.mount(root, router[keys [index]]);
			return true;
		}

		for (var route in router) {
			if (route === path) {
				m.mount(root, router[route]);
				return true
			}

			var matcher = new RegExp("^" + route.replace(/:[^\/]+?\.{3}/g, "(.*?)").replace(/:[^\/]+/g, "([^\\/]+)") + "\/?$");

			if (matcher.test(path)) {
				path.replace(matcher, function() {
					var keys = route.match(/:[^\/]+/g) || [];
					var values = [].slice.call(arguments, 1, -2);
					for (var i = 0, len = keys.length; i < len; i++) routeParams[keys[i].replace(/:|\./g, "")] = decodeURIComponent(values[i])
					m.mount(root, router[route])
				});
				return true
			}
		}
	}
	function routeUnobtrusive(e) {
		e = e || event;
		if (e.ctrlKey || e.metaKey || e.which === 2) return;
		if (e.preventDefault) e.preventDefault();
		else e.returnValue = false;
		var currentTarget = e.currentTarget || e.srcElement;
		var args = m.route.mode === "pathname" && currentTarget.search ? parseQueryString(currentTarget.search.slice(1)) : {};
		while (currentTarget && currentTarget.nodeName.toUpperCase() != "A") currentTarget = currentTarget.parentNode
		m.route(currentTarget[m.route.mode].slice(modes[m.route.mode].length), args)
	}
	function setScroll() {
		if (m.route.mode != "hash" && $location.hash) $location.hash = $location.hash;
		else window.scrollTo(0, 0)
	}
	function buildQueryString(object, prefix) {
		var duplicates = {}
		var str = []
		for (var prop in object) {
			var key = prefix ? prefix + "[" + prop + "]" : prop
			var value = object[prop]
			var valueType = type.call(value)
			var pair = (value === null) ? encodeURIComponent(key) :
				valueType === OBJECT ? buildQueryString(value, key) :
				valueType === ARRAY ? value.reduce(function(memo, item) {
					if (!duplicates[key]) duplicates[key] = {}
					if (!duplicates[key][item]) {
						duplicates[key][item] = true
						return memo.concat(encodeURIComponent(key) + "=" + encodeURIComponent(item))
					}
					return memo
				}, []).join("&") :
				encodeURIComponent(key) + "=" + encodeURIComponent(value)
			if (value !== undefined) str.push(pair)
		}
		return str.join("&")
	}
	function parseQueryString(str) {
		if (str.charAt(0) === "?") str = str.substring(1);
		
		var pairs = str.split("&"), params = {};
		for (var i = 0, len = pairs.length; i < len; i++) {
			var pair = pairs[i].split("=");
			var key = decodeURIComponent(pair[0])
			var value = pair.length == 2 ? decodeURIComponent(pair[1]) : null
			if (params[key] != null) {
				if (type.call(params[key]) !== ARRAY) params[key] = [params[key]]
				params[key].push(value)
			}
			else params[key] = value
		}
		return params
	}
	m.route.buildQueryString = buildQueryString
	m.route.parseQueryString = parseQueryString
	
	function reset(root) {
		var cacheKey = getCellCacheKey(root);
		clear(root.childNodes, cellCache[cacheKey]);
		cellCache[cacheKey] = undefined
	}

	m.deferred = function () {
		var deferred = new Deferred();
		deferred.promise = propify(deferred.promise);
		return deferred
	};
	function propify(promise, initialValue) {
		var prop = m.prop(initialValue);
		promise.then(prop);
		prop.then = function(resolve, reject) {
			return propify(promise.then(resolve, reject), initialValue)
		};
		return prop
	}
	//Promiz.mithril.js | Zolmeister | MIT
	//a modified version of Promiz.js, which does not conform to Promises/A+ for two reasons:
	//1) `then` callbacks are called synchronously (because setTimeout is too slow, and the setImmediate polyfill is too big
	//2) throwing subclasses of Error cause the error to be bubbled up instead of triggering rejection (because the spec does not account for the important use case of default browser error handling, i.e. message w/ line number)
	function Deferred(successCallback, failureCallback) {
		var RESOLVING = 1, REJECTING = 2, RESOLVED = 3, REJECTED = 4;
		var self = this, state = 0, promiseValue = 0, next = [];

		self["promise"] = {};

		self["resolve"] = function(value) {
			if (!state) {
				promiseValue = value;
				state = RESOLVING;

				fire()
			}
			return this
		};

		self["reject"] = function(value) {
			if (!state) {
				promiseValue = value;
				state = REJECTING;

				fire()
			}
			return this
		};

		self.promise["then"] = function(successCallback, failureCallback) {
			var deferred = new Deferred(successCallback, failureCallback);
			if (state === RESOLVED) {
				deferred.resolve(promiseValue)
			}
			else if (state === REJECTED) {
				deferred.reject(promiseValue)
			}
			else {
				next.push(deferred)
			}
			return deferred.promise
		};

		function finish(type) {
			state = type || REJECTED;
			next.map(function(deferred) {
				state === RESOLVED && deferred.resolve(promiseValue) || deferred.reject(promiseValue)
			})
		}

		function thennable(then, successCallback, failureCallback, notThennableCallback) {
			if (((promiseValue != null && type.call(promiseValue) === OBJECT) || typeof promiseValue === FUNCTION) && typeof then === FUNCTION) {
				try {
					// count protects against abuse calls from spec checker
					var count = 0;
					then.call(promiseValue, function(value) {
						if (count++) return;
						promiseValue = value;
						successCallback()
					}, function (value) {
						if (count++) return;
						promiseValue = value;
						failureCallback()
					})
				}
				catch (e) {
					m.deferred.onerror(e);
					promiseValue = e;
					failureCallback()
				}
			} else {
				notThennableCallback()
			}
		}

		function fire() {
			// check if it's a thenable
			var then;
			try {
				then = promiseValue && promiseValue.then
			}
			catch (e) {
				m.deferred.onerror(e);
				promiseValue = e;
				state = REJECTING;
				return fire()
			}
			thennable(then, function() {
				state = RESOLVING;
				fire()
			}, function() {
				state = REJECTING;
				fire()
			}, function() {
				try {
					if (state === RESOLVING && typeof successCallback === FUNCTION) {
						promiseValue = successCallback(promiseValue)
					}
					else if (state === REJECTING && typeof failureCallback === "function") {
						promiseValue = failureCallback(promiseValue);
						state = RESOLVING
					}
				}
				catch (e) {
					m.deferred.onerror(e);
					promiseValue = e;
					return finish()
				}

				if (promiseValue === self) {
					promiseValue = TypeError();
					finish()
				}
				else {
					thennable(then, function () {
						finish(RESOLVED)
					}, finish, function () {
						finish(state === RESOLVING && RESOLVED)
					})
				}
			})
		}
	}
	m.deferred.onerror = function(e) {
		if (type.call(e) === "[object Error]" && !e.constructor.toString().match(/ Error/)) throw e
	};

	m.sync = function(args) {
		var method = "resolve";
		function synchronizer(pos, resolved) {
			return function(value) {
				results[pos] = value;
				if (!resolved) method = "reject";
				if (--outstanding === 0) {
					deferred.promise(results);
					deferred[method](results)
				}
				return value
			}
		}

		var deferred = m.deferred();
		var outstanding = args.length;
		var results = new Array(outstanding);
		if (args.length > 0) {
			for (var i = 0; i < args.length; i++) {
				args[i].then(synchronizer(i, true), synchronizer(i, false))
			}
		}
		else deferred.resolve([]);

		return deferred.promise
	};
	function identity(value) {return value}

	function ajax(options) {
		if (options.dataType && options.dataType.toLowerCase() === "jsonp") {
			var callbackKey = "mithril_callback_" + new Date().getTime() + "_" + (Math.round(Math.random() * 1e16)).toString(36);
			var script = $document.createElement("script");

			window[callbackKey] = function(resp) {
				script.parentNode.removeChild(script);
				options.onload({
					type: "load",
					target: {
						responseText: resp
					}
				});
				window[callbackKey] = undefined
			};

			script.onerror = function(e) {
				script.parentNode.removeChild(script);

				options.onerror({
					type: "error",
					target: {
						status: 500,
						responseText: JSON.stringify({error: "Error making jsonp request"})
					}
				});
				window[callbackKey] = undefined;

				return false
			};

			script.onload = function(e) {
				return false
			};

			script.src = options.url
				+ (options.url.indexOf("?") > 0 ? "&" : "?")
				+ (options.callbackKey ? options.callbackKey : "callback")
				+ "=" + callbackKey
				+ "&" + buildQueryString(options.data || {});
			$document.body.appendChild(script)
		}
		else {
			var xhr = new window.XMLHttpRequest;
			xhr.open(options.method, options.url, true, options.user, options.password);
			xhr.onreadystatechange = function() {
				if (xhr.readyState === 4) {
					if (xhr.status >= 200 && xhr.status < 300) options.onload({type: "load", target: xhr});
					else options.onerror({type: "error", target: xhr})
				}
			};
			if (options.serialize === JSON.stringify && options.data && options.method !== "GET") {
				xhr.setRequestHeader("Content-Type", "application/json; charset=utf-8")
			}
			if (options.deserialize === JSON.parse) {
				xhr.setRequestHeader("Accept", "application/json, text/*");
			}
			if (typeof options.config === FUNCTION) {
				var maybeXhr = options.config(xhr, options);
				if (maybeXhr != null) xhr = maybeXhr
			}

			var data = options.method === "GET" || !options.data ? "" : options.data
			if (data && (type.call(data) != STRING && data.constructor != window.FormData)) {
				throw "Request data should be either be a string or FormData. Check the `serialize` option in `m.request`";
			}
			xhr.send(data);
			return xhr
		}
	}
	function bindData(xhrOptions, data, serialize) {
		if (xhrOptions.method === "GET" && xhrOptions.dataType != "jsonp") {
			var prefix = xhrOptions.url.indexOf("?") < 0 ? "?" : "&";
			var querystring = buildQueryString(data);
			xhrOptions.url = xhrOptions.url + (querystring ? prefix + querystring : "")
		}
		else xhrOptions.data = serialize(data);
		return xhrOptions
	}
	function parameterizeUrl(url, data) {
		var tokens = url.match(/:[a-z]\w+/gi);
		if (tokens && data) {
			for (var i = 0; i < tokens.length; i++) {
				var key = tokens[i].slice(1);
				url = url.replace(tokens[i], data[key]);
				delete data[key]
			}
		}
		return url
	}

	m.request = function(xhrOptions) {
		if (xhrOptions.background !== true) m.startComputation();
		var deferred = new Deferred();
		var isJSONP = xhrOptions.dataType && xhrOptions.dataType.toLowerCase() === "jsonp";
		var serialize = xhrOptions.serialize = isJSONP ? identity : xhrOptions.serialize || JSON.stringify;
		var deserialize = xhrOptions.deserialize = isJSONP ? identity : xhrOptions.deserialize || JSON.parse;
		var extract = isJSONP ? function(jsonp) {return jsonp.responseText} : xhrOptions.extract || function(xhr) {
			return xhr.responseText.length === 0 && deserialize === JSON.parse ? null : xhr.responseText
		};
		xhrOptions.method = (xhrOptions.method || 'GET').toUpperCase();
		xhrOptions.url = parameterizeUrl(xhrOptions.url, xhrOptions.data);
		xhrOptions = bindData(xhrOptions, xhrOptions.data, serialize);
		xhrOptions.onload = xhrOptions.onerror = function(e) {
			try {
				e = e || event;
				var unwrap = (e.type === "load" ? xhrOptions.unwrapSuccess : xhrOptions.unwrapError) || identity;
				var response = unwrap(deserialize(extract(e.target, xhrOptions)), e.target);
				if (e.type === "load") {
					if (type.call(response) === ARRAY && xhrOptions.type) {
						for (var i = 0; i < response.length; i++) response[i] = new xhrOptions.type(response[i])
					}
					else if (xhrOptions.type) response = new xhrOptions.type(response)
				}
				deferred[e.type === "load" ? "resolve" : "reject"](response)
			}
			catch (e) {
				m.deferred.onerror(e);
				deferred.reject(e)
			}
			if (xhrOptions.background !== true) m.endComputation()
		};
		ajax(xhrOptions);
		deferred.promise = propify(deferred.promise, xhrOptions.initialValue);
		return deferred.promise
	};

	//testing API
	m.deps = function(mock) {
		initialize(window = mock || window);
		return window;
	};
	//for internal testing only, do not use `m.deps.factory`
	m.deps.factory = app;

	return m
})(typeof window != "undefined" ? window : {});

if (typeof module != "undefined" && module !== null && module.exports) module.exports = m;
else if (typeof define === "function" && define.amd) define('mithril',[],function() {return m});

define('js/PanelSetup',["require", "exports", "./panelBuilder/PanelSpecificationCollection", "./panelBuilder/translate", "mithril"], function (require, exports, PanelSpecificationCollection, translate, m) {
    "use strict";
    // The home page -- should be a constant
    var _startPage = "page_dashboard";
    // This will hold information about all the panels used
    var _panelSpecificationCollection = new PanelSpecificationCollection();
    function startPage() {
        return _startPage;
    }
    exports.startPage = startPage;
    function panelSpecificationCollection() {
        return _panelSpecificationCollection;
    }
    exports.panelSpecificationCollection = panelSpecificationCollection;
    function addExtraFieldSpecificationsForPageSpecification(pageID, pageSpecification) {
        // console.log("addExtraFieldSpecificationsForPageSpecification", pageSpecification.section, pageID, pageSpecification);
        function addPageChangeButton(newPageID, idExtra, prompt, displayIconClass) {
            // TODO: Translate
            if (displayIconClass !== "homeButtonImage") {
                var sectionPageSpecification = _panelSpecificationCollection.getPageSpecificationForPageID(newPageID);
                prompt += ": " + sectionPageSpecification.displayName;
            }
            var iconPosition = "left";
            if (displayIconClass === "rightButtonImage")
                iconPosition = "right";
            var returnToDashboardButtonSpecification = {
                "id": pageID + idExtra,
                "valueType": "none",
                "displayPrompt": prompt,
                "displayType": "button",
                "displayClass": "narrafirma-page-change-button",
                "displayConfiguration": {
                    "action": "guiOpenSection",
                    "section": newPageID
                },
                displayIconClass: displayIconClass,
                displayPreventBreak: true,
                displayIconPosition: iconPosition
            };
            _panelSpecificationCollection.addFieldSpecificationToPanelSpecification(pageSpecification, returnToDashboardButtonSpecification);
        }
        if (pageSpecification.section !== "dashboard") {
            if (!pageSpecification.isHeader) {
                // TODO: Change the id of this field to have notes or reminder
                // Regular page -- add a footer where the page status can be set
                var statusEntryID = pageID + "_reminders";
                var completionStatusEntryFieldSpecification = {
                    id: statusEntryID,
                    valueType: "string",
                    displayType: "textarea",
                    displayName: "Reminders",
                    displayClass: "narrafirma-reminder",
                    displayPrompt: translate("#dashboard_status_entry::prompt", "You can enter <strong>reminders</strong> about this page here. They will appear on this section's home page.")
                };
                _panelSpecificationCollection.addFieldSpecificationToPanelSpecification(pageSpecification, completionStatusEntryFieldSpecification);
            }
            else {
                // Dashboard page
                // console.log("page dashboard as header", pageSpecification.id, pageSpecification.displayType, pageSpecification);
                // Put in dashboard
                var childPageIDs = _panelSpecificationCollection.getChildPageIDListForHeaderID(pageID);
                // console.log("child pages", pageID, childPageIDs);
                if (!childPageIDs)
                    childPageIDs = [];
                // Add a display to this page for each child page in the same section
                for (var childPageIndex = 0; childPageIndex < childPageIDs.length; childPageIndex++) {
                    var childPageID = childPageIDs[childPageIndex];
                    var statusViewID = childPageID + "_reminders_dashboard";
                    var childPageSpecification = _panelSpecificationCollection.getPageSpecificationForPageID(childPageID);
                    // console.log("childPageID", childPageSpecification, childPageID);
                    if (!childPageSpecification)
                        console.log("Error: problem finding page definition for", childPageID);
                    if (childPageSpecification && childPageSpecification.displayType === "page") {
                        var prompt = translate(childPageID + "::title", childPageSpecification.displayName);
                        var tooltip = childPageSpecification.tooltipText || null;
                        // Wrap the prompt as a link to the page
                        var properties = {
                            href: "javascript:narrafirma_openPage('" + childPageID + "')"
                        };
                        if (childPageSpecification.tooltipText) {
                            properties.title = childPageSpecification.tooltipText;
                        }
                        prompt = m("div.narrafirma-dashboard-page-link", m("a", properties, prompt));
                        if (childPageSpecification.headerAbove) {
                            prompt = [m("div.narrafirma-dashboard-header", childPageSpecification.headerAbove), prompt];
                        }
                        // + " " + translate("#dashboard_status_label", "reminders:")
                        // prompt = prompt  + " ";
                        // console.log("about to call panelBuilder to add one questionAnswer for child page's status", childPageID);
                        var completionStatusDisplayFieldSpecification = {
                            id: statusViewID,
                            valueType: "none",
                            displayType: "questionAnswer",
                            // displayName: prompt,
                            displayPrompt: prompt,
                            displayConfiguration: childPageID + "_reminders"
                        };
                        _panelSpecificationCollection.addFieldSpecificationToPanelSpecification(pageSpecification, completionStatusDisplayFieldSpecification);
                    }
                }
            }
            // Add button at bottom of each page to move to previous
            if (pageSpecification.previousPageID) {
                // TODO: Translate
                addPageChangeButton(pageSpecification.previousPageID, "_previousPageButton", "Previous", "leftButtonImage");
            }
            else {
                addPageChangeButton(_startPage, "_returnToDashboardButton", "Go to home page", "homeButtonImage");
            }
            // Add button at bottom of each page to move forward
            if (pageSpecification.nextPageID) {
                addPageChangeButton(pageSpecification.nextPageID, "_nextPageButton", "Next", "rightButtonImage");
            }
            else {
                addPageChangeButton(_startPage, "_returnToDashboardButton", "Go to home page", "homeButtonImage");
            }
        }
    }
    function processAllPanels() {
        var panels = _panelSpecificationCollection.buildListOfPanels();
        // console.log("processAllPanels", panels);
        var lastPageID = null;
        var panelIndex;
        var panel;
        // Loop to setup navigation
        for (panelIndex = 0; panelIndex < panels.length; panelIndex++) {
            panel = panels[panelIndex];
            // console.log("defining navigatation for panel", panel.id);
            // For panels that are a "page", add to top level pages choices and set up navigation
            if (panel.displayType === "page") {
                // console.log("pushing page", panel);
                // Make it easy to lookup previous and next pages from a page
                if (!panel.isHeader) {
                    var previousPage = _panelSpecificationCollection.getPageSpecificationForPageID(lastPageID);
                    previousPage.nextPageID = panel.id;
                    panel.previousPageID = lastPageID;
                }
                lastPageID = panel.id;
            }
        }
        var lastHeader = null;
        var lastSection = null;
        // A separate loop is needed here to ensure page navigation links have been set up when determining additional buttons for pages
        for (panelIndex = 0; panelIndex < panels.length; panelIndex++) {
            panel = panels[panelIndex];
            if (panel.isHeader) {
                lastHeader = panel.id;
                lastSection = panel.section;
            }
            // console.log("defining panel extra fields and help", panel.id);
            // For panels that are a "page", add extra buttons
            if (panel.displayType === "page") {
                addExtraFieldSpecificationsForPageSpecification(panel.id, panel);
            }
            panel.helpSection = lastSection;
            panel.helpPage = panel.id;
            panel.sectionHeaderPageID = lastHeader;
            for (var fieldIndex = 0; fieldIndex < panel.panelFields.length; fieldIndex++) {
                var fieldSpec = panel.panelFields[fieldIndex];
                fieldSpec.helpSection = lastSection;
                fieldSpec.helpPage = panel.id;
            }
        }
    }
    exports.processAllPanels = processAllPanels;
    // TODO: Temporary for generating JSON navigation data from AMD module
    function generateNavigationDataInJSON() {
        var sections = [];
        var sectionBeingProcessed;
        var pageBeingProcessed;
        var allPanels = _panelSpecificationCollection.buildListOfPanels();
        allPanels.forEach(function (panel) {
            // console.log("panel", panel.displayType, panel.id, panel.section, panel.displayName);
            if (panel.isHeader) {
                if (sectionBeingProcessed)
                    sections.push(sectionBeingProcessed);
                sectionBeingProcessed = {
                    section: panel.section,
                    sectionName: panel.displayName,
                    pages: []
                };
            }
            var navigationInfo = {
                panelID: panel.id,
                panelName: panel.displayName
            };
            if (panel.displayType === "page") {
                sectionBeingProcessed.pages.push(navigationInfo);
                pageBeingProcessed = navigationInfo;
            }
            else {
                if (!pageBeingProcessed.extraPanels)
                    pageBeingProcessed.extraPanels = [];
                pageBeingProcessed.extraPanels.push(navigationInfo);
            }
        });
        // console.log("JSON for navigation:");
        // console.log(JSON.stringify(sections, null, 4));
    }
    // TODO: For helping create all the models -- temporary
    function printModels() {
        console.log("-------------------------------------------------");
        console.log("panelSpecificationCollection", _panelSpecificationCollection);
        console.log("models", _panelSpecificationCollection.modelClassToModelFieldSpecificationsMap);
        var allModels = JSON.stringify(_panelSpecificationCollection.modelClassToModelFieldSpecificationsMap, null, 4);
        console.log("models JSON", allModels);
        // window.open('data:text/plain;charset=utf-8,' + escape(allModels));
        console.log("stop");
        console.log("-------------------------------------------------");
    }
});

define('js/ClientState',["require", "exports", "./PanelSetup"], function (require, exports, PanelSetup) {
    "use strict";
    // m.route.mode = "hash";
    function hash(newValue) {
        if (newValue === void 0) { newValue = null; }
        if (newValue === null)
            return window.location.hash.substr(1);
        if (history.pushState) {
            history.pushState(null, null, "#" + newValue);
        }
        else {
            location.hash = "#" + newValue;
        }
    }
    // getHashParameters derived from: http://stackoverflow.com/questions/4197591/parsing-url-hash-fragment-identifier-with-javascript
    function getHashParameters(hash) {
        var result = {};
        var match;
        // Regex for replacing addition symbol with a space
        var plusMatcher = /\+/g;
        var parameterSplitter = /([^&;=]+)=?([^&;]*)/g;
        var decode = function (s) { return decodeURIComponent(s.replace(plusMatcher, " ")); };
        while (true) {
            match = parameterSplitter.exec(hash);
            if (!match)
                break;
            result[decode(match[1])] = decode(match[2]);
        }
        return result;
    }
    var ClientState = (function () {
        function ClientState() {
            this._projectIdentifier = null;
            this._pageIdentifier = null;
            this._storyCollectionName = null;
            this._catalysisReportName = null;
            this._debugMode = null;
            this._serverStatus = "narrafirma-serverstatus-ok";
            this._serverStatusText = "";
            // This should only be set by Globals
            this._project = null;
        }
        ClientState.prototype.projectIdentifier = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._projectIdentifier = newValue;
            }
            return this._projectIdentifier;
        };
        ClientState.prototype.pageIdentifier = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._pageIdentifier = newValue;
            }
            return this._pageIdentifier;
        };
        ClientState.prototype.storyCollectionName = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._storyCollectionName = newValue;
            }
            return this._storyCollectionName;
        };
        ClientState.prototype.catalysisReportName = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._catalysisReportName = newValue;
            }
            return this._catalysisReportName;
        };
        // Read-only convenience accessor
        ClientState.prototype.catalysisReportIdentifier = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue)
                throw new Error("catalysisReportIdentifier: setting value is not supported");
            var catalysisReportIdentifier = this._project.findCatalysisReport(this._catalysisReportName);
            if (!catalysisReportIdentifier) {
                console.log("Problem finding catalysisReportIdentifier for: " + this._catalysisReportName);
                return null;
            }
            return catalysisReportIdentifier;
        };
        ClientState.prototype.debugMode = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._debugMode = newValue;
            }
            return this._debugMode;
        };
        ClientState.prototype.serverStatus = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._serverStatus = newValue;
            }
            return this._serverStatus;
        };
        ClientState.prototype.serverStatusText = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                this._serverStatusText = newValue;
            }
            return this._serverStatusText;
        };
        ClientState.prototype.initialize = function () {
            var fragment = hash();
            // console.log("fragment when page first loaded", fragment);
            var initialHashParameters = getHashParameters(fragment);
            if (initialHashParameters["project"])
                this._projectIdentifier = initialHashParameters["project"];
            if (initialHashParameters["page"])
                this._pageIdentifier = "page_" + initialHashParameters["page"];
            if (initialHashParameters["storyCollection"])
                this._storyCollectionName = initialHashParameters["storyCollection"];
            if (initialHashParameters["catalysisReport"])
                this._catalysisReportName = initialHashParameters["catalysisReport"];
            if (initialHashParameters["debugMode"])
                this._debugMode = initialHashParameters["debugMode"];
            // Ensure defaults
            if (!initialHashParameters["page"])
                this._pageIdentifier = PanelSetup.startPage();
        };
        ClientState.prototype.hashStringForClientState = function () {
            var result = "";
            var fields = [
                { id: "_projectIdentifier", key: "project" },
                { id: "_pageIdentifier", key: "page" },
                { id: "_storyCollectionName", key: "storyCollection" },
                { id: "_catalysisReportName", key: "catalysisReport" },
                { id: "_debugMode", key: "debugMode" }
            ];
            for (var i = 0; i < fields.length; i++) {
                var field = fields[i];
                var value = this[field.id];
                if (!value)
                    continue;
                if (field.key === "page" && value)
                    value = value.substring("page_".length);
                if (result)
                    result += "&";
                result += field.key + "=" + encodeURIComponent(value);
            }
            // console.log("hashStringForClientState", result, clientState);
            return result;
        };
        ClientState.prototype.urlHashFragmentChanged = function (pageDisplayer) {
            var newHash = hash();
            console.log("urlHashFragmentChanged", newHash);
            // console.log("current clientState", clientState);
            var hashParameters = getHashParameters(newHash);
            // console.log("new hashParameters", hashParameters);
            var currentProjectIdentifier = this._projectIdentifier;
            if (currentProjectIdentifier) {
                if (hashParameters.project && hashParameters.project !== currentProjectIdentifier) {
                    // Force a complete page reload for now, as needs to create a new Pointrel client
                    // TODO: Should we shut down the current Pointrel client first?
                    alert("About to trigger page reload for changed project");
                    location.reload();
                    return;
                }
            }
            else {
                // console.log("changing client state for page", this._projectIdentifier, hashParameters.project);
                this._projectIdentifier = hashParameters.project;
            }
            var selectedPage = hashParameters.page;
            if (!selectedPage) {
                selectedPage = PanelSetup.startPage();
            }
            else {
                selectedPage = "page_" + selectedPage;
            }
            if (selectedPage !== this._pageIdentifier) {
                // console.log("changing client state for page from:", this._pageIdentifier, "to:", selectedPage);
                this._pageIdentifier = selectedPage;
            }
            if (hashParameters.storyCollection && hashParameters.storyCollection !== this._storyCollectionName) {
                // console.log("changing client state for storyCollection", this._storyCollectionIdentifier, hashParameters.storyCollection);
                this._storyCollectionName = hashParameters.storyCollection;
            }
            if (hashParameters.catalysisReport && hashParameters.catalysisReport !== this._catalysisReportName) {
                // console.log("changing client state for catalysisReport", this._catalysisReportName, hashParameters.catalysisReport);
                this._catalysisReportName = hashParameters.catalysisReport;
            }
            if (hashParameters.debugMode && hashParameters.debugMode !== this._debugMode) {
                // console.log("changing client state for debugMode", this._debugMode, hashParameters.debugMode);
                this._debugMode = hashParameters.debugMode;
            }
            // Page displayer will handle cases where the hash is not valid and also optimizing out page redraws if staying on same page
            pageDisplayer.showPage(this._pageIdentifier);
            // console.log("done with urlHashFragmentChanged");
        };
        ClientState.prototype.updateHashIfNeededForChangedClientState = function () {
            var newHash = this.hashStringForClientState();
            if (newHash !== hash())
                hash(newHash);
        };
        return ClientState;
    })();
    return ClientState;
});

define('js/Globals',["require", "exports", "./ClientState"], function (require, exports, ClientState) {
    "use strict";
    var Globals = (function () {
        function Globals() {
        }
        Globals.clientState = function () {
            return Globals._clientState;
        };
        Globals.project = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                if (Globals._project)
                    throw new Error("Global project was previously initalized");
                Globals._project = newValue;
                Globals._clientState._project = newValue;
            }
            return Globals._project;
        };
        Globals.panelSpecificationCollection = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue !== undefined) {
                if (Globals._panelSpecificationCollection)
                    throw new Error("Global panelSpecificationCollection was previously initalized");
                Globals._panelSpecificationCollection = newValue;
            }
            return Globals._panelSpecificationCollection;
        };
        // ClientState is for this local instance only (not shared with other users or other browser tabs)
        Globals._clientState = new ClientState();
        return Globals;
    })();
    return Globals;
});

define('js/questionnaireGeneration',["require", "exports", "./Globals"], function (require, exports, Globals) {
    "use strict";
    var displayTypeToValueTypeMap = {
        // Used in questionnaire and other parts of the application
        boolean: 'boolean',
        label: "none",
        header: "none",
        checkbox: 'boolean',
        checkboxes: 'dictionary',
        text: 'string',
        textarea: 'string',
        select: "string",
        radiobuttons: "string",
        slider: "number",
        // Used only in other parts of the application
        image: "none",
        grid: 'array',
        clusteringDiagram: 'object',
        quizScoreResult: "none",
        button: "none",
        report: "none",
        recommendationTable: "none",
        templateList: "none",
        "function": "none",
        storyBrowser: 'none',
        graphBrowser: 'none',
        patternExplorer: 'none',
        observationsList: 'none',
        accumulatedItemsGrid: 'none',
        storiesList: 'none'
    };
    function convertEditorQuestions(editorQuestions, prefixQPA) {
        var adjustedQuestions = [];
        var valueOptions;
        var displayConfiguration;
        for (var questionIndex = 0; questionIndex < editorQuestions.length; questionIndex++) {
            var question = editorQuestions[questionIndex];
            // console.log("question", question);
            var shortName = question.storyQuestion_shortName || question.participantQuestion_shortName || question.annotationQuestion_shortName;
            // Including "S_" or "P_" or "A_" prefix for user-supplied question ID to prevent collisions with application fields like storyText and JavaScript functions and __proto__
            var id = prefixQPA + shortName;
            var questionType = question.storyQuestion_type || question.participantQuestion_type || question.annotationQuestion_type;
            var prompt = question.storyQuestion_text || question.participantQuestion_text || question.annotationQuestion_text;
            var options = [];
            var optionsString = question.storyQuestion_options || question.participantQuestion_options || question.annotationQuestion_options;
            if (optionsString) {
                // TODO: Improve option handling so can have standard IDs for options
                var splitOptions = optionsString.split("\n");
                // Make sure options don't have leading or trailing space and are not otherwise blank
                for (var index in splitOptions) {
                    var trimmedOption = splitOptions[index].trim();
                    if (trimmedOption) {
                        options.push(trimmedOption);
                    }
                }
            }
            // TODO: valueType might be a number or boolean sometimes
            var valueType = displayTypeToValueTypeMap[questionType];
            // Set these two vars to undefined so no object fields will appear set for these if not otherwise set
            valueOptions = undefined;
            displayConfiguration = undefined;
            if (!valueType)
                console.log("ERROR: Could not resolve valueType for ", question);
            if (questionType === "select" || questionType === "checkboxes" || questionType === "radiobuttons") {
                valueOptions = options;
            }
            else {
                if (options.length === 1) {
                    displayConfiguration = options[0];
                }
                else if (options.length > 1) {
                    displayConfiguration = options;
                }
            }
            adjustedQuestions.push({
                valueType: valueType,
                displayType: questionType,
                id: id,
                valueOptions: valueOptions,
                displayName: shortName,
                displayPrompt: prompt,
                displayConfiguration: displayConfiguration
            });
        }
        return adjustedQuestions;
    }
    exports.convertEditorQuestions = convertEditorQuestions;
    function buildIdToItemMap(itemListField, idField) {
        var project = Globals.project();
        var itemList = project.getListForField(itemListField);
        var result = {};
        itemList.forEach(function (item) {
            var id = project.tripleStore.queryLatestC(item, idField);
            result[id] = item;
        });
        return result;
    }
    function buildItemListFromIdList(idToItemMap, idItemList, idField) {
        var project = Globals.project();
        var result = [];
        idItemList.forEach(function (idItem) {
            // TODO: Fix access here for tripleStore use
            var id = project.tripleStore.queryLatestC(idItem, idField);
            var order = project.tripleStore.queryLatestC(idItem, "order");
            var item = idToItemMap[id];
            if (item) {
                // Retrieve the latest for all the fields of the object (which will include deleted/null fields)
                // TODO: Remove any deleted/null fields
                var itemObject = project.tripleStore.makeObject(item, true);
                itemObject.order = order;
                result.push(itemObject);
            }
            else {
                console.log("Editing error: Missing question definition for", idItem);
            }
        });
        result.sort(function (a, b) {
            if (a.order < b.order)
                return -1;
            if (a.order > b.order)
                return 1;
            return 0;
        });
        return result;
    }
    // Are names just hints as to purpose of code? Can never convey all aspects of interrelationships?
    function collectAllQuestions(putAnnotationQuestionsUpFront) {
        if (putAnnotationQuestionsUpFront === void 0) { putAnnotationQuestionsUpFront = null; }
        var project = Globals.project();
        var elicitingQuestions = project.collectAllElicitingQuestions();
        elicitingQuestions = convertElicitingQuestions(elicitingQuestions);
        var storyQuestions = project.collectAllStoryQuestions();
        storyQuestions = convertEditorQuestions(storyQuestions, "S_");
        var participantQuestions = project.collectAllParticipantQuestions();
        participantQuestions = convertEditorQuestions(participantQuestions, "P_");
        var annotationQuestions = project.collectAllAnnotationQuestions();
        annotationQuestions = convertEditorQuestions(annotationQuestions, "A_");
        var allQuestions = getLeadingStoryQuestions(elicitingQuestions);
        if (putAnnotationQuestionsUpFront) {
            allQuestions = allQuestions.concat(annotationQuestions, storyQuestions, participantQuestions);
        }
        else {
            allQuestions = allQuestions.concat(storyQuestions, participantQuestions, annotationQuestions);
        }
        // console.log("collectAllQuestions", allQuestions);
        return allQuestions;
    }
    exports.collectAllQuestions = collectAllQuestions;
    function getLeadingStoryQuestions(elicitingQuestions) {
        // TODO: What about idea of having IDs that go with eliciting questions so store reference to ID not text prompt?
        var elicitingQuestionValues = [];
        for (var elicitingQuestionIndex = 0; elicitingQuestionIndex < elicitingQuestions.length; elicitingQuestionIndex++) {
            var elicitingQuestionSpecification = elicitingQuestions[elicitingQuestionIndex];
            // elicitingQuestionValues.push({value: elicitingQuestionSpecification.id, text: elicitingQuestionSpecification.label});
            elicitingQuestionValues.push(elicitingQuestionSpecification.id || elicitingQuestionSpecification.shortName || elicitingQuestionSpecification.text);
        }
        // TODO: Remove redundancy
        var leadingStoryQuestions = [];
        leadingStoryQuestions.unshift({
            id: "storyName",
            displayName: "Story Name",
            displayPrompt: "Please give your story a name",
            displayType: "text",
            valueOptions: []
        });
        leadingStoryQuestions.unshift({
            id: "storyText",
            displayName: "Story Text",
            displayPrompt: "Please enter your response to the question above in the space below",
            displayType: "textarea",
            valueOptions: []
        });
        leadingStoryQuestions.unshift({
            id: "elicitingQuestion",
            displayName: "Eliciting Question",
            displayPrompt: "Please choose a question you would like to respond to",
            displayType: "select",
            valueOptions: elicitingQuestionValues
        });
        return leadingStoryQuestions;
    }
    exports.getLeadingStoryQuestions = getLeadingStoryQuestions;
    // TODO: How to save the fact we have exported this in the project? Make a copy??? Or keep original in document somewhere? Versus what is returned from server for surveys?
    function buildQuestionnaire(shortName) {
        // TODO: Redo for if questionnaire template is made of triples
        var project = Globals.project();
        var questionnaireTemplate = project.findQuestionnaireTemplate(shortName);
        if (!questionnaireTemplate)
            return null;
        // console.log("questionnaireTemplate", questionnaireTemplate);
        return buildQuestionnaireFromTemplate(questionnaireTemplate);
    }
    exports.buildQuestionnaire = buildQuestionnaire;
    function convertElicitingQuestions(elicitingQuestions) {
        var result = [];
        for (var elicitingQuestionIndex = 0; elicitingQuestionIndex < elicitingQuestions.length; elicitingQuestionIndex++) {
            var storySolicitationQuestionText = elicitingQuestions[elicitingQuestionIndex].elicitingQuestion_text;
            var storySolicitationQuestionShortName = elicitingQuestions[elicitingQuestionIndex].elicitingQuestion_shortName;
            var storySolicitationQuestionType = elicitingQuestions[elicitingQuestionIndex].elicitingQuestion_type;
            var elicitingQuestionInfo = {
                text: storySolicitationQuestionText,
                id: storySolicitationQuestionShortName,
                "type": storySolicitationQuestionType
            };
            result.push(elicitingQuestionInfo);
        }
        ensureAtLeastOneElicitingQuestion(result);
        return result;
    }
    function buildQuestionnaireFromTemplate(questionnaireTemplate) {
        var project = Globals.project();
        var usedIDs = {
            __createdIDCount: 0
        };
        var questionnaire = {
            __type: "org.workingwithstories.Questionnaire",
            title: "",
            image: "",
            startText: "",
            endText: "",
            elicitingQuestions: [],
            storyQuestions: [],
            participantQuestions: []
        };
        questionnaire.title = project.tripleStore.queryLatestC(questionnaireTemplate, "questionForm_title");
        questionnaire.image = project.tripleStore.queryLatestC(questionnaireTemplate, "questionForm_image");
        questionnaire.startText = project.tripleStore.queryLatestC(questionnaireTemplate, "questionForm_startText");
        questionnaire.endText = project.tripleStore.queryLatestC(questionnaireTemplate, "questionForm_endText");
        // TODO: Should maybe ensure unique IDs for eliciting questions?
        var allElicitingQuestions = buildIdToItemMap("project_elicitingQuestionsList", "elicitingQuestion_shortName");
        var elicitingQuestionIdentifiers = project.tripleStore.getListForSetIdentifier(project.tripleStore.queryLatestC(questionnaireTemplate, "questionForm_elicitingQuestions"));
        var elicitingQuestions = buildItemListFromIdList(allElicitingQuestions, elicitingQuestionIdentifiers, "elicitingQuestion");
        // console.log("elicitingQuestions", elicitingQuestions);
        questionnaire.elicitingQuestions = convertElicitingQuestions(elicitingQuestions);
        var allStoryQuestions = buildIdToItemMap("project_storyQuestionsList", "storyQuestion_shortName");
        var storyQuestionIdentifiers = project.tripleStore.getListForSetIdentifier(project.tripleStore.queryLatestC(questionnaireTemplate, "questionForm_storyQuestions"));
        var storyQuestions = buildItemListFromIdList(allStoryQuestions, storyQuestionIdentifiers, "storyQuestion");
        ensureUniqueQuestionIDs(usedIDs, storyQuestions);
        questionnaire.storyQuestions = convertEditorQuestions(storyQuestions, "S_");
        var allParticipantQuestions = buildIdToItemMap("project_participantQuestionsList", "participantQuestion_shortName");
        var participantQuestionIdentifiers = project.tripleStore.getListForSetIdentifier(project.tripleStore.queryLatestC(questionnaireTemplate, "questionForm_participantQuestions"));
        var participantQuestions = buildItemListFromIdList(allParticipantQuestions, participantQuestionIdentifiers, "participantQuestion");
        ensureUniqueQuestionIDs(usedIDs, participantQuestions);
        questionnaire.participantQuestions = convertEditorQuestions(participantQuestions, "P_");
        // console.log("buildQuestionnaire result", questionnaire);
        return questionnaire;
    }
    exports.buildQuestionnaireFromTemplate = buildQuestionnaireFromTemplate;
    function ensureUniqueQuestionIDs(usedIDs, editorQuestions) {
        // Validate the survey ids to prevent duplicates and missing ones; ideally this should be done in GUI somehow
        for (var index in editorQuestions) {
            var editorQuestion = editorQuestions[index];
            if (!editorQuestion.id) {
                editorQuestion.id = "question " + (++(usedIDs.__createdIDCount));
                console.log("SURVEY DESIGN ERROR: question had missing ID and one was assigned", editorQuestion);
            }
            while (usedIDs[editorQuestion.id]) {
                // ID already exists
                console.log("SURVEY DESIGN ERROR: duplicate ID", editorQuestion.id);
                editorQuestion.id = "question " + (++(usedIDs.__createdIDCount));
                console.log("SURVEY DESIGN ERROR: question had duplicate ID and a new one was assigned", editorQuestion);
            }
            usedIDs[editorQuestion.id] = true;
        }
    }
    function ensureAtLeastOneElicitingQuestion(elicitingQuestions) {
        // TODO: How to prevent this potential problem of no eliciting questions during questionnaire design in GUI?
        if (elicitingQuestions.length === 0) {
            // TODO: Translate
            var message = "No eliciting questions were defined! Adding one with 'What happened?' for testing.";
            console.log("PROBLEM", message);
            console.log("Adding an eliciting question for testing", message);
            var testElicitingQuestionInfo = {
                text: "What happened?",
                id: "what happened",
                type: { "what happened": true }
            };
            elicitingQuestions.push(testElicitingQuestionInfo);
        }
    }
    exports.ensureAtLeastOneElicitingQuestion = ensureAtLeastOneElicitingQuestion;
});

define('js/surveyCollection',["require", "exports", "./panelBuilder/translate", "./questionnaireGeneration"], function (require, exports, translate, questionnaireGeneration) {
    "use strict";
    var project;
    function setProject(theProject) {
        project = theProject;
    }
    exports.setProject = setProject;
    function getStoryField(storyID, fieldName, defaultValue) {
        var result = project.tripleStore.queryLatestC(storyID, fieldName);
        if (result === undefined || result === null)
            result = defaultValue;
        return result;
    }
    function setStoryField(storyID, fieldName, value) {
        project.tripleStore.addTriple(storyID, fieldName, value);
        return value;
    }
    // A Story class where data can be overriden
    var Story = (function () {
        function Story(model) {
            this.model = model;
        }
        Story.prototype.storyID = function () {
            return this.model.storyID;
        };
        Story.prototype.isIgnored = function () {
            return getStoryField(this.model.storyID, "ignore", "").trim() !== "";
        };
        Story.prototype.questionnaire = function () {
            return this.model.questionnaire;
        };
        Story.prototype.ignore = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("ignore", newValue);
        };
        Story.prototype.storyText = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("storyText", newValue);
        };
        Story.prototype.storyName = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("storyName", newValue);
        };
        Story.prototype.elicitingQuestion = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            return this.fieldValue("elicitingQuestion", newValue);
        };
        Story.prototype.fieldValue = function (fieldName, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue === undefined) {
                return getStoryField(this.model.storyID, fieldName, this.model[fieldName]) || "";
            }
            else {
                return setStoryField(this.model.storyID, fieldName, newValue);
            }
        };
        return Story;
    })();
    exports.Story = Story;
    function getStoriesForStoryCollection(storyCollectionIdentifier, includeIgnored) {
        if (includeIgnored === void 0) { includeIgnored = false; }
        var result = [];
        var surveyMessages = project.pointrelClient.filterMessages(function (message) {
            var match = (message._topicIdentifier === "surveyResults" &&
                message.messageType === "surveyResult" &&
                message.change.projectIdentifier === project.projectIdentifier &&
                message.change.storyCollectionIdentifier === storyCollectionIdentifier);
            // console.log("message", match, message);
            return match;
        });
        // console.log("getStoriesForStoryCollection surveyMessages", surveyMessages);
        surveyMessages.forEach(function (message) {
            // Now add stories in survey to results, with extra participant information
            try {
                var surveyResult = message.change.surveyResult;
                var stories = surveyResult.stories;
                for (var storyIndex in stories) {
                    // Make a copy of the story so as not to modify original in message
                    var story = JSON.parse(JSON.stringify(stories[storyIndex]));
                    // console.log("=== story", story);
                    // Add participant info for story
                    var participantData = surveyResult.participantData;
                    for (var key in participantData) {
                        if (key !== "__type") {
                            story[key] = participantData[key];
                        }
                    }
                    // Add questionnaire for display
                    story.questionnaire = surveyResult.questionnaire;
                    var wrappedStory = new Story(story);
                    if (includeIgnored || !wrappedStory.isIgnored()) {
                        result.push(wrappedStory);
                    }
                }
            }
            catch (e) {
                console.log("Problem processing survey result", message, e);
            }
        });
        return result;
    }
    exports.getStoriesForStoryCollection = getStoriesForStoryCollection;
    function getQuestionnaireForStoryCollection(storyCollectionName, alertIfProblem) {
        if (alertIfProblem === void 0) { alertIfProblem = false; }
        var storyCollection = project.findStoryCollection(storyCollectionName);
        if (!storyCollection) {
            // TODO: translate
            if (alertIfProblem)
                alert("The selected story collection could not be found.");
            return null;
        }
        var questionnaireName = project.tripleStore.queryLatestC(storyCollection, "storyCollection_questionnaireIdentifier");
        if (!questionnaireName) {
            // TODO: translate
            if (alertIfProblem)
                alert("The story collection has no selection for a questionnaire.");
            return null;
        }
        var questionnaire = project.tripleStore.queryLatestC(storyCollection, "questionnaire");
        if (!questionnaire) {
            // TODO: translate
            if (alertIfProblem)
                alert("The questionnaire selected in the story collection could not be found.");
            return null;
        }
        return questionnaire;
    }
    exports.getQuestionnaireForStoryCollection = getQuestionnaireForStoryCollection;
    function urlForSurvey(storyCollectionIdentifier) {
        var href = window.location.href;
        var baseURL = href.substring(0, href.lastIndexOf("/"));
        // TODO: Duplicated project prefix; should refactor to have it in one place
        var projectName = project.journalIdentifier.substring("NarraFirmaProject-".length);
        var shortName = project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_shortName");
        return baseURL + "/survey.html#project=" + projectName + "&survey=" + shortName;
    }
    exports.urlForSurvey = urlForSurvey;
    function toggleWebActivationOfSurvey(model, fieldSpecification, value) {
        // TODO: Fix this for mover to using triples for projectModel
        var grid = fieldSpecification.grid;
        var selectedItem = grid.getSelectedItem();
        console.log("toggleWebActivationOfSurvey selectedItem", selectedItem, model, fieldSpecification);
        var shortName = project.tripleStore.queryLatestC(selectedItem, "storyCollection_shortName");
        var activeOnWeb = project.tripleStore.queryLatestC(selectedItem, "storyCollection_activeOnWeb");
        activeOnWeb = !activeOnWeb;
        if (activeOnWeb) {
            // urlForSurvey(shortName)
            project.tripleStore.addTriple(selectedItem, "storyCollection_activeOnWeb", true);
        }
        else {
            project.tripleStore.addTriple(selectedItem, "storyCollection_activeOnWeb", false);
        }
        // TODO: Potential window of vulnerability here because not making both changes (to item and survey questionnaires) as a single transaction
        var questionnaires = {};
        for (var key in project.activeQuestionnaires) {
            questionnaires[key] = project.activeQuestionnaires[key];
        }
        var questionnaire = project.tripleStore.queryLatestC(selectedItem, "questionnaire");
        if (!questionnaire) {
            var questionnaireName = project.tripleStore.queryLatestC(selectedItem, "storyCollection_questionnaireIdentifier");
            console.log("Could not find questionnnaire for", questionnaireName);
            return;
        }
        if (activeOnWeb) {
            questionnaires[shortName] = questionnaire;
        }
        else {
            delete questionnaires[shortName];
        }
        // Now publish the new or removed questionnaire so surveys can pick up the change...
        updateActiveQuestionnaires(questionnaires, "sendMessage", activeOnWeb);
    }
    exports.toggleWebActivationOfSurvey = toggleWebActivationOfSurvey;
    function updateActiveQuestionnaires(questionnaires, sendMessage, activeOnWeb) {
        project.activeQuestionnaires = questionnaires;
        if (!sendMessage)
            return;
        // TODO: Should not have GUI actions in here like alert; either do as Toast or publish on topic that can be hooked up to alert or Toast
        project.pointrelClient.createAndSendChangeMessage("questionnaires", "questionnairesMessage", questionnaires, null, function (error, result) {
            if (error) {
                // TODO: Translate
                var errorMessage = "Problem activating web form";
                if (!activeOnWeb)
                    errorMessage = "Problem deactivating web form";
                alert(errorMessage);
                return;
            }
            // TODO: Translate
            var message = "The web form has been activated.";
            if (!activeOnWeb)
                message = "The web form has been deactivated.";
            alert(message);
        });
    }
    exports.updateActiveQuestionnaires = updateActiveQuestionnaires;
    function storyCollectionStop() {
        // TODO: translate
        // TODO: probably should not have GUI action in here; need to rethink?
        if (!isStoryCollectingEnabled()) {
            alert("Story collection via the web is already not currently enabled.");
            return;
        }
        if (!confirm("Deactivate all story collection via the web?"))
            return;
        var storyCollections = project.getListForField("project_storyCollections");
        for (var i = 0; i < storyCollections.length; i++) {
            var storyCollectionIdentifier = storyCollections[i];
            if (project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_activeOnWeb")) {
                project.tripleStore.addTriple(storyCollectionIdentifier, "storyCollection_activeOnWeb", false);
            }
        }
        updateActiveQuestionnaires({}, "sendMessage", false);
        console.log("Deactivated all web questionnaires");
    }
    exports.storyCollectionStop = storyCollectionStop;
    function isStoryCollectingEnabled() {
        for (var key in project.activeQuestionnaires) {
            return true;
        }
        return false;
    }
    exports.isStoryCollectingEnabled = isStoryCollectingEnabled;
    function collectQuestionsForQuestionnaire(questionnaire) {
        // console.log("collectQuestionsForQuestionnaire", questionnaire);
        if (!questionnaire)
            return [];
        var leadingStoryQuestions = questionnaireGeneration.getLeadingStoryQuestions(questionnaire.elicitingQuestions);
        // console.log("DEBUG questions used by story browser", questions);
        var questions = [].concat(leadingStoryQuestions, questionnaire.storyQuestions);
        questions.push({
            id: "participantData_header",
            displayName: "Participant Data",
            displayPrompt: "---- participant data below ----",
            displayType: "header",
            valueOptions: []
        });
        // TODO: add more participant and survey info, like timestamps and participant ID
        // Participant data has elsewhere been copied into story, so these questions can access it directly
        questions = questions.concat(questionnaire.participantQuestions);
        return questions;
    }
    exports.collectQuestionsForQuestionnaire = collectQuestionsForQuestionnaire;
    // Types of questions that have data associated with them for filters and graphs
    var filterableQuestionTypes = ["select", "slider", "boolean", "text", "checkbox", "checkboxes", "radiobuttons"];
    // function updateFilterPaneForCurrentQuestions(questions) {
    function optionsForAllQuestions(questions, excludeTextQuestionsFlag) {
        if (excludeTextQuestionsFlag === void 0) { excludeTextQuestionsFlag = null; }
        var questionOptions = [];
        questions.forEach(function (question) {
            if (filterableQuestionTypes.indexOf(question.displayType) !== -1) {
                if (!excludeTextQuestionsFlag || question.displayType !== "text") {
                    var defaultText = question.displayName;
                    if (!defaultText)
                        defaultText = question.displayPrompt;
                    questionOptions.push({ label: translate(question.id + "::shortName", defaultText), value: question.id });
                }
            }
        });
        // Sort options by their name
        questionOptions.sort(function (a, b) {
            if (a.label.toLowerCase() < b.label.toLowerCase())
                return -1;
            if (a.label.toLowerCase() > b.label.toLowerCase())
                return 1;
            return 0;
        });
        return questionOptions;
    }
    exports.optionsForAllQuestions = optionsForAllQuestions;
});

define('js/surveyStorage',["require", "exports"], function (require, exports) {
    "use strict";
    function makeSurveyResultMessage(pointrelClient, projectIdentifier, storyCollectionName, completedSurvey) {
        var surveyResultWrapper = {
            projectIdentifier: projectIdentifier,
            // TODO: Mismatch of stored string's intent and the field name
            storyCollectionIdentifier: storyCollectionName,
            surveyResult: completedSurvey
        };
        var message = pointrelClient.createChangeMessage("surveyResults", "surveyResult", surveyResultWrapper, null);
        return message;
    }
    exports.makeSurveyResultMessage = makeSurveyResultMessage;
    function storeSurveyResult(pointrelClient, projectIdentifier, storyCollectionName, completedSurvey, wizardPane) {
        var message = makeSurveyResultMessage(pointrelClient, projectIdentifier, storyCollectionName, completedSurvey);
        console.log("storeSurveyResult", message);
        pointrelClient.sendMessage(message, function (error, result) {
            if (error) {
                console.log("Problem saving survey result", error);
                if (wizardPane && wizardPane.failed) {
                    wizardPane.failed();
                }
                else {
                    // TODO: Translate
                    alert("Problem saving survey result; check the console for details.\nPlease try to submit the survey result later.");
                }
                return;
            }
            console.log("Survey result stored");
            if (wizardPane) {
                wizardPane.forward();
            }
            else {
                // TODO: Translate
                alert("Your contribution has been added to the story collection. Thank you.");
            }
        });
    }
    exports.storeSurveyResult = storeSurveyResult;
});

define('js/panelBuilder/dialogSupport',["require", "exports", "./translate", "mithril"], function (require, exports, translate, m) {
    "use strict";
    // Only supports one dialog at a time -- no nesting!
    // Use an standard alert or confirm for one more level of nesting if needed.
    // TODO: Using a global here to avoid parameterizing mounted components until the following Mithril issue is resolved or clarified:
    // https://github.com/lhorie/mithril.js/issues/638
    // If this is null, no dialog is drawn. If this is a valid configuration, dialog will be displayed.
    var globalDialogConfiguration = null;
    // Leaving one dialog mounted all the time to try to get around with re-creation of grids when dialog opens; maybe Mithril bug?
    function initialize() {
        m.mount(document.getElementById("dialogDiv"), MithrilDialog);
    }
    exports.initialize = initialize;
    // TODO: Translate: Change to taking a translate ID
    // TODO: Buttons don't show up if window too narrow for dialog
    function confirm(message, okCallback) {
        var confirmed = window.confirm(message);
        if (confirmed)
            okCallback();
    }
    exports.confirm = confirm;
    function addButtonThatLaunchesDialog(fieldSpecification, dialogConfiguration) {
        return m("button", {
            "class": "narrafirma-dialog-launching-button",
            onclick: function () {
                openDialog(dialogConfiguration);
            }
        }, translate(fieldSpecification.id, fieldSpecification.displayPrompt));
    }
    exports.addButtonThatLaunchesDialog = addButtonThatLaunchesDialog;
    function hideDialogMethod() {
        globalDialogConfiguration = null;
    }
    var MithrilDialog = (function () {
        function MithrilDialog() {
        }
        MithrilDialog.controller = function () {
            // console.log("Making MithrilDialog");
            return new MithrilDialog();
        };
        MithrilDialog.view = function (controller) {
            // console.log("MithrilDialog view called");
            var dialogContent = [];
            if (globalDialogConfiguration) {
                try {
                    dialogContent = controller.calculateView(globalDialogConfiguration);
                }
                catch (e) {
                    console.log("Problem creating dialog", e);
                    alert("Problem creating dialog");
                    hideDialogMethod();
                }
            }
            return m("div.dialogContentWrapper", dialogContent);
        };
        MithrilDialog.prototype.calculateView = function (args) {
            var dialogConfiguration = args;
            // console.log("MithrilDalog calculateView", dialogConfiguration);
            var internalView;
            try {
                internalView = dialogConfiguration.dialogConstructionFunction(dialogConfiguration, hideDialogMethod);
            }
            catch (e) {
                console.log("Problem creating view", args, e);
                internalView = m("div", "Problem creating view");
            }
            var parts = [
                m("b", translate(dialogConfiguration.dialogTitle)),
                m("div.modal-internal", internalView)
            ];
            if (!dialogConfiguration.dialogOKButtonHidden) {
                parts.push(m("button", { onclick: function () {
                        if (dialogConfiguration.dialogOKCallback) {
                            dialogConfiguration.dialogOKCallback(dialogConfiguration, hideDialogMethod);
                        }
                        else {
                            hideDialogMethod();
                        }
                    } }, translate(args.dialogOKButtonLabel || "OK")));
            }
            if (dialogConfiguration.dialogCancelButtonLabel) {
                parts.push(m("button", { onclick: function () {
                        hideDialogMethod();
                    } }, translate(args.dialogCancelButtonLabel)));
            }
            return m("div.overlay", m("div.modal-content", { "class": dialogConfiguration.dialogStyle }, parts));
        };
        return MithrilDialog;
    })();
    function openDialog(dialogConfiguration) {
        // console.log("openDialog", dialogConfiguration.dialogTitle); // JSON.stringify(dialogConfiguration));
        if (!dialogConfiguration.key)
            dialogConfiguration.key = "standardDialog";
        globalDialogConfiguration = dialogConfiguration;
    }
    exports.openDialog = openDialog;
    // Caller needs to call the hideDialogMethod returned as the second arg of dialogOKCallback to close the dialog
    function openTextEditorDialog(text, dialogTitle, dialogOKButtonLabel, dialogOKCallback) {
        // console.log("openTextEditorDialog called");
        if (!dialogTitle)
            dialogTitle = "Editor";
        if (!dialogOKButtonLabel)
            dialogOKButtonLabel = "OK";
        var model = { text: text };
        var dialogConfiguration = {
            dialogModel: model,
            dialogTitle: dialogTitle,
            dialogStyle: undefined,
            dialogConstructionFunction: build_textEditorDialogContent,
            dialogOKButtonLabel: dialogOKButtonLabel,
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { dialogOKCallback(model.text, hideDialogMethod); },
            dialogCancelButtonLabel: "Cancel"
        };
        openDialog(dialogConfiguration);
    }
    exports.openTextEditorDialog = openTextEditorDialog;
    function build_textEditorDialogContent(dialogConfiguration, hideDialogMethod) {
        // style: "min-height: 400px; min-width: 600px; max-height: 800px; max-width: 800px; overflow: auto"
        return m("div", [
            m("textarea", { key: "standardTextEditorTextarea", "class": "textEditorInDialog", onchange: function (event) { dialogConfiguration.dialogModel.text = event.target.value; }, value: dialogConfiguration.dialogModel.text })
        ]);
    }
    // Caller needs to call the hideDialogMethod returned as the second arg of dialogOKCallback to close the dialog
    function openProgressDialog(progressText, dialogTitle, cancelButtonLabel, dialogCancelCallback) {
        // console.log("openProgressDialog called");
        if (!dialogTitle)
            dialogTitle = "Progress";
        if (!cancelButtonLabel)
            cancelButtonLabel = "Cancel";
        var model = {
            progressText: progressText,
            hideDialogMethod: hideDialogMethod,
            redraw: m.redraw,
            cancelled: false,
            failed: false
        };
        var dialogConfiguration = {
            dialogModel: model,
            dialogTitle: dialogTitle,
            dialogStyle: undefined,
            dialogConstructionFunction: build_progressDialogContent,
            // Use OK button isntead of Cancel because it has a callback and represents the action button
            dialogOKButtonLabel: cancelButtonLabel,
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { dialogCancelCallback(dialogConfiguration, hideDialogMethod); }
        };
        openDialog(dialogConfiguration);
        return model;
    }
    exports.openProgressDialog = openProgressDialog;
    function build_progressDialogContent(dialogConfiguration, hideDialogMethod) {
        return m("div", dialogConfiguration.dialogModel.progressText);
    }
    function openFinishedDialog(finishedText, dialogTitle, okButtonLabel, cancelButtonLabel, dialogOKCallback) {
        // console.log("openProgressDialog called");
        if (!dialogTitle)
            dialogTitle = "Finished";
        if (!okButtonLabel)
            okButtonLabel = "OK";
        if (!cancelButtonLabel)
            cancelButtonLabel = "Cancel";
        var model = {
            finishedText: finishedText,
            hideDialogMethod: hideDialogMethod,
            redraw: m.redraw,
            cancelled: false,
            failed: false
        };
        var dialogConfiguration = {
            dialogModel: model,
            dialogTitle: dialogTitle,
            dialogStyle: undefined,
            dialogConstructionFunction: build_finishedDialogContent,
            // Use OK button instead of Cancel because it has a callback and represents the action button
            dialogOKButtonLabel: okButtonLabel,
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { dialogOKCallback(dialogConfiguration, hideDialogMethod); },
            dialogCancelButtonLabel: cancelButtonLabel
        };
        openDialog(dialogConfiguration);
        return model;
    }
    exports.openFinishedDialog = openFinishedDialog;
    function build_finishedDialogContent(dialogConfiguration, hideDialogMethod) {
        return m("div", dialogConfiguration.dialogModel.finishedText);
    }
    // columns are currently ignored
    // choices should be a list of objects with a name field, like: {name: "test", other: "???}
    function openListChoiceDialog(initialChoice, choices, columns, dialogTitle, dialogOKButtonLabel, isNewAllowed, dialogOKCallback) {
        if (!dialogTitle)
            dialogTitle = "Choices";
        if (!dialogOKButtonLabel)
            dialogOKButtonLabel = "Choose";
        var dialogConfiguration = {
            key: "standardListChooser",
            initialChoice: initialChoice,
            choices: choices,
            columns: columns,
            dialogTitle: dialogTitle,
            dialogOKButtonLabel: dialogOKButtonLabel,
            dialogOKCallback: dialogOKCallback,
            dialogConstructionFunction: build_listChooserDialogContent,
            dialogOKButtonHidden: true,
            isNewAllowed: isNewAllowed
        };
        openDialog(dialogConfiguration);
    }
    exports.openListChoiceDialog = openListChoiceDialog;
    function build_listChooserDialogContent(dialogConfiguration, hideDialogMethod) {
        function selectionMade(args, choice) {
            hideDialogMethod();
            args.dialogOKCallback(choice);
        }
        function makeNewListItem(args, choice) {
            // TODO: Translate
            var name = prompt("New project name?");
            if (!name)
                return;
            // console.log("make new project", name);
            hideDialogMethod();
            args.dialogOKCallback({ id: name, name: name, isNew: true });
        }
        // style: "min-height: 400px; min-width: 600px; max-height: 800px; max-width: 800px; overflow: auto"
        return m("div.overlay", m("div.modal-content", [
            m("b", dialogConfiguration.dialogTitle),
            m("br"),
            dialogConfiguration.dialogOKButtonLabel,
            m("br"),
            dialogConfiguration.choices.sort(function (a, b) { return a.name.localeCompare(b.name); }).map(function (choice) {
                return [
                    m("button", { onclick: selectionMade.bind(null, dialogConfiguration, choice) }, choice.name),
                    m("br")
                ];
            }),
            m("br"),
            dialogConfiguration.isNewAllowed ?
                m("button", { onclick: makeNewListItem.bind(null, dialogConfiguration) }, "[Make new project]")
                :
                    m("div")
        ]));
    }
});

/**
 * humane.js
 * Humanized Messages for Notifications
 * @author Marc Harter (@wavded)
 * @example
 *   humane.log('hello world');
 * @license MIT
 * See more usage examples at: http://wavded.github.com/humane-js/
 */

;!function (name, context, definition) {
   if (typeof module !== 'undefined') module.exports = definition(name, context)
   else if (typeof define === 'function' && typeof define.amd  === 'object') define('humane',definition)
   else context[name] = definition(name, context)
}('humane', this, function (name, context) {
   var win = window
   var doc = document

   var ENV = {
      on: function (el, type, cb) {
         'addEventListener' in win ? el.addEventListener(type,cb,false) : el.attachEvent('on'+type,cb)
      },
      off: function (el, type, cb) {
         'removeEventListener' in win ? el.removeEventListener(type,cb,false) : el.detachEvent('on'+type,cb)
      },
      bind: function (fn, ctx) {
         return function () { fn.apply(ctx,arguments) }
      },
      isArray: Array.isArray || function (obj) { return Object.prototype.toString.call(obj) === '[object Array]' },
      config: function (preferred, fallback) {
         return preferred != null ? preferred : fallback
      },
      transSupport: false,
      useFilter: /msie [678]/i.test(navigator.userAgent), // sniff, sniff
      _checkTransition: function () {
         var el = doc.createElement('div')
         var vendors = { webkit: 'webkit', Moz: '', O: 'o', ms: 'MS' }

         for (var vendor in vendors)
            if (vendor + 'Transition' in el.style) {
               this.vendorPrefix = vendors[vendor]
               this.transSupport = true
            }
      }
   }
   ENV._checkTransition()

   var Humane = function (o) {
      o || (o = {})
      this.queue = []
      this.baseCls = o.baseCls || 'humane'
      this.addnCls = o.addnCls || ''
      this.timeout = 'timeout' in o ? o.timeout : 2500
      this.waitForMove = o.waitForMove || false
      this.clickToClose = o.clickToClose || false
      this.timeoutAfterMove = o.timeoutAfterMove || false
      this.container = o.container

      try { this._setupEl() } // attempt to setup elements
      catch (e) {
        ENV.on(win,'load',ENV.bind(this._setupEl, this)) // dom wasn't ready, wait till ready
      }
   }

   Humane.prototype = {
      constructor: Humane,
      _setupEl: function () {
         var el = doc.createElement('div')
         el.style.display = 'none'
         if (!this.container){
           if(doc.body) this.container = doc.body;
           else throw 'document.body is null'
         }
         this.container.appendChild(el)
         this.el = el
         this.removeEvent = ENV.bind(function(){
            var timeoutAfterMove = ENV.config(this.currentMsg.timeoutAfterMove,this.timeoutAfterMove)
            if (!timeoutAfterMove){
               this.remove()
            } else {
               setTimeout(ENV.bind(this.remove,this),timeoutAfterMove)
            }
         },this)

         this.transEvent = ENV.bind(this._afterAnimation,this)
         this._run()
      },
      _afterTimeout: function () {
         if (!ENV.config(this.currentMsg.waitForMove,this.waitForMove)) this.remove()

         else if (!this.removeEventsSet) {
            ENV.on(doc.body,'mousemove',this.removeEvent)
            ENV.on(doc.body,'click',this.removeEvent)
            ENV.on(doc.body,'keypress',this.removeEvent)
            ENV.on(doc.body,'touchstart',this.removeEvent)
            this.removeEventsSet = true
         }
      },
      _run: function () {
         if (this._animating || !this.queue.length || !this.el) return

         this._animating = true
         if (this.currentTimer) {
            clearTimeout(this.currentTimer)
            this.currentTimer = null
         }

         var msg = this.queue.shift()
         var clickToClose = ENV.config(msg.clickToClose,this.clickToClose)

         if (clickToClose) {
            ENV.on(this.el,'click',this.removeEvent)
            ENV.on(this.el,'touchstart',this.removeEvent)
         }

         var timeout = ENV.config(msg.timeout,this.timeout)

         if (timeout > 0)
            this.currentTimer = setTimeout(ENV.bind(this._afterTimeout,this), timeout)

         if (ENV.isArray(msg.html)) msg.html = '<ul><li>'+msg.html.join('<li>')+'</ul>'

         this.el.innerHTML = msg.html
         this.currentMsg = msg
         this.el.className = this.baseCls
         if (ENV.transSupport) {
            this.el.style.display = 'block'
            setTimeout(ENV.bind(this._showMsg,this),50)
         } else {
            this._showMsg()
         }

      },
      _setOpacity: function (opacity) {
         if (ENV.useFilter){
            try{
               this.el.filters.item('DXImageTransform.Microsoft.Alpha').Opacity = opacity*100
            } catch(err){}
         } else {
            this.el.style.opacity = String(opacity)
         }
      },
      _showMsg: function () {
         var addnCls = ENV.config(this.currentMsg.addnCls,this.addnCls)
         if (ENV.transSupport) {
            this.el.className = this.baseCls+' '+addnCls+' '+this.baseCls+'-animate'
         }
         else {
            var opacity = 0
            this.el.className = this.baseCls+' '+addnCls+' '+this.baseCls+'-js-animate'
            this._setOpacity(0) // reset value so hover states work
            this.el.style.display = 'block'

            var self = this
            var interval = setInterval(function(){
               if (opacity < 1) {
                  opacity += 0.1
                  if (opacity > 1) opacity = 1
                  self._setOpacity(opacity)
               }
               else clearInterval(interval)
            }, 30)
         }
      },
      _hideMsg: function () {
         var addnCls = ENV.config(this.currentMsg.addnCls,this.addnCls)
         if (ENV.transSupport) {
            this.el.className = this.baseCls+' '+addnCls
            ENV.on(this.el,ENV.vendorPrefix ? ENV.vendorPrefix+'TransitionEnd' : 'transitionend',this.transEvent)
         }
         else {
            var opacity = 1
            var self = this
            var interval = setInterval(function(){
               if(opacity > 0) {
                  opacity -= 0.1
                  if (opacity < 0) opacity = 0
                  self._setOpacity(opacity);
               }
               else {
                  self.el.className = self.baseCls+' '+addnCls
                  clearInterval(interval)
                  self._afterAnimation()
               }
            }, 30)
         }
      },
      _afterAnimation: function () {
         if (ENV.transSupport) ENV.off(this.el,ENV.vendorPrefix ? ENV.vendorPrefix+'TransitionEnd' : 'transitionend',this.transEvent)

         if (this.currentMsg.cb) this.currentMsg.cb()
         this.el.style.display = 'none'

         this._animating = false
         this._run()
      },
      remove: function (e) {
         var cb = typeof e == 'function' ? e : null

         ENV.off(doc.body,'mousemove',this.removeEvent)
         ENV.off(doc.body,'click',this.removeEvent)
         ENV.off(doc.body,'keypress',this.removeEvent)
         ENV.off(doc.body,'touchstart',this.removeEvent)
         ENV.off(this.el,'click',this.removeEvent)
         ENV.off(this.el,'touchstart',this.removeEvent)
         this.removeEventsSet = false

         if (cb && this.currentMsg) this.currentMsg.cb = cb
         if (this._animating) this._hideMsg()
         else if (cb) cb()
      },
      log: function (html, o, cb, defaults) {
         var msg = {}
         if (defaults)
           for (var opt in defaults)
               msg[opt] = defaults[opt]

         if (typeof o == 'function') cb = o
         else if (o)
            for (var opt in o) msg[opt] = o[opt]

         msg.html = html
         if (cb) msg.cb = cb
         this.queue.push(msg)
         this._run()
         return this
      },
      spawn: function (defaults) {
         var self = this
         return function (html, o, cb) {
            self.log.call(self,html,o,cb,defaults)
            return self
         }
      },
      create: function (o) { return new Humane(o) }
   }
   return new Humane()
});

define('js/panelBuilder/toaster',["require", "exports", "humane"], function (require, exports, humane) {
    "use strict";
    // For a "toaster" that can give status or progress updates
    var toasterWidget = null;
    // This should only be called once in your application, at the beginning
    function createToasterWidget(container) {
        // No longer needed to do anything
    }
    exports.createToasterWidget = createToasterWidget;
    function toast(message, messageType, duration_ms) {
        if (messageType === void 0) { messageType = "message"; }
        if (duration_ms === void 0) { duration_ms = 2000; }
        // TODO: Translate message if needed
        humane.log(message);
    }
    exports.toast = toast;
});

/* Blob.js
 * A Blob implementation.
 * 2014-07-24
 *
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/dsamarin
 * License: X11/MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

define('Blob',[],function() {
 
(function (view) {
	"use strict";

	view.URL = view.URL || view.webkitURL;

	if (view.Blob && view.URL) {
		try {
			new Blob;
			return;
		} catch (e) {}
	}

	// Internally we use a BlobBuilder implementation to base Blob off of
	// in order to support older browsers that only have BlobBuilder
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
		var
			  get_class = function(object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			}
			, FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			}
			, FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			}
			, FBB_proto = FakeBlobBuilder.prototype
			, FB_proto = FakeBlob.prototype
			, FileReaderSync = view.FileReaderSync
			, FileException = function(type) {
				this.code = this[this.name = type];
			}
			, file_ex_codes = (
				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
			).split(" ")
			, file_ex_code = file_ex_codes.length
			, real_URL = view.URL || view.webkitURL || view
			, real_create_object_URL = real_URL.createObjectURL
			, real_revoke_object_URL = real_URL.revokeObjectURL
			, URL = real_URL
			, btoa = view.btoa
			, atob = view.atob

			, ArrayBuffer = view.ArrayBuffer
			, Uint8Array = view.Uint8Array

			, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
		;
		FakeBlob.fake = FB_proto.fake = true;
		while (file_ex_code--) {
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
		}
		// Polyfill URL
		if (!real_URL.createObjectURL) {
			URL = view.URL = function(uri) {
				var
					  uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
					, uri_origin
				;
				uri_info.href = uri;
				if (!("origin" in uri_info)) {
					if (uri_info.protocol.toLowerCase() === "data:") {
						uri_info.origin = null;
					} else {
						uri_origin = uri.match(origin);
						uri_info.origin = uri_origin && uri_origin[1];
					}
				}
				return uri_info;
			};
		}
		URL.createObjectURL = function(blob) {
			var
				  type = blob.type
				, data_URI_header
			;
			if (type === null) {
				type = "application/octet-stream";
			}
			if (blob instanceof FakeBlob) {
				data_URI_header = "data:" + type;
				if (blob.encoding === "base64") {
					return data_URI_header + ";base64," + blob.data;
				} else if (blob.encoding === "URI") {
					return data_URI_header + "," + decodeURIComponent(blob.data);
				} if (btoa) {
					return data_URI_header + ";base64," + btoa(blob.data);
				} else {
					return data_URI_header + "," + encodeURIComponent(blob.data);
				}
			} else if (real_create_object_URL) {
				return real_create_object_URL.call(real_URL, blob);
			}
		};
		URL.revokeObjectURL = function(object_URL) {
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
				real_revoke_object_URL.call(real_URL, object_URL);
			}
		};
		FBB_proto.append = function(data/*, endings*/) {
			var bb = this.data;
			// decode data to a binary string
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
				var
					  str = ""
					, buf = new Uint8Array(data)
					, i = 0
					, buf_len = buf.length
				;
				for (; i < buf_len; i++) {
					str += String.fromCharCode(buf[i]);
				}
				bb.push(str);
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
				if (FileReaderSync) {
					var fr = new FileReaderSync;
					bb.push(fr.readAsBinaryString(data));
				} else {
					// async FileReader won't work as BlobBuilder is sync
					throw new FileException("NOT_READABLE_ERR");
				}
			} else if (data instanceof FakeBlob) {
				if (data.encoding === "base64" && atob) {
					bb.push(atob(data.data));
				} else if (data.encoding === "URI") {
					bb.push(decodeURIComponent(data.data));
				} else if (data.encoding === "raw") {
					bb.push(data.data);
				}
			} else {
				if (typeof data !== "string") {
					data += ""; // convert unsupported types to strings
				}
				// decode UTF-16 to binary string
				bb.push(unescape(encodeURIComponent(data)));
			}
		};
		FBB_proto.getBlob = function(type) {
			if (!arguments.length) {
				type = null;
			}
			return new FakeBlob(this.data.join(""), type, "raw");
		};
		FBB_proto.toString = function() {
			return "[object BlobBuilder]";
		};
		FB_proto.slice = function(start, end, type) {
			var args = arguments.length;
			if (args < 3) {
				type = null;
			}
			return new FakeBlob(
				  this.data.slice(start, args > 1 ? end : this.data.length)
				, type
				, this.encoding
			);
		};
		FB_proto.toString = function() {
			return "[object Blob]";
		};
		FB_proto.close = function() {
			this.size = 0;
			delete this.data;
		};
		return FakeBlobBuilder;
	}(view));

	view.Blob = function(blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				if (Uint8Array && blobParts[i] instanceof Uint8Array) {
					builder.append(blobParts[i].buffer);
				}
				else {
					builder.append(blobParts[i]);
				}
			}
		}
		var blob = builder.getBlob(type);
		if (!blob.slice && blob.webkitSlice) {
			blob.slice = blob.webkitSlice;
		}
		return blob;
	};

	var getPrototypeOf = Object.getPrototypeOf || function(object) {
		return object.__proto__;
	};
	view.Blob.prototype = getPrototypeOf(new view.Blob());
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

});

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2015-05-07.2
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = new MouseEvent("click");
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, auto_bom = function(blob) {
			// prepend BOM for UTF-8 XML and text/* types (including HTML)
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
				return new Blob(["\ufeff", blob], {type: blob.type});
			}
			return blob;
		}
		, FileSaver = function(blob, name) {
			blob = auto_bom(blob);
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				setTimeout(function() {
					click(save_link);
					dispatch_all();
					revoke(object_url);
					filesaver.readyState = filesaver.DONE;
				});
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	// IE 10+ (native saveAs)
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
		return function(blob, name) {
			return navigator.msSaveOrOpenBlob(auto_bom(blob), name);
		};
	}

	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  // TODO: Would need to load Blob polyfill somehow...
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define('FileSaver',["Blob"], function(discardBlobPolyfillResult) {
    return saveAs;
  });
}
;
define('js/csvImportExport',["require", "exports", "d3", "./pointrel20150417/generateRandomUuid", "./questionnaireGeneration", "./surveyCollection", "./surveyStorage", "./panelBuilder/dialogSupport", "./Globals", "mithril", "./panelBuilder/toaster", "FileSaver"], function (require, exports, d3, generateRandomUuid, questionnaireGeneration, surveyCollection, surveyStorage, dialogSupport, Globals, m, toaster, saveAs) {
    "use strict";
    var project;
    function initialize(theProject) {
        project = theProject;
    }
    exports.initialize = initialize;
    function processCSVContents(contents, callbackForItem) {
        // console.log("processCSVContents contents", contents);
        var rows = d3.csv.parseRows(contents);
        // console.log("rows", rows);
        var items = [];
        var header;
        for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            var row = rows[rowIndex];
            // Throw away comment lines and lines with blanks at first two positions
            if (!row.length || row.length < 2 || (!row[0].trim() && !row[1].trim()) || row[0].trim().charAt(0) === ";") {
            }
            else {
                if (!header) {
                    header = [];
                    var headerEnded = false;
                    for (var headerIndex = 0; headerIndex < row.length; headerIndex++) {
                        var label = row[headerIndex];
                        if (label) {
                            // Should be an error if header fields are missing but more show up later
                            if (headerEnded) {
                                console.log("ERROR: header has empty field before end");
                                alert("ERROR: header has empty field before end");
                            }
                            header.push(label);
                        }
                        else {
                            headerEnded = true;
                        }
                    }
                }
                else {
                    var newItem = callbackForItem(header, row);
                    if (newItem)
                        items.push(newItem);
                }
            }
        }
        // console.log("header", header);
        // console.log("items", items);
        return { header: header, items: items };
    }
    function padLeadingZeros(num, size) {
        var result = num + "";
        while (result.length < size)
            result = "0" + result;
        return result;
    }
    function processCSVContentsForStories(contents) {
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName) {
            alert("No story collection has been selected");
        }
        var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName, true);
        if (!questionnaire)
            return;
        var progressModel = dialogSupport.openProgressDialog("Processing CSV file...", "Progress writing imported stories", "Cancel", dialogCancelled);
        var headerAndItems = processCSVContents(contents, function (header, row) {
            var newItem = {};
            for (var fieldIndex = 0; fieldIndex < header.length; fieldIndex++) {
                var fieldName = header[fieldIndex];
                // Note the value is trimmed
                var value = row[fieldIndex].trim();
                if (newItem[fieldName] === undefined) {
                    newItem[fieldName] = value;
                }
                else {
                    // Handle case where this is a multiple choice question, which is indicated by multiple columns
                    var data = newItem[fieldName];
                    if (data && typeof data === 'object') {
                        if (value !== "")
                            data[value] = true;
                    }
                    else {
                        var newData = {};
                        if (data !== "")
                            newData[data] = true;
                        if (value !== "")
                            newData[value] = true;
                        newItem[fieldName] = newData;
                    }
                }
            }
            return newItem;
        });
        // console.log("processCSVContentsForStories headerAndItems", headerAndItems);
        var items = headerAndItems.items;
        var surveyResults = [];
        var untitledCount = 0;
        // TODO: this is a kludgy way to get a string and seems brittle
        var importedByUserIdentifier = project.userIdentifier.userIdentifier;
        for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
            var item = items[itemIndex];
            // console.log("item", item);
            // TODO: Copied code from surveyBuilder module! Need a common function with surveyBuilder to make this!!!
            var newSurveyResult = {
                __type: "org.workingwithstories.QuestionnaireResponse",
                // TODO: Think about whether to include entire questionnaire or something else perhaps
                questionnaire: questionnaire,
                responseID: generateRandomUuid("QuestionnaireResponse"),
                stories: [],
                participantData: {
                    __type: "org.workingwithstories.ParticipantData",
                    participantID: generateRandomUuid("Participant")
                },
                // TODO: Should have timestamp in CSV file!!!
                timestampStart: "" + new Date().toISOString(),
                timestampEnd: "" + new Date().toISOString(),
                timeDuration_ms: 0,
                // TODO: this is a kludgy way to get a string and seems brittle
                importedBy: importedByUserIdentifier
            };
            var elicitingQuestion = item["Eliciting question"] || questionnaire.elicitingQuestions[0].id;
            var story = {
                __type: "org.workingwithstories.Story",
                // TODO: Can this "id" field be safely removed? id: generateRandomUuid("TODO:???"),
                storyID: generateRandomUuid("Story"),
                participantID: newSurveyResult.participantData.participantID,
                elicitingQuestion: elicitingQuestion,
                storyText: item["Story text"],
                storyName: item["Story title"] || ("Untitled #" + padLeadingZeros(++untitledCount, 4))
            };
            var i;
            var question;
            for (i = 0; i < questionnaire.storyQuestions.length; i++) {
                question = questionnaire.storyQuestions[i];
                story[question.id] = item[question.id.substring("S_".length)];
            }
            newSurveyResult.stories.push(story);
            for (i = 0; i < questionnaire.participantQuestions.length; i++) {
                question = questionnaire.participantQuestions[i];
                newSurveyResult.participantData[question.id] = item[question.id.substring("P_".length)];
            }
            // Add any annotations
            project.collectAllAnnotationQuestions().forEach(function (annotationQuestion) {
                var id = annotationQuestion.annotationQuestion_shortName;
                var value = item[id];
                if (value !== null && value !== undefined) {
                    newSurveyResult.participantData["A_" + id] = value;
                }
            });
            // console.log("newSurveyResult", newSurveyResult);
            surveyResults.push(newSurveyResult);
        }
        if (!surveyResults.length) {
            alert("No stories to write");
            progressModel.hideDialogMethod();
            progressModel.redraw();
            return;
        }
        /*
        var newStoryCollection = {
            id: generateRandomUuid("StoryCollection"),
            storyCollection_shortName: storyCollectionIdentifier,
            storyCollection_questionnaireIdentifier: questionnaire.title,
            storyCollection_activeOnWeb: false,
            storyCollection_notes: "imported by: " + importedByUserIdentifier + " at: " + new Date().toISOString(),
            questionnaire: questionnaire
        };
        
        var storyCollections = project.getFieldValue("project_storyCollections");
        if (!storyCollections) {
            storyCollections = project.tripleStore.newIdForSet("StoryCollectionSet");
            project.setFieldValue("project_storyCollections", storyCollections);
        }
    
        project.tripleStore.makeNewSetItem(storyCollections, "StoryCollection", newStoryCollection);
         
        */
        var totalStoryCount = surveyResults.length;
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        var wizardPane = {
            forward: function () {
                console.log("survey sending success");
                if (progressModel.failed)
                    return;
                sendNextSurveyResult();
            },
            failed: function () {
                console.log("survey sending failed");
                if (progressModel.failed)
                    return;
                progressModel.failed = true;
                // TODO: Translate
                alert("Problem saving survey result; check the console for details.");
                progressModel.hideDialogMethod();
                progressModel.redraw();
            }
        };
        var storyIndexToSend = 0;
        function sendNextSurveyResult() {
            if (progressModel.cancelled) {
                alert("Cancelled after sending " + storyIndexToSend + " stories");
            }
            else if (storyIndexToSend >= surveyResults.length) {
                alert("Finished sending stories to server.");
                progressModel.hideDialogMethod();
                progressModel.redraw();
            }
            else {
                var surveyResult = surveyResults[storyIndexToSend++];
                // TODO: Translate
                progressModel.progressText = "Sending " + storyIndexToSend + " of " + totalStoryCount + " stories";
                progressModel.redraw();
                surveyStorage.storeSurveyResult(project.pointrelClient, project.projectIdentifier, storyCollectionName, surveyResult, wizardPane);
            }
        }
        // Start sending survey results
        sendNextSurveyResult();
    }
    function processCSVContentsForQuestionnaire(contents) {
        var headerAndItems = processCSVContents(contents, function (header, row) {
            // console.log("callback", header, row);
            var newItem = {};
            var lastFieldIndex;
            for (var fieldIndex = 0; fieldIndex < row.length; fieldIndex++) {
                var fieldName = header[fieldIndex];
                if (fieldName) {
                    lastFieldIndex = fieldIndex;
                }
                else {
                    fieldName = header[lastFieldIndex];
                }
                // TODO: Should the value really be trimmed?
                var value = row[fieldIndex].trim();
                // console.log("fieldName, value", fieldName, value);
                if (fieldIndex < header.length - 1) {
                    newItem[fieldName] = value;
                }
                else {
                    // Handle multiple values for last header items
                    var list = newItem[fieldName];
                    // console.log("list", list, fieldIndex, fieldName);
                    if (!list) {
                        list = [];
                        newItem[fieldName] = list;
                    }
                    if (value)
                        list.push(value);
                }
            }
            return newItem;
        });
        // console.log("processCSVContentsForQuestionnaire headerAndItems", headerAndItems);
        var shortName = prompt("Please enter a short name for a new story form.");
        if (!shortName)
            return;
        if (questionnaireGeneration.buildQuestionnaire(shortName)) {
            alert('A story form already exists with that name: "' + shortName + '"');
            return;
        }
        var storyFormListIdentifier = project.getFieldValue("project_storyForms");
        if (!storyFormListIdentifier) {
            storyFormListIdentifier = project.tripleStore.newIdForSet("StoryFormSet");
            project.setFieldValue("project_storyForms", storyFormListIdentifier);
        }
        // console.log("storyFormListIdentifier");
        // TODO: Generalize random uuid function to take class name
        // TODO: Maybe rename quesitonForm_ to storyForm_ ?
        var template = {
            id: generateRandomUuid("StoryForm"),
            questionForm_shortName: shortName,
            questionForm_elicitingQuestions: project.tripleStore.newIdForSet("ElicitingQuestionChoiceSet"),
            questionForm_storyQuestions: project.tripleStore.newIdForSet("StoryQuestionChoiceSet"),
            questionForm_participantQuestions: project.tripleStore.newIdForSet("ParticipantQuestionChoiceSet")
        };
        project.tripleStore.makeNewSetItem(storyFormListIdentifier, "StoryForm", template);
        // For all items:
        //   Check if one with that name already exists; warn if options or type is different
        //   If does not exist, create it in the related set
        //   Add a reference to the question in the story form
        var questionTypeCounts = {};
        var items = headerAndItems.items;
        for (var itemIndex = 0; itemIndex < items.length; itemIndex++) {
            var item = items[itemIndex];
            var about = item.About;
            var reference;
            var question;
            if (about === "story") {
                question = questionForItem(item, "storyQuestion");
                reference = ensureQuestionExists(question, "storyQuestion");
                addReferenceToList(template.questionForm_storyQuestions, reference, "storyQuestion", "StoryQuestionChoice");
            }
            else if (about === "participant") {
                question = questionForItem(item, "participantQuestion");
                reference = ensureQuestionExists(question, "participantQuestion");
                addReferenceToList(template.questionForm_participantQuestions, reference, "participantQuestion", "ParticipantQuestionChoice");
            }
            else if (about === "annotation") {
                question = questionForItem(item, "annotationQuestion");
                reference = ensureQuestionExists(question, "annotationQuestion");
            }
            else if (about === "eliciting") {
                var answers = item["Answers"];
                answers.forEach(function (elicitingQuestionDefinition) {
                    if (!elicitingQuestionDefinition)
                        elicitingQuestionDefinition = "ERROR:MissingElicitingText";
                    var sections = elicitingQuestionDefinition.split("|");
                    // If only one section, use it as both id and text
                    if (sections.length < 2) {
                        sections.push(sections[0]);
                    }
                    var elicitingQuestion = {
                        elicitingQuestion_text: sections[1].trim(),
                        elicitingQuestion_shortName: sections[0].trim(),
                        elicitingQuestion_type: {}
                    };
                    reference = ensureQuestionExists(elicitingQuestion, "elicitingQuestion");
                    addReferenceToList(template.questionForm_elicitingQuestions, reference, "elicitingQuestion", "ElicitingQuestionChoice");
                });
            }
            else if (about === "ignore") {
            }
            else {
                console.log("Error: unexpected About type of", about);
            }
        }
        m.redraw();
        toaster.toast("Finished reading story form: " + shortName);
        toaster.toast("Updating server in progress in background");
        function addReferenceToList(listIdentifier, reference, fieldName, className) {
            var order = questionTypeCounts[fieldName];
            if (!order) {
                order = 0;
            }
            order = order + 1;
            questionTypeCounts[fieldName] = order;
            var choice = {
                order: order
            };
            choice[fieldName] = reference;
            project.tripleStore.makeNewSetItem(listIdentifier, className, choice);
        }
    }
    function ensureQuestionExists(question, questionCategory) {
        var idAccessor = questionCategory + "_shortName";
        var existingQuestionsInCategory = project.questionsForCategory(questionCategory);
        var matchingQuestion = null;
        existingQuestionsInCategory.forEach(function (existingQuestion) {
            if (existingQuestion[idAccessor] === question[idAccessor])
                matchingQuestion = existingQuestion;
        });
        if (!matchingQuestion) {
            // console.log("adding question that does not exist yet", question, questionCategory); 
            project.addQuestionForCategory(question, questionCategory);
        }
        else {
            // TODO: What if questions with the same shortName but different options already exist?
            // TODO: Should check type as well
            if (matchingQuestion[questionCategory + "_options"] !== question[questionCategory + "_options"]) {
                console.log("IMPORT ISSUE: options don't match for questions", question, matchingQuestion);
                alert("Options do not match for existing question: " + question[idAccessor]);
            }
        }
        return question[idAccessor];
    }
    function questionForItem(item, questionCategory) {
        var valueType = "string";
        var questionType = "text";
        var valueOptions;
        var answers = item["Answers"];
        var itemType = item["Type"].trim();
        if (itemType === "Single choice") {
            questionType = "select";
            valueOptions = answers;
        }
        else if (itemType === "Scale") {
            valueType = "number";
            questionType = "slider";
            valueOptions = [answers[0], answers[1]];
        }
        else if (itemType === "Multiple choice") {
            questionType = "checkboxes";
            valueOptions = item["Answers"];
        }
        else if (itemType === "Radiobuttons") {
            questionType = "radiobuttons";
            valueOptions = item["Answers"];
        }
        else if (itemType === "Boolean") {
            questionType = "boolean";
        }
        else if (itemType === "Checkbox") {
            questionType = "checkbox";
        }
        else if (itemType === "Text") {
            questionType = "text";
        }
        else if (itemType === "Textarea") {
            questionType = "textarea";
        }
        else {
            console.log("IMPORT ERROR: unsupported question type: ", itemType);
        }
        var question = {};
        question[questionCategory + "_type"] = questionType;
        question[questionCategory + "_shortName"] = item["Short name"];
        question[questionCategory + "_text"] = item["Long name"];
        if (valueOptions) {
            question[questionCategory + "_options"] = valueOptions.join("\n");
        }
        return question;
    }
    function chooseCSVFileToImport(callback) {
        // console.log("chooseFileToImport");
        var cvsFileUploader = document.getElementById("csvFileLoader");
        // console.log("cvsFileUploader", cvsFileUploader);
        cvsFileUploader.onchange = function () {
            var file = cvsFileUploader.files[0];
            if (!file) {
                return;
            }
            var reader = new FileReader();
            reader.onload = function (e) {
                var contents = e.target.result;
                callback(contents);
            };
            reader.readAsText(file);
        };
        cvsFileUploader.click();
    }
    function importCSVStories() {
        if (!Globals.clientState().storyCollectionName()) {
            // TODO: Translate
            return alert("You need to select a story collection before you can import stories.");
        }
        chooseCSVFileToImport(processCSVContentsForStories);
    }
    exports.importCSVStories = importCSVStories;
    function importCSVQuestionnaire() {
        chooseCSVFileToImport(processCSVContentsForQuestionnaire);
    }
    exports.importCSVQuestionnaire = importCSVQuestionnaire;
    function addCSVOutputLine(output, line) {
        // console.log("line", line);
        var start = true;
        line.forEach(function (item) {
            // console.log("item", item);
            if (start) {
                start = false;
            }
            else {
                output += ",";
            }
            if (item && item.indexOf(",") !== -1) {
                item = item.replace(/"/g, '""');
                item = '"' + item + '"';
            }
            output += item;
        });
        output += "\n";
        return output;
    }
    var exportQuestionTypeMap = {
        "select": "Single choice",
        "slider": "Scale",
        "checkboxes": "Multiple choice",
        "radiobuttons": "Radiobuttons",
        "boolean": "Boolean",
        "checkbox": "Checkbox",
        "text": "Text",
        "textarea": "Textarea"
    };
    function exportQuestionnaire() {
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName) {
            alert("Please select a story collection first");
            return;
        }
        // console.log("exportStoryCollection", storyCollectionName);
        var currentQuestionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
        if (!currentQuestionnaire) {
            alert("The story collection has not been initialized with a story form: " + storyCollectionName);
            return;
        }
        // console.log("currentQuestionnaire", currentQuestionnaire);
        // Order Long name   Short name  Type    About   Answers
        var output = "";
        var lineIndex = 1;
        function addOutputLine(line) {
            output = addCSVOutputLine(output, line);
        }
        var header = ["Order", "Long name", "Short name", "Type", "About", "Answers"];
        addOutputLine(header);
        var elicitingLine = ["1", "Eliciting question", "Eliciting question", "Eliciting question", "eliciting"];
        currentQuestionnaire.elicitingQuestions.forEach(function (elicitingQuestionSpecification) {
            elicitingLine.push(elicitingQuestionSpecification.id + "|" + elicitingQuestionSpecification.text);
        });
        addOutputLine(elicitingLine);
        function outputQuestions(questions, about) {
            for (var i = 0; i < questions.length; i++) {
                var outputLine = [];
                var question = questions[i];
                outputLine.push("" + (++lineIndex));
                outputLine.push(question.displayPrompt || "");
                outputLine.push(question.displayName || "");
                var questionType = exportQuestionTypeMap[question.displayType];
                if (!questionType) {
                    console.log("EXPORT ERROR: unsupported question type: ", question.displayType);
                    questionType = "UNSUPPORTED:" + question.displayType;
                }
                outputLine.push(questionType);
                outputLine.push(about);
                if (question.displayType === "slider") {
                    if (question.displayConfiguration) {
                        if (question.displayConfiguration.length === 1) {
                            outputLine.push(question.displayConfiguration);
                        }
                        else if (question.displayConfiguration.length > 1) {
                            question.displayConfiguration.forEach(function (option) {
                                outputLine.push(option);
                            });
                        }
                    }
                }
                else {
                    if (question.valueOptions) {
                        question.valueOptions.forEach(function (option) {
                            outputLine.push(option);
                        });
                    }
                }
                addOutputLine(outputLine);
            }
        }
        outputQuestions(currentQuestionnaire.storyQuestions, "story");
        outputQuestions(currentQuestionnaire.participantQuestions, "participant");
        var annotationQuestions = project.collectAllAnnotationQuestions();
        var adjustedAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(annotationQuestions, "A_");
        outputQuestions(adjustedAnnotationQuestions, "annotation");
        // Export questionnaire
        var questionnaireBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
        // TODO: This seems to clear the console in FireFox 40; why?
        saveAs(questionnaireBlob, "export_story_form_" + storyCollectionName + ".csv");
    }
    exports.exportQuestionnaire = exportQuestionnaire;
    function exportStoryCollection() {
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName) {
            alert("Please select a story collection first");
            return;
        }
        // console.log("exportStoryCollection", storyCollectionName);
        var currentQuestionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
        if (!currentQuestionnaire) {
            alert("The story collection has not been initialized with a story form: " + storyCollectionName);
            return;
        }
        var allStories = surveyCollection.getStoriesForStoryCollection(storyCollectionName, true);
        // console.log("allStories", allStories);
        var header1 = [];
        var header2 = [];
        function header(contents, secondHeader) {
            if (secondHeader === void 0) { secondHeader = ""; }
            header1.push(contents);
            header2.push(secondHeader);
        }
        // Put initial header
        header("Story title");
        header("Story text");
        header("Eliciting question");
        function headersForQuestions(questions) {
            for (var i = 0; i < questions.length; i++) {
                var storyQuestion = questions[i];
                // TODO: Maybe should export ID instead? Or more header lines with ID and prompt?
                if (storyQuestion.valueOptions && storyQuestion.displayType === "checkboxes") {
                    storyQuestion.valueOptions.forEach(function (option) {
                        header(storyQuestion.displayName, option);
                    });
                }
                else {
                    header(storyQuestion.displayName);
                }
            }
        }
        headersForQuestions(currentQuestionnaire.storyQuestions);
        headersForQuestions(currentQuestionnaire.participantQuestions);
        var annotationQuestions = project.collectAllAnnotationQuestions();
        var adjustedAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(annotationQuestions, "A_");
        headersForQuestions(adjustedAnnotationQuestions);
        // console.log("header1", header1);
        // console.log("header2", header2);
        var output = "";
        function addOutputLine(line) {
            output = addCSVOutputLine(output, line);
        }
        addOutputLine(header1);
        addOutputLine(header2);
        function dataForQuestions(questions, story, outputLine) {
            for (var i = 0; i < questions.length; i++) {
                var question = questions[i];
                var value = story.fieldValue(question.id);
                if (value === undefined || value === null)
                    value = "";
                if (question.valueOptions && question.displayType === "checkboxes") {
                    question.valueOptions.forEach(function (option) {
                        outputLine.push(value[option] ? option : "");
                    });
                }
                else {
                    outputLine.push(value);
                }
            }
        }
        allStories.forEach(function (story) {
            var outputLine = [];
            outputLine.push(story.storyName());
            outputLine.push(story.storyText());
            outputLine.push(story.elicitingQuestion());
            dataForQuestions(currentQuestionnaire.storyQuestions, story, outputLine);
            dataForQuestions(currentQuestionnaire.participantQuestions, story, outputLine);
            dataForQuestions(adjustedAnnotationQuestions, story, outputLine);
            addOutputLine(outputLine);
        });
        // Testing
        //var blob = new Blob(["Hello, world!"], {type: "text/plain;charset=utf-8"});
        //saveAs(blob, "hello world.csv");
        // Export story collection
        var storyCollectionBlob = new Blob([output], { type: "text/csv;charset=utf-8" });
        // TODO: This seems to clear the console in FireFox 40; why?
        saveAs(storyCollectionBlob, "export_story_collection_" + storyCollectionName + ".csv");
    }
    exports.exportStoryCollection = exportStoryCollection;
});

define('js/versions',["require", "exports"], function (require, exports) {
    "use strict";
    // Return current versions used by application  
    var versions = {
        narrafirmaApplication: "0.9.8",
        questionnaireContentType: "org.workingwithstories.NarraFirmaQuestionnaire",
        questionnaireContentVersion: "0.1.0",
        surveyResultContentType: "org.workingwithstories.NarraFirmaSurveyResult",
        surveyResultContentVersion: "0.1.0"
    };
    return versions;
});

define('js/navigationPane',["require", "exports", "mithril", "./PanelSetup", "./Globals", "./versions"], function (require, exports, m, PanelSetup, Globals, versions) {
    "use strict";
    var panelSpecificationCollection;
    var currentSectionID;
    var currentPageSpecification;
    var userIdentifier;
    var navigationController = null;
    /* jshint scripturl:true */
    var launchHelpCommand = "javascript:narrafirma_helpClicked()";
    var logoutCommand = "javascript:narrafirma_logoutClicked()";
    var loginCommand = "javascript:narrafirma_loginClicked()";
    var Navigation = {
        panelBuilder: null,
        controller: function (args) {
            // console.log("********************** Making new navigation pane");
            this.pageID = null;
            this.pageSpecification = null;
            this.panelBuilder = Navigation.panelBuilder;
        },
        view: function (controller, args) {
            // console.log("&&&&&&&&&&&&&&&&&&&&&&&&&& View called for navigation pane");
            return m("div[id=narrafirma-navigation]", [
                m("span[id=narrafirma-name]", {
                    "class": Globals.clientState().serverStatus(),
                    "title": Globals.clientState().serverStatusText()
                }, "NarraFirma™"),
                m("span[id=narrafirma-breadcrumbs]", buildBreadcrumbs(controller)),
                Globals.project().readOnly ? m("span[id=narrafirma-read-only]", { title: "Project is read-only for this user. Local changes can be made, but they will not be saved on the server and will be lost if the page is reloaded." }, "[READONLY!]") : [],
                // These next four links float right and so are added in reverse order
                userIdentifier === "anonymous" ?
                    m("a[id=narrafirma-login-link]", { href: loginCommand, title: "Login instead of being anonymous" }, 'Login') :
                    m("a[id=narrafirma-logout-link]", { href: logoutCommand, title: "Logout the current user" }, 'Logout (' + userIdentifier + ')'),
                m("span[id=narrafirma-version]", "v" + versions.narrafirmaApplication),
                m("a[id=narrafirma-help-link]", { href: launchHelpCommand, title: "Open online help for this page" }, "Help"),
                m("a[id=narrafirma-next-page]", { href: nextPageLink(), title: nextPageTitle(), "class": nextPageClass() }, "=>"),
                m("a[id=narrafirma-previous-page]", { href: previousPageLink(), title: previousPageTitle(), "class": previousPageClass() }, "<=")
            ]);
        }
    };
    function previousPageTitle() {
        if (!currentPageSpecification || !currentPageSpecification.previousPageID)
            return "No previous page";
        var previousPage = panelSpecificationCollection.getPageSpecificationForPageID(currentPageSpecification.previousPageID);
        if (previousPage)
            return "Previous page (" + previousPage.displayName + ")";
        return "Previous page";
    }
    function previousPageClass() {
        if (!currentPageSpecification || !currentPageSpecification.previousPageID)
            return "narrafirma-link-disabled";
        return "narrafirma-link-enabled";
    }
    function previousPageLink() {
        if (!currentPageSpecification)
            return "#";
        return linkForPage(currentPageSpecification.previousPageID);
    }
    function nextPageTitle() {
        if (!currentPageSpecification || !currentPageSpecification.nextPageID)
            return "No next page";
        var nextPage = panelSpecificationCollection.getPageSpecificationForPageID(currentPageSpecification.nextPageID);
        if (nextPage)
            return "Next page (" + nextPage.displayName + ")";
        return "Next page";
    }
    function nextPageClass() {
        if (!currentPageSpecification || !currentPageSpecification.nextPageID)
            return "narrafirma-link-disabled";
        return "narrafirma-link-enabled";
    }
    function nextPageLink() {
        if (!currentPageSpecification)
            return "#";
        return linkForPage(currentPageSpecification.nextPageID);
    }
    function initializeNavigationPane(thePanelSpecificationCollection, theUserIdentifier, panelBuilder) {
        panelSpecificationCollection = thePanelSpecificationCollection;
        userIdentifier = theUserIdentifier;
        Navigation.panelBuilder = panelBuilder;
        navigationController = m.mount(document.getElementById("navigationDiv"), Navigation);
    }
    exports.initializeNavigationPane = initializeNavigationPane;
    function setCurrentPageSpecification(pageID, pageSpecification) {
        currentPageSpecification = pageSpecification;
        navigationController.pageID = pageID;
        navigationController.pageSpecification = pageSpecification;
    }
    exports.setCurrentPageSpecification = setCurrentPageSpecification;
    function buildBreadcrumbs(controller) {
        var pageID = controller.pageID;
        var pageSpecification = controller.pageSpecification;
        currentPageSpecification = pageSpecification;
        if (!pageSpecification)
            return ["Starting up..."];
        var breadcrumbs = [];
        if (pageID !== PanelSetup.startPage()) {
            breadcrumbs.push(htmlForBreadcrumb(PanelSetup.startPage(), "Home"));
            breadcrumbs.push(" > ");
            // console.log("pageSpecification", pageSpecification);
            // TODO: Should lookup name of section
            if (!pageSpecification.isHeader) {
                var sectionPageSpecification = panelSpecificationCollection.getPageSpecificationForPageID("page_" + pageSpecification.section);
                if (sectionPageSpecification) {
                    breadcrumbs.push(htmlForBreadcrumb(sectionPageSpecification.id, sectionPageSpecification.displayName));
                    breadcrumbs.push(" > ");
                }
                else {
                    console.log("ERROR: could not find sectionPageSpecification for: ", pageSpecification.section, pageSpecification);
                }
            }
        }
        breadcrumbs.push(m("span", { id: "narrafirma-breadcrumb-current" }, pageSpecification.displayName));
        return breadcrumbs;
    }
    function linkForPage(pageIdentifier) {
        if (!pageIdentifier)
            return "javascript:void(0)";
        return "javascript:narrafirma_openPage(\'" + pageIdentifier + "\')";
    }
    function htmlForBreadcrumb(pageIdentifier, pageName) {
        return m("a", { href: linkForPage(pageIdentifier) }, pageName);
    }
    function getCurrentPageSpecification() {
        return currentPageSpecification;
    }
    exports.getCurrentPageSpecification = getCurrentPageSpecification;
});

define('js/pageDisplayer',["require", "exports", "./navigationPane", "mithril", "./PanelSetup"], function (require, exports, navigationPane, m, PanelSetup) {
    "use strict";
    // For tracking what page the application is on
    var currentPageID = null;
    var currentPageSpecification = null;
    var currentPage;
    var panelBuilder;
    var project;
    var clientState;
    var PageDisplayer = {
        controller: function (args) {
            // console.log("PageDisplayer created");
        },
        view: function (controller, args) {
            var contentsDiv;
            // console.log("========== view called in PageDisplayer ==========", currentPageID);
            // Setting the hash may trigger another call to the showPage function eventually, but as the new page will already be set, it should not loop further
            clientState.updateHashIfNeededForChangedClientState();
            if (!currentPageID) {
                contentsDiv = m("div", "Starting up...");
            }
            else {
                // Create the display widgets for this page
                try {
                    contentsDiv = m("div", { "class": "narrafirma-" + currentPageID }, [
                        m("div.narrafirma-page-name", currentPageSpecification.displayName),
                        panelBuilder.buildPanel(currentPageID, project.projectIdentifier)
                    ]);
                }
                catch (e) {
                    console.log("ERROR: When trying to view page", currentPageID, e);
                    // TODO: Translate
                    // alert("Something when wrong trying to create this page");
                    contentsDiv = m("div", "PROBLEM: Failed to view page: " + currentPageID);
                }
            }
            return m("div.pageContents", { key: "pageContents" }, contentsDiv);
        }
    };
    // Call this once at the beginning of the application
    function configurePageDisplayer(thePanelBuilder, theProject, theClientState) {
        panelBuilder = thePanelBuilder;
        project = theProject;
        clientState = theClientState;
        m.mount(document.getElementById("pageDiv"), PageDisplayer);
    }
    exports.configurePageDisplayer = configurePageDisplayer;
    function showPage(pageID, forceRefresh, isRedrawAlreadyQueued) {
        // console.log("showPage", pageID, forceRefresh);
        if (forceRefresh === void 0) { forceRefresh = false; }
        if (isRedrawAlreadyQueued === void 0) { isRedrawAlreadyQueued = false; }
        if (!pageID)
            pageID = PanelSetup.startPage();
        if (currentPageID === pageID && !forceRefresh) {
            // console.log("Page is already current; returning");
            return;
        }
        var pageSpecification;
        try {
            pageSpecification = panelBuilder.getPageSpecificationForPageID(pageID);
        }
        catch (e) {
            console.log("Problem finding pageSpecification for", pageID);
        }
        var badPage = null;
        // Assume that if we have a panel specification for a page that it is OK to go to it
        if (!pageSpecification || pageSpecification.displayType !== "page") {
            console.log("no such page", pageID);
            alert("No such page: " + pageID);
            badPage = pageID;
            // Put back the hash if there was a valid one there already
            if (currentPageID !== null && currentPageID !== pageID) {
                pageID = currentPageID;
            }
            else {
                pageID = PanelSetup.startPage();
            }
            // clientState.updateHashIfNeededForChangedClientState();
            try {
                pageSpecification = panelBuilder.getPageSpecificationForPageID(pageID);
            }
            catch (e) {
                console.log("Problem finding pageSpecification for", pageID);
            }
        }
        // Just going to assume we will be redrawing later via Mithril...
        // Make sure the hash is pointing to this page if this is not a forced refresh
        if (currentPageID !== pageID || badPage) {
            // console.log("setting currentPageID to", pageID);
            currentPageID = pageID;
            currentPageSpecification = pageSpecification;
            clientState.pageIdentifier(currentPageID);
        }
        navigationPane.setCurrentPageSpecification(pageID, pageSpecification);
        if (!isRedrawAlreadyQueued) {
            try {
                m.redraw();
            }
            catch (e) {
                console.log("ERROR: When trying to redraw page", currentPageID, e);
            }
        }
    }
    exports.showPage = showPage;
    function getCurrentPageID() {
        return currentPageID;
    }
    exports.getCurrentPageID = getCurrentPageID;
});

define('js/sanitizeHTML',["require", "exports", "mithril"], function (require, exports, m) {
    "use strict";
    // This constructs a nested Mithril object with only specific HTML tags allowed
    // No attributes are allowed.
    // A css class (from a short approved list) can be set on a tag using a ".className" after the opening tag name.
    // For example: <span.narrafirma-special-warning>Warning!!!<span>
    // 1 is normal tag that needs to be closed; 2 is self-closing tag (br and hr)
    var allowedHTMLTags = {
        // a
        address: 1,
        article: 1,
        b: 1,
        big: 1,
        blockquote: 1,
        br: 2,
        caption: 1,
        cite: 1,
        code: 1,
        del: 1,
        div: 1,
        dd: 1,
        d1: 1,
        dt: 1,
        em: 1,
        h1: 1,
        h2: 1,
        h3: 1,
        h4: 1,
        h5: 1,
        h6: 1,
        hr: 2,
        i: 1,
        // img
        kbd: 1,
        li: 1,
        ol: 1,
        p: 1,
        pre: 1,
        s: 1,
        small: 1,
        span: 1,
        sup: 1,
        sub: 1,
        strong: 1,
        strike: 1,
        table: 1,
        td: 1,
        th: 1,
        tr: 1,
        u: 1,
        ul: 1
    };
    var smallerSubsetOfAllowedHTMLTags = {
        b: 1,
        big: 1,
        em: 1,
        i: 1,
        s: 1,
        small: 1,
        sup: 1,
        sub: 1,
        strong: 1,
        strike: 1,
        u: 1
    };
    var allowedCSSClasses = {
        "narrafirma-special-warning": 1
    };
    function generateSanitizedHTMLForMithril(html) {
        return generateSpecificTypeOfSanitizedHTMLForMithril(html, allowedHTMLTags);
    }
    exports.generateSanitizedHTMLForMithril = generateSanitizedHTMLForMithril;
    function generateSmallerSetOfSanitizedHTMLForMithril(html) {
        return generateSpecificTypeOfSanitizedHTMLForMithril(html, smallerSubsetOfAllowedHTMLTags);
    }
    exports.generateSmallerSetOfSanitizedHTMLForMithril = generateSmallerSetOfSanitizedHTMLForMithril;
    function generateSpecificTypeOfSanitizedHTMLForMithril(html, specifiedHTMLTags) {
        // console.log("html", html);
        if (html === undefined || html === null) {
            console.log("Undefined or null html", html);
            html = "";
        }
        // Handle case where is already a Mithril object
        if (html.tag)
            return html;
        var hasMarkup = html.indexOf("<") !== -1;
        // console.log("has markup", hasMarkup);
        if (!hasMarkup)
            return html;
        // Use a fake div tag as a conceptual placeholder
        var tags = [{ tagName: "div", cssClass: undefined }];
        var output = [[]];
        var text = "";
        for (var i = 0, l = html.length; i < l; i++) {
            var c = html.charAt(i);
            if (c === "<") {
                if (text !== "") {
                    output[output.length - 1].push(text);
                    text = "";
                }
                var closing = html.charAt(i + 1) === "/";
                if (closing)
                    i++;
                var pos = html.indexOf(">", i + 1);
                if (pos < 0) {
                    throw new Error("no closing angle bracket found after position: " + i);
                }
                var tagName = html.substring(i + 1, pos);
                i = pos;
                // console.log("tagName", tagName);
                var cssClass;
                var parts = tagName.split(".");
                if (parts.length > 1) {
                    tagName = parts[0];
                    cssClass = parts[1];
                }
                else {
                    cssClass = undefined;
                }
                if (/[^A-Za-z0-9]/.test(tagName)) {
                    throw new Error("tag is not alphanumeric: " + tagName);
                }
                if (cssClass && !allowedCSSClasses[cssClass]) {
                    throw new Error("css class is not allowed: " + cssClass);
                }
                if (closing) {
                    var startTag = tags.pop();
                    if (startTag.tagName !== tagName) {
                        throw new Error("closing tag does not match opening tag for: " + tagName);
                    }
                    cssClass = startTag.cssClass;
                }
                if (!specifiedHTMLTags[tagName]) {
                    throw new Error("tag is not allowed: " + tagName);
                }
                if (specifiedHTMLTags[tagName] === 2) {
                    // self-closing tag like BR
                    output.push([]);
                    closing = true;
                }
                if (closing) {
                    var newTag;
                    if (cssClass) {
                        newTag = m(tagName, { "class": cssClass }, output.pop());
                    }
                    else {
                        newTag = m(tagName, output.pop());
                    }
                    output[output.length - 1].push(newTag);
                }
                else {
                    tags.push({ tagName: tagName, cssClass: cssClass });
                    output.push([]);
                }
            }
            else {
                text = text + c;
            }
        }
        if (text)
            output[output.length - 1].push(text);
        if (tags.length !== 1 || output.length !== 1) {
            throw new Error("Unmatched start tag: " + tags.pop());
        }
        // Don't return the fake div tag, just the contents
        return output.pop();
    }
    exports.generateSpecificTypeOfSanitizedHTMLForMithril = generateSpecificTypeOfSanitizedHTMLForMithril;
});

define('js/surveyBuilderMithril',["require", "exports", "mithril", "./pointrel20150417/generateRandomUuid", "./sanitizeHTML"], function (require, exports, m, generateRandomUuid, sanitizeHTML) {
    "use strict";
    // TODO: Fix overly long lines and remove next line disabling check
    /* tslint:disable:max-line-length */
    // Accessibility References:
    // http://usabilitygeek.com/10-free-web-based-web-site-accessibility-evaluation-tools/
    // http://validator.w3.org/mobile/
    // http://achecker.ca/checker/index.php#output_div [first used testing tool]
    // http://webaim.org/techniques/forms/controls
    /* TODO:
     * All widget types:
     X   boolean
     X   radiobuttons
     X   checkbox
     *   (maybe) image
     *   (maybe) togglebutton
     * Multiple eliciting questions
     X Storing data in model
     X Add styling classes
     X Dialog version
     X Call validation for each story
     * (Optional) Reporting validation errors inline
     * (Optional for now) Call translate
     X After survey is sent, make the form read-only somehow
     X Accessibility [at least the basics]
     */
    var idsMade = {};
    var idCount = 0;
    function getIdForText(text) {
        if (!idsMade["$" + text]) {
            idsMade["$" + text] = idCount++;
        }
        return "panelField_" + idsMade["$" + text];
    }
    // Redrawing
    var globalRedrawCallback;
    function setGlobalRedrawFunction(callback) {
        globalRedrawCallback = callback;
    }
    exports.setGlobalRedrawFunction = setGlobalRedrawFunction;
    function globalRedraw(source) {
        if (source === void 0) { source = undefined; }
        globalRedrawCallback(source);
    }
    function addAllowedHTMLToPrompt(text) {
        return sanitizeHTML.generateSanitizedHTMLForMithril(text);
    }
    function buildQuestionLabel(fieldSpecification) {
        return [
            // TODO: Generalize this css class name
            m("span", { "class": "narrafirma-survey-prompt" }, addAllowedHTMLToPrompt(fieldSpecification.displayPrompt)),
            m("br")
        ];
    }
    // Builder is used by main application, and is passed in for compatibility
    function displayQuestion(builder, model, fieldSpecification) {
        var fieldID = fieldSpecification.id;
        if (model) {
            fieldID = (model.storyID || model.participantID) + "__" + fieldID;
        }
        var displayType = fieldSpecification.displayType;
        var questionLabel = buildQuestionLabel(fieldSpecification);
        function makeLabel() {
            // The for attribute of the label element must refer to a form control.
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
        }
        var parts = [];
        function makeLegend() {
            // Do nothing for now
            parts.unshift(m("legend", questionLabel[0]));
            questionLabel = [];
        }
        var value = null;
        if (model)
            value = model[fieldSpecification.id];
        if (value === undefined)
            value = "";
        function change(event, value) {
            if (event)
                value = event.target.value;
            // console.log("onchange", fieldSpecification.id, value);
            model[fieldSpecification.id] = value;
            // TODO: redraw on value change seems not needed in this survey case, since values do not affect anything about rest of application?
            // redraw();
            // Except for one case. Could there be more?
            if (fieldSpecification.id === "storyName")
                globalRedraw();
            // yes, there is one more case - the slider needs to interact with the "Does not apply" checkbox
            if (fieldSpecification.displayType === "slider")
                globalRedraw();
        }
        function isEmpty(value) {
            return value === undefined || value === null || value === "";
        }
        var standardValueOptions = {
            value: value,
            id: getIdForText(fieldID),
            onchange: change
        };
        if (displayType === "label") {
        }
        else if (displayType === "header") {
        }
        else if (displayType === "text") {
            makeLabel();
            parts = [
                m("input", standardValueOptions),
                m("br")
            ];
        }
        else if (displayType === "textarea") {
            makeLabel();
            parts = [
                m("textarea", standardValueOptions),
                m("br")
            ];
        }
        else if (displayType === "checkbox") {
            makeLabel();
            var checkboxText = "";
            if (fieldSpecification.displayConfiguration) {
                checkboxText = fieldSpecification.displayConfiguration;
            }
            parts = [
                m("input[type=checkbox]", {
                    id: getIdForText(fieldID),
                    checked: value,
                    onchange: function (event) { change(null, event.target.checked); } }),
                m("label", { "for": getIdForText(fieldID) }, checkboxText),
                m("br")
            ];
        }
        else if (displayType === "checkboxes") {
            // The for attribute of the label element must refer to a form control.
            delete questionLabel[0].attrs["for"];
            if (!value) {
                value = {};
                model[fieldSpecification.id] = value;
            }
            parts = [
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionName;
                    var optionValue;
                    if (typeof option === "string") {
                        optionName = option;
                        optionValue = option;
                    }
                    else {
                        optionName = option.name;
                        optionValue = option.value;
                    }
                    var optionID = getIdForText(fieldID + "_" + option);
                    return [
                        m("input[type=checkbox]", {
                            id: optionID,
                            checked: !!value[optionValue],
                            onchange: function (event) {
                                value[optionValue] = event.target.checked;
                                change(null, value);
                            }
                        }),
                        m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(optionName)),
                        m("br")
                    ];
                })
            ];
            makeLegend();
            parts = [m("fieldset", parts)];
        }
        else if (displayType === "radiobuttons") {
            // The for attribute of the label element must refer to a form control.
            delete questionLabel[0].attrs["for"];
            parts = [
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionName;
                    var optionValue;
                    if (typeof option === "string") {
                        optionName = option;
                        optionValue = option;
                    }
                    else {
                        optionName = option.name;
                        optionValue = option.value;
                    }
                    var optionID = getIdForText(fieldID + "_" + optionValue);
                    return [
                        m("input[type=radio]", { id: optionID, value: optionValue, name: fieldSpecification.id, checked: value === optionValue, onchange: change.bind(null, null, optionValue) }),
                        m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(optionName)),
                        m("br")
                    ];
                })
            ];
            makeLegend();
            parts = [m("fieldset", parts)];
        }
        else if (displayType === "boolean") {
            // The for attribute of the label element must refer to a form control.
            delete questionLabel[0].attrs["for"];
            parts = [
                m("input[type=radio]", { id: getIdForText(fieldID + "_yes"), value: true, name: fieldSpecification.id, checked: value === true, onchange: change.bind(null, null, true) }),
                m("label", { "for": getIdForText(fieldID + "_yes") }, "yes"),
                m("br"),
                m("input[type=radio]", { id: getIdForText(fieldID + "_no"), value: false, name: fieldSpecification.id, checked: value === false, onchange: change.bind(null, null, false) }),
                m("label", { "for": getIdForText(fieldID + "_no") }, "no"),
                m("br")
            ];
            makeLegend();
            parts = [m("fieldset", parts)];
        }
        else if (displayType === "select") {
            makeLabel();
            var selectOptions = [];
            var defaultOptions = {
                name: '',
                value: '',
                selected: undefined
            };
            if (!value)
                defaultOptions.selected = 'selected';
            selectOptions.push(m("option", defaultOptions, '-- select --'));
            selectOptions = selectOptions.concat(fieldSpecification.valueOptions.map(function (option, index) {
                var optionName;
                var optionValue;
                if (typeof option === "string") {
                    optionName = option;
                    optionValue = option;
                }
                else {
                    optionName = option.name;
                    optionValue = option.value;
                }
                var optionOptions = { value: optionValue, selected: undefined };
                // console.log("optionValue, value", optionValue, value, optionValue === value);
                if (optionValue === value)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, optionName);
            }));
            parts = [
                m("select", standardValueOptions, selectOptions),
                m("br")
            ];
        }
        else if (displayType === "slider") {
            makeLabel();
            var checkboxID = getIdForText(fieldID) + "_doesNotApply";
            var sliderValueOptions = {
                value: value,
                id: getIdForText(fieldID),
                onchange: change,
                min: 0,
                max: 100,
                step: 1
            };
            var leftSideText = "";
            var rightSideText = "";
            var doesNotApplyText = "Does not apply";
            if (fieldSpecification.displayConfiguration) {
                if (fieldSpecification.displayConfiguration.length > 1) {
                    leftSideText = fieldSpecification.displayConfiguration[0];
                    rightSideText = fieldSpecification.displayConfiguration[1];
                }
                if (fieldSpecification.displayConfiguration.length > 2) {
                    doesNotApplyText = fieldSpecification.displayConfiguration[2];
                }
            }
            // Could suggest 0-100 to support <IE10 that don't have range input -- or could do polyfill
            // if (fieldSpecification.displayPrompt) questionLabel[0].children = fieldSpecification.displayPrompt + " (0-100)";
            parts = [
                m("span", { "class": "narrafirma-survey-low" }, "◀ " + leftSideText),
                m('span', { "class": "narrafirma-survey-slider" }, m('input[type="range"]', sliderValueOptions)),
                m('span', { "class": "narrafirma-survey-high" }, rightSideText + " ▶"),
                m("br"),
                m('input[type="checkbox"]', {
                    "class": "narrafirma-survey-does-not-apply",
                    id: checkboxID,
                    checked: isEmpty(sliderValueOptions.value),
                    onclick: function (event) {
                        var isChecked = event.target.checked;
                        if (isChecked) {
                            model[fieldSpecification.id] = "";
                            globalRedraw();
                        }
                        else {
                            model[fieldSpecification.id] = "50";
                            globalRedraw();
                        }
                    }
                }),
                m("label", { "for": checkboxID }, doesNotApplyText)
            ];
        }
        else {
            parts = [
                m("span", { style: { "font-weight": "bold" } }, "UNFINISHED: " + fieldSpecification.displayType),
                m("br")
            ];
        }
        if (parts.length) {
            parts = m("div", { "class": "narrafirma-survey-question-internal" }, parts);
        }
        if (questionLabel) {
            parts = questionLabel.concat(parts);
        }
        var classString = "narrafirma-survey-question-external narrafirma-survey-question-type-" + displayType;
        if (fieldSpecification.displayClass) {
            classString += " " + fieldSpecification.displayClass;
        }
        return m("div", { key: fieldID, "class": classString }, parts);
    }
    function buildSurveyForm(surveyDiv, questionnaire, doneCallback, surveyOptions) {
        if (surveyOptions === void 0) { surveyOptions = {}; }
        console.log("buildSurveyForm questions", questionnaire);
        var startText = questionnaire.startText;
        // TODO: Translate
        if (!startText)
            startText = 'Please help by taking a short survey. The data you enter will be sent to the server only at the end when you press the "submit survey" button.';
        var startQuestions = [];
        if (surveyOptions.previewMode) {
            startQuestions.push({ id: "previewMode_header", displayName: "previewMode", displayClass: "narrafirma-preview", displayPrompt: "Previewing story form; results will not be saved.", displayType: "header", valueOptions: [] });
        }
        if (questionnaire.title) {
            startQuestions.push({ id: "title_header", displayName: "title", displayPrompt: questionnaire.title, displayType: "header", valueOptions: [] });
            if (!surveyOptions.ignoreTitleChange)
                document.title = questionnaire.title;
        }
        startQuestions.push({ id: "startText_label", displayName: "startText", displayPrompt: startText, displayType: "label", valueOptions: [] });
        var endText = questionnaire.endText;
        // TODO: Translate
        if (!endText)
            endText = "Thank you for taking the survey.";
        var endQuestions = [];
        endQuestions.push({ id: "endText_label", displayName: "endText", displayPrompt: endText, displayType: "label", valueOptions: [] });
        // TODO: What about idea of having IDs that go with eliciting questions so store reference to ID not text prompt?
        var elicitingQuestionOptions = [];
        for (var elicitingQuestionIndex in questionnaire.elicitingQuestions) {
            var elicitingQuestionSpecification = questionnaire.elicitingQuestions[elicitingQuestionIndex];
            var value = elicitingQuestionSpecification.id || elicitingQuestionSpecification.text;
            var option = { name: elicitingQuestionSpecification.text, value: value };
            elicitingQuestionOptions.push(option);
        }
        // TODO: What if these IDs for storyText and storyName are not unique?
        var initialStoryQuestions = [];
        var singlePrompt = null;
        // initialStoryQuestions.push({id: "questionHeader", displayName: "questionHeader", displayPrompt: "Story", displayType: "header", valueOptions: []});
        if (elicitingQuestionOptions.length !== 1) {
            initialStoryQuestions.push({ id: "elicitingQuestion", displayName: "elicitingQuestion", displayPrompt: "Please choose a question to which you would like to respond:", displayType: "radiobuttons", valueOptions: elicitingQuestionOptions });
            initialStoryQuestions.push({ id: "storyText", displayName: "storyText", displayPrompt: "Please enter your response in the box below:", displayType: "textarea", valueOptions: [] });
        }
        else {
            singlePrompt = elicitingQuestionOptions[0];
            initialStoryQuestions.push({ id: "storyText", displayName: "storyText", displayPrompt: singlePrompt.text, displayType: "textarea", valueOptions: [] });
        }
        initialStoryQuestions.push({ id: "storyName", displayName: "storyName", displayPrompt: "Please give your story a name.", displayType: "text", valueOptions: [] });
        var allStoryQuestions = initialStoryQuestions.concat(questionnaire.storyQuestions);
        var participantQuestions = [{ id: "participantHeader", displayName: "participantHeader", displayPrompt: "About you", displayType: "header", valueOptions: [] }];
        participantQuestions = participantQuestions.concat(questionnaire.participantQuestions);
        // TODO: For testing
        // participantQuestions.push({id: "test1", displayName: "test1", displayPrompt: "test checkbox", displayType: "checkbox", valueOptions:[]});
        // participantQuestions.push({id: "test2", displayName: "test2", displayPrompt: "test boolean", displayType: "boolean", valueOptions:[]});
        // participantQuestions.push({id: "test3", displayName: "test3", displayPrompt: "test radiobuttons", displayType: "radiobuttons", valueOptions:["one", "two", "three"]});
        var timestampStart = new Date();
        var surveyResult = {
            __type: "org.workingwithstories.QuestionnaireResponse",
            // TODO: Think about whether to include entire questionnaire or something else perhaps
            questionnaire: questionnaire,
            responseID: generateRandomUuid("QuestionnaireResponse"),
            stories: [],
            participantData: null,
            timestampStart: "" + timestampStart.toISOString()
        };
        var participantID = generateRandomUuid("Participant");
        var participantDataModel = {
            __type: "org.workingwithstories.ParticipantData",
            participantID: participantID
        };
        surveyResult.participantData = participantDataModel;
        // m.render(surveyDiv, m("div", ["Hello survey ============== b", "More!!"]));
        console.log("startQuestions", startQuestions);
        var stories = surveyResult.stories;
        function addStory() {
            var storyQuestionsModel = {
                __type: "org.workingwithstories.Story",
                storyID: generateRandomUuid("Story"),
                participantID: participantID,
                elicitingQuestion: undefined
            };
            if (singlePrompt)
                storyQuestionsModel.elicitingQuestion = singlePrompt.value;
            stories.push(storyQuestionsModel);
        }
        addStory();
        function makeLabelForStory(story, index) {
            var storyLabel = story.storyName;
            if (storyLabel)
                storyLabel = storyLabel.trim();
            if (!storyLabel) {
                storyLabel = 'untitled story #' + (index + 1);
            }
            else {
                storyLabel = '"' + storyLabel + '"';
            }
            return storyLabel;
        }
        // submitted can be one of: "never", "pending", "failed", "success"
        var submitted = "never";
        function submitSurvey(surveyResult, wizardPane, doneCallback) {
            console.log("submitting survey...");
            var timestampEnd = new Date();
            surveyResult.timestampEnd = timestampEnd.toISOString();
            surveyResult.timeDuration_ms = timestampEnd.getTime() - timestampStart.getTime();
            console.log("survey answers", surveyResult);
            doneCallback("submitted", surveyResult, wizardPane);
        }
        function validateStoryQuestionsModel(storyQuestionsModel, index) {
            var storyIndex = "story #" + (index + 1);
            // TODO: Translate
            var elicitingQuestion = storyQuestionsModel.elicitingQuestion;
            var storyName = storyQuestionsModel.storyName;
            var storyText = storyQuestionsModel.storyText;
            if (!elicitingQuestion) {
                alert("Before proceeding, please select the question to which you are responding for " + storyIndex);
                return false;
            }
            if (!storyText) {
                alert("Please enter a story before proceeding for " + storyIndex);
                return false;
            }
            if (!storyName) {
                alert("Please give your story a name before proceeding for " + storyIndex);
                return false;
            }
            return true;
        }
        function displayStoryQuestions(story, index) {
            var storylabel = makeLabelForStory(story, index);
            var result = [
                // m("span", {"class": "narrafirma-survey-story-label", style: {"font-weight": "bold"}}, "Story #" + (index + 1)),
                // m("br"),
                m("button", {
                    "class": "narrafirma-survey-delete-story-button",
                    onclick: function () {
                        // TODO: Only confirm if the story has a title or text
                        if (!confirm("Are you sure you want to delete this story (" + storylabel + ")?"))
                            return;
                        stories.splice(index, 1);
                        redraw();
                    }
                }, "Delete this story"),
                m("hr"),
                allStoryQuestions.map(displayQuestion.bind(null, null, story))
            ];
            var evenOrOdd = (index % 2 === 1) ? "narrafirma-survey-story-odd" : "narrafirma-survey-story-even";
            // A locally unique key needs to be defined so Mithril can track deletions and inserts without rebuilding DOM nodes
            return m("div", { key: story.storyID, "class": "narrafirma-survey-story " + evenOrOdd }, result);
        }
        function validate() {
            // TODO: Improve validation
            if (!stories.length) {
                alert("Please add at least one story before proceeding.");
                return false;
            }
            for (var i = 0; i < stories.length; i++) {
                var story = stories[i];
                if (!validateStoryQuestionsModel(story, i))
                    return false;
            }
            return true;
        }
        function submitButtonPressed() {
            if (!validate())
                return;
            console.log("Submit survey validated");
            // TODO: Fix no-longer-correct name from Dojo version
            var wizardPane = {
                forward: function () {
                    console.log("survey sending success" + (surveyOptions.previewMode ? " [preview mode only]" : ""));
                    submitted = "success";
                    // TODO: Translate
                    alert("Your contribution has been added to the story collection. Thank you.");
                    redraw("network");
                },
                failed: function () {
                    console.log("survey sending failed");
                    submitted = "failed";
                    // TODO: Translate
                    alert("Problem saving survey result; check the console for details.\nPlease try to submit the survey result later.");
                    redraw("network");
                }
            };
            submitted = "pending";
            submitSurvey(surveyResult, wizardPane, doneCallback);
            redraw();
        }
        function submitButtonOrWaitOrFinal() {
            if (submitted === "never") {
                return m("button", { "class": "narrafirma-survey-submit-survey-button", onclick: submitButtonPressed }, "Submit Survey" + (surveyOptions.previewMode ? " [preview mode only]" : ""));
            }
            else if (submitted === "failed") {
                return m("div", [
                    "Sending to server failed. Please try again...",
                    m("br"),
                    m("button", { "class": "narrafirma-survey-submit-survey-button", onclick: submitButtonPressed }, "Resubmit Survey" + (surveyOptions.previewMode ? " [preview mode only]" : ""))
                ]);
            }
            else if (submitted === "pending") {
                return m("div", ["Sending survey result to server... Please wait..."]);
            }
            else {
                return endQuestions.map(function (question, index) {
                    return m("div", [
                        "Server accepted survey OK",
                        m("br"),
                        displayQuestion(null, null, question),
                        m("br"),
                        m("br")
                    ]);
                });
            }
        }
        function tellAnotherStory() {
            addStory();
            redraw();
        }
        var tagsToMakeReadOnly = {
            "input": true,
            "select": true,
            "textarea": true,
            "button": true
        };
        // Make survey read-only after sent to server
        // Recursive function derived from: http://lhorie.github.io/mithril-blog/when-css-lets-you-down.html
        function makeReadOnly(root, parent) {
            if (!root) {
                return root;
            }
            if (root instanceof Array) {
                for (var i = 0; i < root.length; i++) {
                    makeReadOnly(root[i], parent);
                }
                return;
            }
            if (root.children) {
                makeReadOnly(root.children, root);
            }
            if (typeof root === "object" && root.tag in tagsToMakeReadOnly) {
                // console.log("makeReadOnly", root);
                if (root.tag === "textarea" || (root.tag === "input" && !root.attrs.type)) {
                    // Ensure text fields still have copy available
                    root.attrs.readOnly = true;
                }
                else {
                    root.attrs.disabled = true;
                }
            }
            return root;
        }
        function anotherStoryButton() {
            return m("div", { "class": "narrafirma-survey-tell-another-story-button-panel" }, [
                "Would you like to tell another story?",
                m("button", { "class": "narrafirma-survey-tell-another-story-button", onclick: tellAnotherStory }, "Yes, I'd like to tell another story")
            ]);
        }
        var view = function () {
            var result = m("div", [
                startQuestions.map(function (question, index) {
                    return m("div", [displayQuestion(null, null, question)]);
                }),
                stories.map(function (story, index) {
                    return displayStoryQuestions(story, index);
                }),
                anotherStoryButton(),
                participantQuestions.map(function (question, index) {
                    return m("div", [displayQuestion(null, surveyResult.participantData, question)]);
                }),
                submitButtonOrWaitOrFinal()
            ]);
            if (submitted === "pending" || submitted === "success") {
                makeReadOnly(result, null);
            }
            return result;
        };
        function redraw(source) {
            if (source === void 0) { source = "gui"; }
            // console.log("About to redraw");
            if (surveyDiv) {
                m.render(surveyDiv, view());
            }
            else {
                // When the survery form is used in a Dialog, the code will be calling redraw automatically as a mounted component,
                // so only need to call redraw for an asynchronous server response
                if (source === "network")
                    m.redraw();
            }
        }
        setGlobalRedrawFunction(redraw);
        redraw();
        // Return a function that could be called to produce a survey template, like for a dialog
        return view;
    }
    exports.buildSurveyForm = buildSurveyForm;
});

define('js/storyCardDisplay',["require", "exports", "mithril", "./questionnaireGeneration", "./Globals"], function (require, exports, m, questionnaireGeneration, Globals) {
    "use strict";
    function wrap(elementType, cssClass, text) {
        return m(elementType, { "class": cssClass }, text);
    }
    function displayHTMLForSlider(fieldSpecification, fieldName, value) {
        if (fieldSpecification.displayConfiguration.length < 2) {
            console.log("missing displayConfiguration for slider", fieldSpecification);
            return m("div", "ERROR: Problem displaying slider " + fieldSpecification.id);
        }
        // Assumes values go from 0 to 100; places 100.0 in last bucket
        var lowLabel = fieldSpecification.displayConfiguration[0];
        var highLabel = fieldSpecification.displayConfiguration[1];
        var sliderText = [];
        var bucketCount = 40;
        var bucketSize = 100.0 / bucketCount;
        var placed = false;
        for (var i = 0; i < bucketCount; i++) {
            var bucketLow = i * bucketSize;
            var bucketHigh = i * bucketSize + bucketSize;
            if (!placed && value && ((value < bucketHigh) || (value && i === bucketCount - 1))) {
                sliderText.push(m("b", "|"));
                placed = true;
            }
            else {
                sliderText.push("-");
            }
        }
        return m("tr", [
            wrap("td", "narrafirma-story-card-slider-name", fieldName),
            wrap("td", "narrafirma-story-card-slider-label-left", lowLabel),
            wrap("td", "narrafirma-story-card-slider-contents", sliderText),
            wrap("td", "narrafirma-story-card-slider-label-right", highLabel)
        ]);
    }
    function displayHTMLForCheckboxes(fieldSpecification, fieldName, value) {
        var options = [];
        options.push(wrap("span", "narrafirma-story-card-field-name", fieldName + ": "));
        // TODO: What if value is not current available option?
        for (var i = 0; i < fieldSpecification.valueOptions.length; i++) {
            var option = fieldSpecification.valueOptions[i];
            //console.log("checkboxes", option, fieldSpecification, value);
            if (options.length - 1)
                options.push(", ");
            if (value && value[option]) {
                options.push(wrap("span", "narrafirma-story-card-checkboxes-selected", option));
            }
            else {
                options.push(wrap("span", "narrafirma-story-card-checkboxes-unselected", option));
            }
        }
        return options;
    }
    function displayHTMLForRadioButtons(fieldSpecification, fieldName, value) {
        var options = [];
        options.push(wrap("span", "narrafirma-story-card-field-name", fieldName + ": "));
        // TODO: What if value is not current available option?
        for (var i = 0; i < fieldSpecification.valueOptions.length; i++) {
            var option = fieldSpecification.valueOptions[i];
            //console.log("checkboxes", option, fieldSpecification, value);
            if (options.length - 1)
                options.push(", ");
            if (value && value === option) {
                options.push(wrap("span", "narrafirma-story-card-radiobuttons-selected", option));
            }
            else {
                options.push(wrap("span", "narrafirma-story-card-radiobuttons-unselected", option));
            }
        }
        return options;
    }
    function displayHTMLForSelect(fieldSpecification, fieldName, value) {
        var options = [];
        options.push(wrap("span", "narrafirma-story-card-field-name", fieldName + ": "));
        // TODO: What if value is not current available option?
        for (var i = 0; i < fieldSpecification.valueOptions.length; i++) {
            var option = fieldSpecification.valueOptions[i];
            if (options.length - 1)
                options.push(", ");
            if (value && value === option) {
                options.push(wrap("span", "narrafirma-story-card-select-selected", option));
            }
            else {
                options.push(wrap("span", "narrafirma-story-card-select-unselected", option));
            }
        }
        return options;
    }
    function displayHTMLForField(storyModel, fieldSpecification, nobreak) {
        if (nobreak === void 0) { nobreak = null; }
        // if (!model[fieldSpecification.id]) return "";
        var value = storyModel.fieldValue(fieldSpecification.id);
        // TODO: extra checking here for problems with test data -- could probably be changed back to just displayName eventually
        var fieldName = fieldSpecification.displayName || fieldSpecification.displayPrompt;
        var result = [];
        if (fieldSpecification.displayType === "slider") {
            result.push(displayHTMLForSlider(fieldSpecification, fieldName, value));
        }
        else if (fieldSpecification.displayType === "checkboxes") {
            result.push(displayHTMLForCheckboxes(fieldSpecification, fieldName, value));
        }
        else if (fieldSpecification.displayType === "select") {
            result.push(displayHTMLForSelect(fieldSpecification, fieldName, value));
        }
        else if (fieldSpecification.displayType === "radiobuttons") {
            result.push(displayHTMLForRadioButtons(fieldSpecification, fieldName, value));
        }
        else if (fieldSpecification.displayType === "label" || fieldSpecification.displayType === "header") {
            return [];
        }
        else {
            // TODO: May need more handling here for other cases
            result.push(wrap("span", "narrafirma-story-card-field-name", fieldName + ": "));
            result.push(value);
        }
        if (!nobreak) {
            result.push(m("br"));
        }
        return result;
    }
    function generateStoryCardContent(storyModel, options) {
        if (options === void 0) { options = {}; }
        // Encode all user-supplied text to ensure it does not create HTML issues
        var elicitingQuestion = storyModel.elicitingQuestion();
        // console.log("elicitingQuestion", elicitingQuestion);
        var storyName = storyModel.storyName();
        var storyText = storyModel.storyText();
        var otherFields = [];
        var questions = [];
        var questionnaire = storyModel.questionnaire();
        if (options.questionnaire)
            questionnaire = options.questionnaire;
        if (questionnaire)
            questions = questions.concat(questionnaire.storyQuestions);
        if (questionnaire)
            questions = questions.concat(questionnaire.participantQuestions);
        questions.sort(function (a, b) {
            var aName = a.displayName || a.displayPrompt || "";
            aName = aName.toLowerCase();
            var bName = b.displayName || b.displayPrompt || "";
            bName = bName.toLowerCase();
            if (aName < bName)
                return -1;
            if (aName > bName)
                return 1;
            return 0;
        });
        var question;
        var i;
        // Put sliders in a table at the start, so loop twice with different conditions
        for (i = 0; i < questions.length; i++) {
            question = questions[i];
            if (question.displayType !== "slider")
                continue;
            otherFields.push(displayHTMLForField(storyModel, question, "nobreak"));
        }
        if (otherFields.length)
            otherFields = [m("table", otherFields)];
        for (i = 0; i < questions.length; i++) {
            question = questions[i];
            if (question.displayType === "slider")
                continue;
            otherFields.push(displayHTMLForField(storyModel, question));
        }
        // console.log("otherFields", otherFields);
        var textForElicitingQuestion = [];
        if (!options.excludeElicitingQuestion) {
            textForElicitingQuestion = m(".narrafirma-story-card-eliciting-question", [wrap("span", "narrafirma-story-card-eliciting-question-name", "Eliciting question: "),
                elicitingQuestion, m("br")]);
        }
        var storyTextAtTop = [];
        var storyTextClass = "";
        if (options["location"] && options["location"] === "storyBrowser") {
            storyTextClass = "narrafirma-story-card-story-text-in-story-browser";
        }
        else {
            storyTextClass = "narrafirma-story-card-story-text-in-printed-story-cards";
        }
        var storyTextAtBottom = wrap("div", storyTextClass, storyText);
        if (options.storyTextAtTop) {
            storyTextAtTop = storyTextAtBottom;
            storyTextAtBottom = [];
        }
        // place annotations at bottom (so they don't appear the same as the other questions)
        if (!options.excludeAnnotations) {
            var annotationQuestions = Globals.project().collectAllAnnotationQuestions();
            var adjustedAnnotationQuestions = questionnaireGeneration.convertEditorQuestions(annotationQuestions, "A_");
        }
        var annotationFields = [];
        for (i = 0; i < adjustedAnnotationQuestions.length; i++) {
            question = adjustedAnnotationQuestions[i];
            if (question.displayType !== "slider")
                continue;
            annotationFields.push(displayHTMLForField(storyModel, question, "nobreak"));
        }
        if (annotationFields.length)
            annotationFields = [m("table", annotationFields)];
        for (i = 0; i < adjustedAnnotationQuestions.length; i++) {
            question = adjustedAnnotationQuestions[i];
            if (question.displayType === "slider")
                continue;
            annotationFields.push(displayHTMLForField(storyModel, question));
        }
        if (annotationFields.length)
            annotationFields = [wrap("span", "narrafirma-story-card-annotations", annotationFields)];
        var storyCardContent = m("div[class=storyCard]", [
            wrap("div", "narrafirma-story-card-story-title", storyName),
            storyTextAtTop,
            otherFields,
            storyTextAtBottom,
            textForElicitingQuestion,
            annotationFields,
            m("hr")
        ]);
        return storyCardContent;
    }
    exports.generateStoryCardContent = generateStoryCardContent;
});

// jStat 1.4.3 from: https://github.com/jstat/jstat
/* Copyright (c) 2013 jStat

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

define('jstat',[],function() {
    
this.j$ = this.jStat = (function(Math, undefined) {

// For quick reference.
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var toString = Object.prototype.toString;

// Calculate correction for IEEE error
// TODO: This calculation can be improved.
function calcRdx(n, m) {
  var val = n > m ? n : m;
  return Math.pow(10,
                  17 - ~~(Math.log(((val > 0) ? val : -val)) * Math.LOG10E));
}


var isArray = Array.isArray || function isArray(arg) {
  return toString.call(arg) === '[object Array]';
};


function isFunction(arg) {
  return toString.call(arg) === '[object Function]';
}


function isNumber(arg) {
  return typeof arg === 'number' && arg === arg;
}


// Converts the jStat matrix to vector.
function toVector(arr) {
  return concat.apply([], arr);
}


// The one and only jStat constructor.
function jStat() {
  return new jStat._init(arguments);
}


// TODO: Remove after all references in src files have been removed.
jStat.fn = jStat.prototype;


// By separating the initializer from the constructor it's easier to handle
// always returning a new instance whether "new" was used or not.
jStat._init = function _init(args) {
  var i;

  // If first argument is an array, must be vector or matrix.
  if (isArray(args[0])) {
    // Check if matrix.
    if (isArray(args[0][0])) {
      // See if a mapping function was also passed.
      if (isFunction(args[1]))
        args[0] = jStat.map(args[0], args[1]);
      // Iterate over each is faster than this.push.apply(this, args[0].
      for (i = 0; i < args[0].length; i++)
        this[i] = args[0][i];
      this.length = args[0].length;

    // Otherwise must be a vector.
    } else {
      this[0] = isFunction(args[1]) ? jStat.map(args[0], args[1]) : args[0];
      this.length = 1;
    }

  // If first argument is number, assume creation of sequence.
  } else if (isNumber(args[0])) {
    this[0] = jStat.seq.apply(null, args);
    this.length = 1;

  // Handle case when jStat object is passed to jStat.
  } else if (args[0] instanceof jStat) {
    // Duplicate the object and pass it back.
    return jStat(args[0].toArray());

  // Unexpected argument value, return empty jStat object.
  // TODO: This is strange behavior. Shouldn't this throw or some such to let
  // the user know they had bad arguments?
  } else {
    this[0] = [];
    this.length = 1;
  }

  return this;
};
jStat._init.prototype = jStat.prototype;
jStat._init.constructor = jStat;


// Utility functions.
// TODO: for internal use only?
jStat.utils = {
  calcRdx: calcRdx,
  isArray: isArray,
  isFunction: isFunction,
  isNumber: isNumber,
  toVector: toVector
};


// Easily extend the jStat object.
// TODO: is this seriously necessary?
jStat.extend = function extend(obj) {
  var i, j;

  if (arguments.length === 1) {
    for (j in obj)
      jStat[j] = obj[j];
    return this;
  }

  for (i = 1; i < arguments.length; i++) {
    for (j in arguments[i])
      obj[j] = arguments[i][j];
  }

  return obj;
};


// Returns the number of rows in the matrix.
jStat.rows = function rows(arr) {
  return arr.length || 1;
};


// Returns the number of columns in the matrix.
jStat.cols = function cols(arr) {
  return arr[0].length || 1;
};


// Returns the dimensions of the object { rows: i, cols: j }
jStat.dimensions = function dimensions(arr) {
  return {
    rows: jStat.rows(arr),
    cols: jStat.cols(arr)
  };
};


// Returns a specified row as a vector
jStat.row = function row(arr, index) {
  return arr[index];
};


// Returns the specified column as a vector
jStat.col = function cols(arr, index) {
  var column = new Array(arr.length);
  for (var i = 0; i < arr.length; i++)
    column[i] = [arr[i][index]];
  return column;
};


// Returns the diagonal of the matrix
jStat.diag = function diag(arr) {
  var nrow = jStat.rows(arr);
  var res = new Array(nrow);
  for (var row = 0; row < nrow; row++)
    res[row] = [arr[row][row]];
  return res;
};


// Returns the anti-diagonal of the matrix
jStat.antidiag = function antidiag(arr) {
  var nrow = jStat.rows(arr) - 1;
  var res = new Array(nrow);
  for (var i = 0; nrow >= 0; nrow--, i++)
    res[i] = [arr[i][nrow]];
  return res;
};

// Transpose a matrix or array.
jStat.transpose = function transpose(arr) {
  var obj = [];
  var objArr, rows, cols, j, i;

  // Make sure arr is in matrix format.
  if (!isArray(arr[0]))
    arr = [arr];

  rows = arr.length;
  cols = arr[0].length;

  for (i = 0; i < cols; i++) {
    objArr = new Array(rows);
    for (j = 0; j < rows; j++)
      objArr[j] = arr[j][i];
    obj.push(objArr);
  }

  // If obj is vector, return only single array.
  return obj.length === 1 ? obj[0] : obj;
};


// Map a function to an array or array of arrays.
// "toAlter" is an internal variable.
jStat.map = function map(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    for (col = 0; col < ncol; col++)
      res[row][col] = func(arr[row][col], row, col);
  }

  return res.length === 1 ? res[0] : res;
};


// Cumulatively combine the elements of an array or array of arrays using a function.
jStat.cumreduce = function cumreduce(arr, func, toAlter) {
  var row, nrow, ncol, res, col;

  if (!isArray(arr[0]))
    arr = [arr];

  nrow = arr.length;
  ncol = arr[0].length;
  res = toAlter ? arr : new Array(nrow);

  for (row = 0; row < nrow; row++) {
    // if the row doesn't exist, create it
    if (!res[row])
      res[row] = new Array(ncol);
    if (ncol > 0)
      res[row][0] = arr[row][0];
    for (col = 1; col < ncol; col++)
      res[row][col] = func(res[row][col-1], arr[row][col]);
  }
  return res.length === 1 ? res[0] : res;
};


// Destructively alter an array.
jStat.alter = function alter(arr, func) {
  return jStat.map(arr, func, true);
};


// Generate a rows x cols matrix according to the supplied function.
jStat.create = function  create(rows, cols, func) {
  var res = new Array(rows);
  var i, j;

  if (isFunction(cols)) {
    func = cols;
    cols = rows;
  }

  for (i = 0; i < rows; i++) {
    res[i] = new Array(cols);
    for (j = 0; j < cols; j++)
      res[i][j] = func(i, j);
  }

  return res;
};


function retZero() { return 0; }


// Generate a rows x cols matrix of zeros.
jStat.zeros = function zeros(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retZero);
};


function retOne() { return 1; }


// Generate a rows x cols matrix of ones.
jStat.ones = function ones(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retOne);
};


// Generate a rows x cols matrix of uniformly random numbers.
jStat.rand = function rand(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, Math.random);
};


function retIdent(i, j) { return i === j ? 1 : 0; }


// Generate an identity matrix of size row x cols.
jStat.identity = function identity(rows, cols) {
  if (!isNumber(cols))
    cols = rows;
  return jStat.create(rows, cols, retIdent);
};


// Tests whether a matrix is symmetric
jStat.symmetric = function symmetric(arr) {
  var issymmetric = true;
  var size = arr.length;
  var row, col;

  if (arr.length !== arr[0].length)
    return false;

  for (row = 0; row < size; row++) {
    for (col = 0; col < size; col++)
      if (arr[col][row] !== arr[row][col])
        return false;
  }

  return true;
};


// Set all values to zero.
jStat.clear = function clear(arr) {
  return jStat.alter(arr, retZero);
};


// Generate sequence.
jStat.seq = function seq(min, max, length, func) {
  if (!isFunction(func))
    func = false;

  var arr = [];
  var hival = calcRdx(min, max);
  var step = (max * hival - min * hival) / ((length - 1) * hival);
  var current = min;
  var cnt;

  // Current is assigned using a technique to compensate for IEEE error.
  // TODO: Needs better implementation.
  for (cnt = 0;
       current <= max;
       cnt++, current = (min * hival + step * hival * cnt) / hival) {
    arr.push((func ? func(current, cnt) : current));
  }

  return arr;
};


// TODO: Go over this entire implementation. Seems a tragic waste of resources
// doing all this work. Instead, and while ugly, use new Function() to generate
// a custom function for each static method.

// Quick reference.
var jProto = jStat.prototype;

// Default length.
jProto.length = 0;

// For internal use only.
// TODO: Check if they're actually used, and if they are then rename them
// to _*
jProto.push = Array.prototype.push;
jProto.sort = Array.prototype.sort;
jProto.splice = Array.prototype.splice;
jProto.slice = Array.prototype.slice;


// Return a clean array.
jProto.toArray = function toArray() {
  return this.length > 1 ? slice.call(this) : slice.call(this)[0];
};


// Map a function to a matrix or vector.
jProto.map = function map(func, toAlter) {
  return jStat(jStat.map(this, func, toAlter));
};


// Cumulatively combine the elements of a matrix or vector using a function.
jProto.cumreduce = function cumreduce(func, toAlter) {
  return jStat(jStat.cumreduce(this, func, toAlter));
};


// Destructively alter an array.
jProto.alter = function alter(func) {
  jStat.alter(this, func);
  return this;
};


// Extend prototype with methods that have no argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(func) {
      var self = this,
      results;
      // Check for callback.
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self));
        });
        return this;
      }
      results = jStat[passfunc](this);
      return isArray(results) ? jStat(results) : results;
    };
  })(funcs[i]);
})('transpose clear symmetric rows cols dimensions diag antidiag'.split(' '));


// Extend prototype with methods that have one argument.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function(index, func) {
      var self = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(self, jProto[passfunc].call(self, index));
        });
        return this;
      }
      return jStat(jStat[passfunc](this, index));
    };
  })(funcs[i]);
})('row col'.split(' '));


// Extend prototype with simple shortcut methods.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = new Function(
        'return jStat(jStat.' + passfunc + '.apply(null, arguments));');
  })(funcs[i]);
})('create zeros ones rand identity'.split(' '));


// Exposing jStat.
return jStat;

}(Math));
(function(jStat, Math) {

var isFunction = jStat.utils.isFunction;

// Ascending functions for sort
function ascNum(a, b) { return a - b; }

function clip(arg, min, max) {
  return Math.max(min, Math.min(arg, max));
}


// sum of an array
jStat.sum = function sum(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};


// sum squared
jStat.sumsqrd = function sumsqrd(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i] * arr[i];
  return sum;
};


// sum of squared errors of prediction (SSE)
jStat.sumsqerr = function sumsqerr(arr) {
  var mean = jStat.mean(arr);
  var sum = 0;
  var i = arr.length;
  var tmp;
  while (--i >= 0) {
    tmp = arr[i] - mean;
    sum += tmp * tmp;
  }
  return sum;
};

// sum of an array in each row
jStat.sumrow = function sumrow(arr) {
  var sum = 0;
  var i = arr.length;
  while (--i >= 0)
    sum += arr[i];
  return sum;
};

// product of an array
jStat.product = function product(arr) {
  var prod = 1;
  var i = arr.length;
  while (--i >= 0)
    prod *= arr[i];
  return prod;
};


// minimum value of an array
jStat.min = function min(arr) {
  var low = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] < low)
      low = arr[i];
  return low;
};


// maximum value of an array
jStat.max = function max(arr) {
  var high = arr[0];
  var i = 0;
  while (++i < arr.length)
    if (arr[i] > high)
      high = arr[i];
  return high;
};


// mean value of an array
jStat.mean = function mean(arr) {
  return jStat.sum(arr) / arr.length;
};


// mean squared error (MSE)
jStat.meansqerr = function meansqerr(arr) {
  return jStat.sumsqerr(arr) / arr.length;
};


// geometric mean of an array
jStat.geomean = function geomean(arr) {
  return Math.pow(jStat.product(arr), 1 / arr.length);
};


// median of an array
jStat.median = function median(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  // check if array is even or odd, then return the appropriate
  return !(arrlen & 1)
    ? (_arr[(arrlen / 2) - 1 ] + _arr[(arrlen / 2)]) / 2
    : _arr[(arrlen / 2) | 0 ];
};


// cumulative sum of an array
jStat.cumsum = function cumsum(arr) {
  return jStat.cumreduce(arr, function (a, b) { return a + b; });
};


// cumulative product of an array
jStat.cumprod = function cumprod(arr) {
  return jStat.cumreduce(arr, function (a, b) { return a * b; });
};


// successive differences of a sequence
jStat.diff = function diff(arr) {
  var diffs = [];
  var arrLen = arr.length;
  var i;
  for (i = 1; i < arrLen; i++)
    diffs.push(arr[i] - arr[i - 1]);
  return diffs;
};


// mode of an array
// if there are multiple modes of an array, return all of them
// is this the appropriate way of handling it?
jStat.mode = function mode(arr) {
  var arrLen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  var count = 1;
  var maxCount = 0;
  var numMaxCount = 0;
  var mode_arr = [];
  var i;

  for (i = 0; i < arrLen; i++) {
    if (_arr[i] === _arr[i + 1]) {
      count++;
    } else {
      if (count > maxCount) {
        mode_arr = [_arr[i]];
        maxCount = count;
        numMaxCount = 0;
      }
      // are there multiple max counts
      else if (count === maxCount) {
        mode_arr.push(_arr[i]);
        numMaxCount++;
      }
      // resetting count for new value in array
      count = 1;
    }
  }

  return numMaxCount === 0 ? mode_arr[0] : mode_arr;
};


// range of an array
jStat.range = function range(arr) {
  return jStat.max(arr) - jStat.min(arr);
};

// variance of an array
// flag = true indicates sample instead of population
jStat.variance = function variance(arr, flag) {
  return jStat.sumsqerr(arr) / (arr.length - (flag ? 1 : 0));
};


// standard deviation of an array
// flag = true indicates sample instead of population
jStat.stdev = function stdev(arr, flag) {
  return Math.sqrt(jStat.variance(arr, flag));
};


// mean deviation (mean absolute deviation) of an array
jStat.meandev = function meandev(arr) {
  var devSum = 0;
  var mean = jStat.mean(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - mean);
  return devSum / arr.length;
};


// median deviation (median absolute deviation) of an array
jStat.meddev = function meddev(arr) {
  var devSum = 0;
  var median = jStat.median(arr);
  var i;
  for (i = arr.length - 1; i >= 0; i--)
    devSum += Math.abs(arr[i] - median);
  return devSum / arr.length;
};


// coefficient of variation
jStat.coeffvar = function coeffvar(arr) {
  return jStat.stdev(arr) / jStat.mean(arr);
};


// quartiles of an array
jStat.quartiles = function quartiles(arr) {
  var arrlen = arr.length;
  var _arr = arr.slice().sort(ascNum);
  return [
    _arr[ Math.round((arrlen) / 4) - 1 ],
    _arr[ Math.round((arrlen) / 2) - 1 ],
    _arr[ Math.round((arrlen) * 3 / 4) - 1 ]
  ];
};


// Arbitary quantiles of an array. Direct port of the scipy.stats
// implementation by Pierre GF Gerard-Marchant.
jStat.quantiles = function quantiles(arr, quantilesArray, alphap, betap) {
  var sortedArray = arr.slice().sort(ascNum);
  var quantileVals = [quantilesArray.length];
  var n = arr.length;
  var i, p, m, aleph, k, gamma;

  if (typeof alphap === 'undefined')
    alphap = 3 / 8;
  if (typeof betap === 'undefined')
    betap = 3 / 8;

  for (i = 0; i < quantilesArray.length; i++) {
    p = quantilesArray[i];
    m = alphap + p * (1 - alphap - betap);
    aleph = n * p + m;
    k = Math.floor(clip(aleph, 1, n - 1));
    gamma = clip(aleph - k, 0, 1);
    quantileVals[i] = (1 - gamma) * sortedArray[k - 1] + gamma * sortedArray[k];
  }

  return quantileVals;
};

// Returns the k-th percentile of values in a range, where k is in the
// range 0..1, exclusive.
jStat.percentile = function percentile(arr, k) {
  var _arr = arr.slice().sort(ascNum);
  var realIndex = k * (_arr.length - 1);
  var index = parseInt(realIndex);
  var frac = realIndex - index;

  if (index + 1 < _arr.length) {
    return _arr[index] * (1 - frac) + _arr[index + 1] * frac;
  } else {
    return _arr[index];
  }
}


// The percentile rank of score in a given array. Returns the percentage
// of all values in the input array that are less than (kind='strict') or
// less or equal than (kind='weak') score. Default is weak.
jStat.percentileOfScore = function percentileOfScore(arr, score, kind) {
  var counter = 0;
  var len = arr.length;
  var strict = false;
  var value, i;

  if (kind === 'strict')
    strict = true;

  for (i = 0; i < len; i++) {
    value = arr[i];
    if ((strict && value < score) ||
        (!strict && value <= score)) {
      counter++;
    }
  }

  return counter / len;
};


// Histogram (bin count) data
jStat.histogram = function histogram(arr, bins) {
  var first = jStat.min(arr);
  var binCnt = bins || 4;
  var binWidth = (jStat.max(arr) - first) / binCnt;
  var len = arr.length;
  var bins = [];
  var i;

  for (i = 0; i < binCnt; i++)
    bins[i] = 0;
  for (i = 0; i < len; i++)
    bins[Math.min(Math.floor(((arr[i] - first) / binWidth)), binCnt - 1)] += 1;

  return bins;
};


// covariance of two arrays
jStat.covariance = function covariance(arr1, arr2) {
  var u = jStat.mean(arr1);
  var v = jStat.mean(arr2);
  var arr1Len = arr1.length;
  var sq_dev = new Array(arr1Len);
  var i;

  for (i = 0; i < arr1Len; i++)
    sq_dev[i] = (arr1[i] - u) * (arr2[i] - v);

  return jStat.sum(sq_dev) / (arr1Len - 1);
};


// (pearson's) population correlation coefficient, rho
jStat.corrcoeff = function corrcoeff(arr1, arr2) {
  return jStat.covariance(arr1, arr2) /
      jStat.stdev(arr1, 1) /
      jStat.stdev(arr2, 1);
};

// pdfernhout added from jstat pull request: https://github.com/jstat/jstat/pull/163/files
// (spearman's) rank correlation coefficient, sp
jStat.spearmancoeff = function spearmancoeff(arr1, arr2) {
  sortfunction = function(a,b) { return a[1]-b[1]};
  var npoints = arr1.length;
  if (arr1.length != arr2.length)
    return 0.0;
  if (npoints == 0)
    return 0.0;
  var arr1cp = new Array(npoints);
  var arr2cp = new Array(npoints);
  var arr1rank = new Array(npoints);
  var arr2rank = new Array(npoints);
  var arr1cps;
  var arr2cps;
  var dsqr = 0;
  var i;
  for (i = 0; i < npoints; i++){
    arr1cp[i] = [i,arr1[i]];
    arr2cp[i] = [i,arr2[i]];
  }
  var arr1cps = arr1cp.sort(sortfunction);
  var arr2cps = arr2cp.sort(sortfunction);
  for (i = 0; i < npoints; i++){
    arr1rank[arr1cps[i][0]] = i;
    arr2rank[arr2cps[i][0]] = i;
  }
  dsqr = 0;
  for (i = 0; i < npoints; i++){
    dsqr  += (arr1rank[i] - arr2rank[i])*(arr1rank[i] - arr2rank[i]);
  }

  return 1 - dsqr*6.0/(npoints*(npoints*npoints-1))
};

// statistical standardized moments (general form of skew/kurt)
jStat.stanMoment = function stanMoment(arr, n) {
  var mu = jStat.mean(arr);
  var sigma = jStat.stdev(arr);
  var len = arr.length;
  var skewSum = 0;

  for (i = 0; i < len; i++)
    skewSum += Math.pow((arr[i] - mu) / sigma, n);

  return skewSum / arr.length;
};

// (pearson's) moment coefficient of skewness
jStat.skewness = function skewness(arr) {
  return jStat.stanMoment(arr, 3);
};

// (pearson's) (excess) kurtosis
jStat.kurtosis = function kurtosis(arr) {
  return jStat.stanMoment(arr, 4) - 3;
};


var jProto = jStat.prototype;


// Extend jProto with method for calculating cumulative sums and products.
// This differs from the similar extension below as cumsum and cumprod should
// not be run again in the case fullbool === true.
// If a matrix is passed, automatically assume operation should be done on the
// columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('cumsum cumprod').split(' '));


// Extend jProto with methods which don't require arguments and work on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    // If a matrix is passed, automatically assume operation should be done on
    // the columns.
    jProto[passfunc] = function(fullbool, func) {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      // Assignment reassignation depending on how parameters were passed in.
      if (isFunction(fullbool)) {
        func = fullbool;
        fullbool = false;
      }
      // Check if a callback was passed with the function.
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jProto[passfunc].call(tmpthis, fullbool));
        });
        return this;
      }
      // Check if matrix and run calculations.
      if (this.length > 1) {
        if (passfunc !== 'sumrow')
          tmpthis = fullbool === true ? this : this.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = jStat[passfunc](tmpthis[i]);
        return fullbool === true
            ? jStat[passfunc](jStat.utils.toVector(arr))
            : arr;
      }
      // Pass fullbool if only vector, not a matrix. for variance and stdev.
      return jStat[passfunc](this[0], fullbool);
    };
  })(funcs[i]);
})(('sum sumsqrd sumsqerr sumrow product min max mean meansqerr geomean ' +
    'median diff mode range variance stdev meandev meddev coeffvar quartiles ' +
    'histogram skewness kurtosis').split(' '));


// Extend jProto with functions that take arguments. Operations on matrices are
// done on columns.
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jProto[passfunc] = function() {
      var arr = [];
      var i = 0;
      var tmpthis = this;
      var args = Array.prototype.slice.call(arguments);

      // If the last argument is a function, we assume it's a callback; we
      // strip the callback out and call the function again.
      if (isFunction(args[args.length - 1])) {
        var callbackFunction = args[args.length - 1];
        var argsToPass = args.slice(0, args.length - 1);

        setTimeout(function() {
          callbackFunction.call(tmpthis,
                                jProto[passfunc].apply(tmpthis, argsToPass));
        });
        return this;

      // Otherwise we curry the function args and call normally.
      } else {
        var callbackFunction = undefined;
        var curriedFunction = function curriedFunction(vector) {
          return jStat[passfunc].apply(tmpthis, [vector].concat(args));
        }
      }

      // If this is a matrix, run column-by-column.
      if (this.length > 1) {
        tmpthis = tmpthis.transpose();
        for (; i < tmpthis.length; i++)
          arr[i] = curriedFunction(tmpthis[i]);
        return arr;
      }

      // Otherwise run on the vector.
      return curriedFunction(this[0]);
    };
  })(funcs[i]);
})('quantiles percentileOfScore'.split(' '));

}(this.jStat, Math));
// Special functions //
(function(jStat, Math) {

// Log-gamma function
jStat.gammaln = function gammaln(x) {
  var j = 0;
  var cof = [
    76.18009172947146, -86.50532032941677, 24.01409824083091,
    -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
  ];
  var ser = 1.000000000190015;
  var xx, y, tmp;
  tmp = (y = xx = x) + 5.5;
  tmp -= (xx + 0.5) * Math.log(tmp);
  for (; j < 6; j++)
    ser += cof[j] / ++y;
  return Math.log(2.5066282746310005 * ser / xx) - tmp;
};


// gamma of x
jStat.gammafn = function gammafn(x) {
  var p = [-1.716185138865495, 24.76565080557592, -379.80425647094563,
           629.3311553128184, 866.9662027904133, -31451.272968848367,
           -36144.413418691176, 66456.14382024054
  ];
  var q = [-30.8402300119739, 315.35062697960416, -1015.1563674902192,
           -3107.771671572311, 22538.118420980151, 4755.8462775278811,
           -134659.9598649693, -115132.2596755535];
  var fact = false;
  var n = 0;
  var xden = 0;
  var xnum = 0;
  var y = x;
  var i, z, yi, res, sum, ysq;
  if (y <= 0) {
    res = y % 1 + 3.6e-16;
    if (res) {
      fact = (!(y & 1) ? 1 : -1) * Math.PI / Math.sin(Math.PI * res);
      y = 1 - y;
    } else {
      return Infinity;
    }
  }
  yi = y;
  if (y < 1) {
    z = y++;
  } else {
    z = (y -= n = (y | 0) - 1) - 1;
  }
  for (i = 0; i < 8; ++i) {
    xnum = (xnum + p[i]) * z;
    xden = xden * z + q[i];
  }
  res = xnum / xden + 1;
  if (yi < y) {
    res /= yi;
  } else if (yi > y) {
    for (i = 0; i < n; ++i) {
      res *= y;
      y++;
    }
  }
  if (fact) {
    res = fact / res;
  }
  return res;
};


// lower incomplete gamma function, which is usually typeset with a
// lower-case greek gamma as the function symbol
jStat.gammap = function gammap(a, x) {
  return jStat.lowRegGamma(a, x) * jStat.gammafn(a);
};


// The lower regularized incomplete gamma function, usually written P(a,x)
jStat.lowRegGamma = function lowRegGamma(a, x) {
  var aln = jStat.gammaln(a);
  var ap = a;
  var sum = 1 / a;
  var del = sum;
  var b = x + 1 - a;
  var c = 1 / 1.0e-30;
  var d = 1 / b;
  var h = d;
  var i = 1;
  // calculate maximum number of itterations required for a
  var ITMAX = -~(Math.log((a >= 1) ? a : 1 / a) * 8.5 + a * 0.4 + 17);
  var an, endval;

  if (x < 0 || a <= 0) {
    return NaN;
  } else if (x < a + 1) {
    for (; i <= ITMAX; i++) {
      sum += del *= x / ++ap;
    }
    return (sum * Math.exp(-x + a * Math.log(x) - (aln)));
  }

  for (; i <= ITMAX; i++) {
    an = -i * (i - a);
    b += 2;
    d = an * d + b;
    c = b + an / c;
    d = 1 / d;
    h *= d * c;
  }

  return (1 - h * Math.exp(-x + a * Math.log(x) - (aln)));
};

// natural log factorial of n
jStat.factorialln = function factorialln(n) {
  return n < 0 ? NaN : jStat.gammaln(n + 1);
};

// factorial of n
jStat.factorial = function factorial(n) {
  return n < 0 ? NaN : jStat.gammafn(n + 1);
};

// combinations of n, m
jStat.combination = function combination(n, m) {
  // make sure n or m don't exceed the upper limit of usable values
  return (n > 170 || m > 170)
      ? Math.exp(jStat.combinationln(n, m))
      : (jStat.factorial(n) / jStat.factorial(m)) / jStat.factorial(n - m);
};


jStat.combinationln = function combinationln(n, m){
  return jStat.factorialln(n) - jStat.factorialln(m) - jStat.factorialln(n - m);
};


// permutations of n, m
jStat.permutation = function permutation(n, m) {
  return jStat.factorial(n) / jStat.factorial(n - m);
};


// beta function
jStat.betafn = function betafn(x, y) {
  // ensure arguments are positive
  if (x <= 0 || y <= 0)
    return undefined;
  // make sure x + y doesn't exceed the upper limit of usable values
  return (x + y > 170)
      ? Math.exp(jStat.betaln(x, y))
      : jStat.gammafn(x) * jStat.gammafn(y) / jStat.gammafn(x + y);
};


// natural logarithm of beta function
jStat.betaln = function betaln(x, y) {
  return jStat.gammaln(x) + jStat.gammaln(y) - jStat.gammaln(x + y);
};


// Evaluates the continued fraction for incomplete beta function by modified
// Lentz's method.
jStat.betacf = function betacf(x, a, b) {
  var fpmin = 1e-30;
  var m = 1;
  var qab = a + b;
  var qap = a + 1;
  var qam = a - 1;
  var c = 1;
  var d = 1 - qab * x / qap;
  var m2, aa, del, h;

  // These q's will be used in factors that occur in the coefficients
  if (Math.abs(d) < fpmin)
    d = fpmin;
  d = 1 / d;
  h = d;

  for (; m <= 100; m++) {
    m2 = 2 * m;
    aa = m * (b - m) * x / ((qam + m2) * (a + m2));
    // One step (the even one) of the recurrence
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    h *= d * c;
    aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
    // Next step of the recurrence (the odd one)
    d = 1 + aa * d;
    if (Math.abs(d) < fpmin)
      d = fpmin;
    c = 1 + aa / c;
    if (Math.abs(c) < fpmin)
      c = fpmin;
    d = 1 / d;
    del = d * c;
    h *= del;
    if (Math.abs(del - 1.0) < 3e-7)
      break;
  }

  return h;
};


// Returns the inverse of the lower regularized inomplete gamma function
jStat.gammapinv = function gammapinv(p, a) {
  var j = 0;
  var a1 = a - 1;
  var EPS = 1e-8;
  var gln = jStat.gammaln(a);
  var x, err, t, u, pp, lna1, afac;

  if (p >= 1)
    return Math.max(100, a + 100 * Math.sqrt(a));
  if (p <= 0)
    return 0;
  if (a > 1) {
    lna1 = Math.log(a1);
    afac = Math.exp(a1 * (lna1 - 1) - gln);
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t * (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    x = Math.max(1e-3,
                 a * Math.pow(1 - 1 / (9 * a) - x / (3 * Math.sqrt(a)), 3));
  } else {
    t = 1 - a * (0.253 + a * 0.12);
    if (p < t)
      x = Math.pow(p / t, 1 / a);
    else
      x = 1 - Math.log(1 - (p - t) / (1 - t));
  }

  for(; j < 12; j++) {
    if (x <= 0)
      return 0;
    err = jStat.lowRegGamma(a, x) - p;
    if (a > 1)
      t = afac * Math.exp(-(x - a1) + a1 * (Math.log(x) - lna1));
    else
      t = Math.exp(-x + a1 * Math.log(x) - gln);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * ((a - 1) / x - 1))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (Math.abs(t) < EPS * x)
      break;
  }

  return x;
};


// Returns the error function erf(x)
jStat.erf = function erf(x) {
  var cof = [-1.3026537197817094, 6.4196979235649026e-1, 1.9476473204185836e-2,
             -9.561514786808631e-3, -9.46595344482036e-4, 3.66839497852761e-4,
             4.2523324806907e-5, -2.0278578112534e-5, -1.624290004647e-6,
             1.303655835580e-6, 1.5626441722e-8, -8.5238095915e-8,
             6.529054439e-9, 5.059343495e-9, -9.91364156e-10,
             -2.27365122e-10, 9.6467911e-11, 2.394038e-12,
             -6.886027e-12, 8.94487e-13, 3.13092e-13,
             -1.12708e-13, 3.81e-16, 7.106e-15,
             -1.523e-15, -9.4e-17, 1.21e-16,
             -2.8e-17];
  var j = cof.length - 1;
  var isneg = false;
  var d = 0;
  var dd = 0;
  var t, ty, tmp, res;

  if (x < 0) {
    x = -x;
    isneg = true;
  }

  t = 2 / (2 + x);
  ty = 4 * t - 2;

  for(; j > 0; j--) {
    tmp = d;
    d = ty * d - dd + cof[j];
    dd = tmp;
  }

  res = t * Math.exp(-x * x + 0.5 * (cof[0] + ty * d) - dd);
  return isneg ? res - 1 : 1 - res;
};


// Returns the complmentary error function erfc(x)
jStat.erfc = function erfc(x) {
  return 1 - jStat.erf(x);
};


// Returns the inverse of the complementary error function
jStat.erfcinv = function erfcinv(p) {
  var j = 0;
  var x, err, t, pp;
  if (p >= 2)
    return -100;
  if (p <= 0)
    return 100;
  pp = (p < 1) ? p : 2 - p;
  t = Math.sqrt(-2 * Math.log(pp / 2));
  x = -0.70711 * ((2.30753 + t * 0.27061) /
                  (1 + t * (0.99229 + t * 0.04481)) - t);
  for (; j < 2; j++) {
    err = jStat.erfc(x) - pp;
    x += err / (1.12837916709551257 * Math.exp(-x * x) - x * err);
  }
  return (p < 1) ? x : -x;
};


// Returns the inverse of the incomplete beta function
jStat.ibetainv = function ibetainv(p, a, b) {
  var EPS = 1e-8;
  var a1 = a - 1;
  var b1 = b - 1;
  var j = 0;
  var lna, lnb, pp, t, u, err, x, al, h, w, afac;
  if (p <= 0)
    return 0;
  if (p >= 1)
    return 1;
  if (a >= 1 && b >= 1) {
    pp = (p < 0.5) ? p : 1 - p;
    t = Math.sqrt(-2 * Math.log(pp));
    x = (2.30753 + t * 0.27061) / (1 + t* (0.99229 + t * 0.04481)) - t;
    if (p < 0.5)
      x = -x;
    al = (x * x - 3) / 6;
    h = 2 / (1 / (2 * a - 1)  + 1 / (2 * b - 1));
    w = (x * Math.sqrt(al + h) / h) - (1 / (2 * b - 1) - 1 / (2 * a - 1)) *
        (al + 5 / 6 - 2 / (3 * h));
    x = a / (a + b * Math.exp(2 * w));
  } else {
    lna = Math.log(a / (a + b));
    lnb = Math.log(b / (a + b));
    t = Math.exp(a * lna) / a;
    u = Math.exp(b * lnb) / b;
    w = t + u;
    if (p < t / w)
      x = Math.pow(a * w * p, 1 / a);
    else
      x = 1 - Math.pow(b * w * (1 - p), 1 / b);
  }
  afac = -jStat.gammaln(a) - jStat.gammaln(b) + jStat.gammaln(a + b);
  for(; j < 10; j++) {
    if (x === 0 || x === 1)
      return x;
    err = jStat.ibeta(x, a, b) - p;
    t = Math.exp(a1 * Math.log(x) + b1 * Math.log(1 - x) + afac);
    u = err / t;
    x -= (t = u / (1 - 0.5 * Math.min(1, u * (a1 / x - b1 / (1 - x)))));
    if (x <= 0)
      x = 0.5 * (x + t);
    if (x >= 1)
      x = 0.5 * (x + t + 1);
    if (Math.abs(t) < EPS * x && j > 0)
      break;
  }
  return x;
};


// Returns the incomplete beta function I_x(a,b)
jStat.ibeta = function ibeta(x, a, b) {
  // Factors in front of the continued fraction.
  var bt = (x === 0 || x === 1) ?  0 :
    Math.exp(jStat.gammaln(a + b) - jStat.gammaln(a) -
             jStat.gammaln(b) + a * Math.log(x) + b *
             Math.log(1 - x));
  if (x < 0 || x > 1)
    return false;
  if (x < (a + 1) / (a + b + 2))
    // Use continued fraction directly.
    return bt * jStat.betacf(x, a, b) / a;
  // else use continued fraction after making the symmetry transformation.
  return 1 - bt * jStat.betacf(1 - x, b, a) / b;
};


// Returns a normal deviate (mu=0, sigma=1).
// If n and m are specified it returns a object of normal deviates.
jStat.randn = function randn(n, m) {
  var u, v, x, y, q, mat;
  if (!m)
    m = n;
  if (n)
    return jStat.create(n, m, function() { return jStat.randn(); });
  do {
    u = Math.random();
    v = 1.7156 * (Math.random() - 0.5);
    x = u - 0.449871;
    y = Math.abs(v) + 0.386595;
    q = x * x + y * (0.19600 * y - 0.25472 * x);
  } while (q > 0.27597 && (q > 0.27846 || v * v > -4 * Math.log(u) * u * u));
  return v / u;
};


// Returns a gamma deviate by the method of Marsaglia and Tsang.
jStat.randg = function randg(shape, n, m) {
  var oalph = shape;
  var a1, a2, u, v, x, mat;
  if (!m)
    m = n;
  if (!shape)
    shape = 1;
  if (n) {
    mat = jStat.zeros(n,m);
    mat.alter(function() { return jStat.randg(shape); });
    return mat;
  }
  if (shape < 1)
    shape += 1;
  a1 = shape - 1 / 3;
  a2 = 1 / Math.sqrt(9 * a1);
  do {
    do {
      x = jStat.randn();
      v = 1 + a2 * x;
    } while(v <= 0);
    v = v * v * v;
    u = Math.random();
  } while(u > 1 - 0.331 * Math.pow(x, 4) &&
          Math.log(u) > 0.5 * x*x + a1 * (1 - v + Math.log(v)));
  // alpha > 1
  if (shape == oalph)
    return a1 * v;
  // alpha < 1
  do {
    u = Math.random();
  } while(u === 0);
  return Math.pow(u, 1 / oalph) * a1 * v;
};


// making use of static methods on the instance
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(
          jStat.map(this, function(value) { return jStat[passfunc](value); }));
    }
  })(funcs[i]);
})('gammaln gammafn factorial factorialln'.split(' '));


(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function() {
      return jStat(jStat[passfunc].apply(null, arguments));
    };
  })(funcs[i]);
})('randn'.split(' '));

}(this.jStat, Math));
(function(jStat, Math) {

// generate all distribution instance methods
(function(list) {
  for (var i = 0; i < list.length; i++) (function(func) {
    // distribution instance method
    jStat[func] = function(a, b, c) {
      if (!(this instanceof arguments.callee))
        return new arguments.callee(a, b, c);
      this._a = a;
      this._b = b;
      this._c = c;
      return this;
    };
    // distribution method to be used on a jStat instance
    jStat.fn[func] = function(a, b, c) {
      var newthis = jStat[func](a, b, c);
      newthis.data = this;
      return newthis;
    };
    // sample instance method
    jStat[func].prototype.sample = function(arr) {
      var a = this._a;
      var b = this._b;
      var c = this._c;
      if (arr)
        return jStat.alter(arr, function() {
          return jStat[func].sample(a, b, c);
        });
      else
        return jStat[func].sample(a, b, c);
    };
    // generate the pdf, cdf and inv instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function(x) {
          var a = this._a;
          var b = this._b;
          var c = this._c;
          if (!x && x !== 0)
            x = this.data;
          if (typeof x !== 'number') {
            return jStat.fn.map.call(x, function(x) {
              return jStat[func][fnfunc](x, a, b, c);
            });
          }
          return jStat[func][fnfunc](x, a, b, c);
        };
      })(vals[i]);
    })('pdf cdf inv'.split(' '));
    // generate the mean, median, mode and variance instance methods
    (function(vals) {
      for (var i = 0; i < vals.length; i++) (function(fnfunc) {
        jStat[func].prototype[fnfunc] = function() {
          return jStat[func][fnfunc](this._a, this._b, this._c);
        };
      })(vals[i]);
    })('mean median mode variance'.split(' '));
  })(list[i]);
})((
  'beta centralF cauchy chisquare exponential gamma invgamma kumaraswamy ' +
  'lognormal noncentralt normal pareto studentt weibull uniform  binomial ' +
  'negbin hypgeom poisson triangular'
).split(' '));



// extend beta function with static methods
jStat.extend(jStat.beta, {
  pdf: function pdf(x, alpha, beta) {
    // PDF is zero outside the support
    if (x > 1 || x < 0)
      return 0;
    // PDF is one for the uniform case
    if (alpha == 1 && beta == 1)
      return 1;

    if (alpha < 512 || beta < 512) {
      return (Math.pow(x, alpha - 1) * Math.pow(1 - x, beta - 1)) /
          jStat.betafn(alpha, beta);
    } else {
      return Math.exp((alpha - 1) * Math.log(x) +
                      (beta - 1) * Math.log(1 - x) -
                      jStat.betaln(alpha, beta));
    }
  },

  cdf: function cdf(x, alpha, beta) {
    return (x > 1 || x < 0) ? (x > 1) * 1 : jStat.ibeta(x, alpha, beta);
  },

  inv: function inv(x, alpha, beta) {
    return jStat.ibetainv(x, alpha, beta);
  },

  mean: function mean(alpha, beta) {
    return alpha / (alpha + beta);
  },

  median: function median(alpha, beta) {
    return jStat.ibetainv(0.5, alpha, beta);
  },

  mode: function mode(alpha, beta) {
    return (alpha - 1 ) / ( alpha + beta - 2);
  },

  // return a random sample
  sample: function sample(alpha, beta) {
    var u = jStat.randg(alpha);
    return u / (u + jStat.randg(beta));
  },

  variance: function variance(alpha, beta) {
    return (alpha * beta) / (Math.pow(alpha + beta, 2) * (alpha + beta + 1));
  }
});

// extend F function with static methods
jStat.extend(jStat.centralF, {
  // This implementation of the pdf function avoids float overflow
  // See the way that R calculates this value:
  // https://svn.r-project.org/R/trunk/src/nmath/df.c
  pdf: function pdf(x, df1, df2) {
    var p, q, f;

    if (x < 0)
      return 0;

    if (df1 <= 2) {
      if (x === 0 && df1 < 2) {
        return Infinity;
      }
      if (x === 0 && df1 === 2) {
        return 1;
      }
      return Math.sqrt((Math.pow(df1 * x, df1) * Math.pow(df2, df2)) /
                       (Math.pow(df1 * x + df2, df1 + df2))) /
                       (x * jStat.betafn(df1/2, df2/2));
    }

    p = (df1 * x) / (df2 + x * df1);
    q = df2 / (df2 + x * df1);
    f = df1 * q / 2.0;
    return f * jStat.binomial.pdf((df1 - 2) / 2, (df1 + df2 - 2) / 2, p);
  },

  cdf: function cdf(x, df1, df2) {
    if (x < 0)
      return 0;
    return jStat.ibeta((df1 * x) / (df1 * x + df2), df1 / 2, df2 / 2);
  },

  inv: function inv(x, df1, df2) {
    return df2 / (df1 * (1 / jStat.ibetainv(x, df1 / 2, df2 / 2) - 1));
  },

  mean: function mean(df1, df2) {
    return (df2 > 2) ? df2 / (df2 - 2) : undefined;
  },

  mode: function mode(df1, df2) {
    return (df1 > 2) ? (df2 * (df1 - 2)) / (df1 * (df2 + 2)) : undefined;
  },

  // return a random sample
  sample: function sample(df1, df2) {
    var x1 = jStat.randg(df1 / 2) * 2;
    var x2 = jStat.randg(df2 / 2) * 2;
    return (x1 / df1) / (x2 / df2);
  },

  variance: function variance(df1, df2) {
    if (df2 <= 4)
      return undefined;
    return 2 * df2 * df2 * (df1 + df2 - 2) /
        (df1 * (df2 - 2) * (df2 - 2) * (df2 - 4));
  }
});


// extend cauchy function with static methods
jStat.extend(jStat.cauchy, {
  pdf: function pdf(x, local, scale) {
    return (scale / (Math.pow(x - local, 2) + Math.pow(scale, 2))) / Math.PI;
  },

  cdf: function cdf(x, local, scale) {
    return Math.atan((x - local) / scale) / Math.PI + 0.5;
  },

  inv: function(p, local, scale) {
    return local + scale * Math.tan(Math.PI * (p - 0.5));
  },

  median: function median(local, scale) {
    return local;
  },

  mode: function mode(local, scale) {
    return local;
  },

  sample: function sample(local, scale) {
    return jStat.randn() *
        Math.sqrt(1 / (2 * jStat.randg(0.5))) * scale + local;
  }
});



// extend chisquare function with static methods
jStat.extend(jStat.chisquare, {
  pdf: function pdf(x, dof) {
    if (x < 0)
      return 0;
    return (x === 0 && dof === 2) ? 0.5 :
        Math.exp((dof / 2 - 1) * Math.log(x) - x / 2 - (dof / 2) *
                 Math.log(2) - jStat.gammaln(dof / 2));
  },

  cdf: function cdf(x, dof) {
    if (x < 0)
      return 0;
    return jStat.lowRegGamma(dof / 2, x / 2);
  },

  inv: function(p, dof) {
    return 2 * jStat.gammapinv(p, 0.5 * dof);
  },

  mean : function(dof) {
    return dof;
  },

  // TODO: this is an approximation (is there a better way?)
  median: function median(dof) {
    return dof * Math.pow(1 - (2 / (9 * dof)), 3);
  },

  mode: function mode(dof) {
    return (dof - 2 > 0) ? dof - 2 : 0;
  },

  sample: function sample(dof) {
    return jStat.randg(dof / 2) * 2;
  },

  variance: function variance(dof) {
    return 2 * dof;
  }
});



// extend exponential function with static methods
jStat.extend(jStat.exponential, {
  pdf: function pdf(x, rate) {
    return x < 0 ? 0 : rate * Math.exp(-rate * x);
  },

  cdf: function cdf(x, rate) {
    return x < 0 ? 0 : 1 - Math.exp(-rate * x);
  },

  inv: function(p, rate) {
    return -Math.log(1 - p) / rate;
  },

  mean : function(rate) {
    return 1 / rate;
  },

  median: function (rate) {
    return (1 / rate) * Math.log(2);
  },

  mode: function mode(rate) {
    return 0;
  },

  sample: function sample(rate) {
    return -1 / rate * Math.log(Math.random());
  },

  variance : function(rate) {
    return Math.pow(rate, -2);
  }
});



// extend gamma function with static methods
jStat.extend(jStat.gamma, {
  pdf: function pdf(x, shape, scale) {
    if (x < 0)
      return 0;
    return (x === 0 && shape === 1) ? 1 / scale :
            Math.exp((shape - 1) * Math.log(x) - x / scale -
                    jStat.gammaln(shape) - shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    if (x < 0)
      return 0;
    return jStat.lowRegGamma(shape, x / scale);
  },

  inv: function(p, shape, scale) {
    return jStat.gammapinv(p, shape) * scale;
  },

  mean : function(shape, scale) {
    return shape * scale;
  },

  mode: function mode(shape, scale) {
    if(shape > 1) return (shape - 1) * scale;
    return undefined;
  },

  sample: function sample(shape, scale) {
    return jStat.randg(shape) * scale;
  },

  variance: function variance(shape, scale) {
    return shape * scale * scale;
  }
});

// extend inverse gamma function with static methods
jStat.extend(jStat.invgamma, {
  pdf: function pdf(x, shape, scale) {
    if (x <= 0)
      return 0;
    return Math.exp(-(shape + 1) * Math.log(x) - scale / x -
                    jStat.gammaln(shape) + shape * Math.log(scale));
  },

  cdf: function cdf(x, shape, scale) {
    if (x <= 0)
      return 0;
    return 1 - jStat.lowRegGamma(shape, scale / x);
  },

  inv: function(p, shape, scale) {
    return scale / jStat.gammapinv(1 - p, shape);
  },

  mean : function(shape, scale) {
    return (shape > 1) ? scale / (shape - 1) : undefined;
  },

  mode: function mode(shape, scale) {
    return scale / (shape + 1);
  },

  sample: function sample(shape, scale) {
    return scale / jStat.randg(shape);
  },

  variance: function variance(shape, scale) {
    if (shape <= 2)
      return undefined;
    return scale * scale / ((shape - 1) * (shape - 1) * (shape - 2));
  }
});


// extend kumaraswamy function with static methods
jStat.extend(jStat.kumaraswamy, {
  pdf: function pdf(x, alpha, beta) {
    if (x === 0 && alpha === 1)
      return beta;
    else if (x === 1 && beta === 1)
      return alpha;
    return Math.exp(Math.log(alpha) + Math.log(beta) + (alpha - 1) *
                    Math.log(x) + (beta - 1) *
                    Math.log(1 - Math.pow(x, alpha)));
  },

  cdf: function cdf(x, alpha, beta) {
    if (x < 0)
      return 0;
    else if (x > 1)
      return 1;
    return (1 - Math.pow(1 - Math.pow(x, alpha), beta));
  },

  inv: function inv(p, alpha, beta) {
    return Math.pow(1 - Math.pow(1 - p, 1 / beta), 1 / alpha);
  },

  mean : function(alpha, beta) {
    return (beta * jStat.gammafn(1 + 1 / alpha) *
            jStat.gammafn(beta)) / (jStat.gammafn(1 + 1 / alpha + beta));
  },

  median: function median(alpha, beta) {
    return Math.pow(1 - Math.pow(2, -1 / beta), 1 / alpha);
  },

  mode: function mode(alpha, beta) {
    if (!(alpha >= 1 && beta >= 1 && (alpha !== 1 && beta !== 1)))
      return undefined;
    return Math.pow((alpha - 1) / (alpha * beta - 1), 1 / alpha);
  },

  variance: function variance(alpha, beta) {
    throw new Error('variance not yet implemented');
    // TODO: complete this
  }
});



// extend lognormal function with static methods
jStat.extend(jStat.lognormal, {
  pdf: function pdf(x, mu, sigma) {
    if (x <= 0)
      return 0;
    return Math.exp(-Math.log(x) - 0.5 * Math.log(2 * Math.PI) -
                    Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) /
                    (2 * sigma * sigma));
  },

  cdf: function cdf(x, mu, sigma) {
    if (x < 0)
      return 0;
    return 0.5 +
        (0.5 * jStat.erf((Math.log(x) - mu) / Math.sqrt(2 * sigma * sigma)));
  },

  inv: function(p, mu, sigma) {
    return Math.exp(-1.41421356237309505 * sigma * jStat.erfcinv(2 * p) + mu);
  },

  mean: function mean(mu, sigma) {
    return Math.exp(mu + sigma * sigma / 2);
  },

  median: function median(mu, sigma) {
    return Math.exp(mu);
  },

  mode: function mode(mu, sigma) {
    return Math.exp(mu - sigma * sigma);
  },

  sample: function sample(mu, sigma) {
    return Math.exp(jStat.randn() * sigma + mu);
  },

  variance: function variance(mu, sigma) {
    return (Math.exp(sigma * sigma) - 1) * Math.exp(2 * mu + sigma * sigma);
  }
});



// extend noncentralt function with static methods
jStat.extend(jStat.noncentralt, {
  pdf: function pdf(x, dof, ncp) {
    var tol = 1e-14;
    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t
      return jStat.studentt.pdf(x, dof)

    if (Math.abs(x) < tol) {  // different formula for x == 0
      return Math.exp(jStat.gammaln((dof + 1) / 2) - ncp * ncp / 2 -
                      0.5 * Math.log(Math.PI * dof) - jStat.gammaln(dof / 2));
    }

    // formula for x != 0
    return dof / x *
        (jStat.noncentralt.cdf(x * Math.sqrt(1 + 2 / dof), dof+2, ncp) -
         jStat.noncentralt.cdf(x, dof, ncp));
  },

  cdf: function cdf(x, dof, ncp) {
    var tol = 1e-14;
    var min_iterations = 200;

    if (Math.abs(ncp) < tol)  // ncp approx 0; use student-t
      return jStat.studentt.cdf(x, dof);

    // turn negative x into positive and flip result afterwards
    var flip = false;
    if (x < 0) {
      flip = true;
      ncp = -ncp;
    }

    var prob = jStat.normal.cdf(-ncp, 0, 1);
    var value = tol + 1;
    // use value at last two steps to determine convergence
    var lastvalue = value;
    var y = x * x / (x * x + dof);
    var j = 0;
    var p = Math.exp(-ncp * ncp / 2);
    var q = Math.exp(-ncp * ncp / 2 - 0.5 * Math.log(2) -
                     jStat.gammaln(3 / 2)) * ncp;
    while (j < min_iterations || lastvalue > tol || value > tol) {
      lastvalue = value;
      if (j > 0) {
        p *= (ncp * ncp) / (2 * j);
        q *= (ncp * ncp) / (2 * (j + 1 / 2));
      }
      value = p * jStat.beta.cdf(y, j + 0.5, dof / 2) +
          q * jStat.beta.cdf(y, j+1, dof/2);
      prob += 0.5 * value;
      j++;
    }

    return flip ? (1 - prob) : prob;
  }
});


// extend normal function with static methods
jStat.extend(jStat.normal, {
  pdf: function pdf(x, mean, std) {
    return Math.exp(-0.5 * Math.log(2 * Math.PI) -
                    Math.log(std) - Math.pow(x - mean, 2) / (2 * std * std));
  },

  cdf: function cdf(x, mean, std) {
    return 0.5 * (1 + jStat.erf((x - mean) / Math.sqrt(2 * std * std)));
  },

  inv: function(p, mean, std) {
    return -1.41421356237309505 * std * jStat.erfcinv(2 * p) + mean;
  },

  mean : function(mean, std) {
    return mean;
  },

  median: function median(mean, std) {
    return mean;
  },

  mode: function (mean, std) {
    return mean;
  },

  sample: function sample(mean, std) {
    return jStat.randn() * std + mean;
  },

  variance : function(mean, std) {
    return std * std;
  }
});



// extend pareto function with static methods
jStat.extend(jStat.pareto, {
  pdf: function pdf(x, scale, shape) {
    if (x < scale)
      return 0;
    return (shape * Math.pow(scale, shape)) / Math.pow(x, shape + 1);
  },

  cdf: function cdf(x, scale, shape) {
    if (x < scale)
      return 0;
    return 1 - Math.pow(scale / x, shape);
  },

  inv: function inv(p, scale, shape) {
    return scale / Math.pow(1 - p, 1 / shape);
  },

  mean: function mean(scale, shape) {
    if (shape <= 1)
      return undefined;
    return (shape * Math.pow(scale, shape)) / (shape - 1);
  },

  median: function median(scale, shape) {
    return scale * (shape * Math.SQRT2);
  },

  mode: function mode(scale, shape) {
    return scale;
  },

  variance : function(scale, shape) {
    if (shape <= 2)
      return undefined;
    return (scale*scale * shape) / (Math.pow(shape - 1, 2) * (shape - 2));
  }
});



// extend studentt function with static methods
jStat.extend(jStat.studentt, {
  pdf: function pdf(x, dof) {
    dof = dof > 1e100 ? 1e100 : dof;
    return (1/(Math.sqrt(dof) * jStat.betafn(0.5, dof/2))) *
        Math.pow(1 + ((x * x) / dof), -((dof + 1) / 2));
  },

  cdf: function cdf(x, dof) {
    var dof2 = dof / 2;
    return jStat.ibeta((x + Math.sqrt(x * x + dof)) /
                       (2 * Math.sqrt(x * x + dof)), dof2, dof2);
  },

  inv: function(p, dof) {
    var x = jStat.ibetainv(2 * Math.min(p, 1 - p), 0.5 * dof, 0.5);
    x = Math.sqrt(dof * (1 - x) / x);
    return (p > 0.5) ? x : -x;
  },

  mean: function mean(dof) {
    return (dof > 1) ? 0 : undefined;
  },

  median: function median(dof) {
    return 0;
  },

  mode: function mode(dof) {
    return 0;
  },

  sample: function sample(dof) {
    return jStat.randn() * Math.sqrt(dof / (2 * jStat.randg(dof / 2)));
  },

  variance: function variance(dof) {
    return (dof  > 2) ? dof / (dof - 2) : (dof > 1) ? Infinity : undefined;
  }
});



// extend weibull function with static methods
jStat.extend(jStat.weibull, {
  pdf: function pdf(x, scale, shape) {
    if (x < 0)
      return 0;
    return (shape / scale) * Math.pow((x / scale), (shape - 1)) *
        Math.exp(-(Math.pow((x / scale), shape)));
  },

  cdf: function cdf(x, scale, shape) {
    return x < 0 ? 0 : 1 - Math.exp(-Math.pow((x / scale), shape));
  },

  inv: function(p, scale, shape) {
    return scale * Math.pow(-Math.log(1 - p), 1 / shape);
  },

  mean : function(scale, shape) {
    return scale * jStat.gammafn(1 + 1 / shape);
  },

  median: function median(scale, shape) {
    return scale * Math.pow(Math.log(2), 1 / shape);
  },

  mode: function mode(scale, shape) {
    if (shape <= 1)
      return undefined;
    return scale * Math.pow((shape - 1) / shape, 1 / shape);
  },

  sample: function sample(scale, shape) {
    return scale * Math.pow(-Math.log(Math.random()), 1 / shape);
  },

  variance: function variance(scale, shape) {
    return scale * scale * jStat.gammafn(1 + 2 / shape) -
        Math.pow(this.mean(scale, shape), 2);
  }
});



// extend uniform function with static methods
jStat.extend(jStat.uniform, {
  pdf: function pdf(x, a, b) {
    return (x < a || x > b) ? 0 : 1 / (b - a);
  },

  cdf: function cdf(x, a, b) {
    if (x < a)
      return 0;
    else if (x < b)
      return (x - a) / (b - a);
    return 1;
  },

  inv: function(p, a, b) {
    return a + (p * (b - a));
  },

  mean: function mean(a, b) {
    return 0.5 * (a + b);
  },

  median: function median(a, b) {
    return jStat.mean(a, b);
  },

  mode: function mode(a, b) {
    throw new Error('mode is not yet implemented');
  },

  sample: function sample(a, b) {
    return (a / 2 + b / 2) + (b / 2 - a / 2) * (2 * Math.random() - 1);
  },

  variance: function variance(a, b) {
    return Math.pow(b - a, 2) / 12;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.binomial, {
  pdf: function pdf(k, n, p) {
    return (p === 0 || p === 1) ?
      ((n * p) === k ? 1 : 0) :
      jStat.combination(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
  },

  cdf: function cdf(x, n, p) {
    var binomarr = [],
    k = 0;
    if (x < 0) {
      return 0;
    }
    if (x < n) {
      for (; k <= x; k++) {
        binomarr[ k ] = jStat.binomial.pdf(k, n, p);
      }
      return jStat.sum(binomarr);
    }
    return 1;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.negbin, {
  pdf: function pdf(k, r, p) {
    return k !== k | 0
      ? false
      : k < 0
        ? 0
        : jStat.combination(k + r - 1, r - 1) * Math.pow(1 - p, k) * Math.pow(p, r);
  },

  cdf: function cdf(x, r, p) {
    var sum = 0,
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sum += jStat.negbin.pdf(k, r, p);
    }
    return sum;
  }
});



// extend uniform function with static methods
jStat.extend(jStat.hypgeom, {
  pdf: function pdf(k, N, m, n) {
    // Hypergeometric PDF.

    // A simplification of the CDF algorithm below.

    // k = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(k !== k | 0) {
      return false;
    } else if(k < 0 || k < m - (N - n)) {
      // It's impossible to have this few successes drawn.
      return 0;
    } else if(k > n || k > m) {
      // It's impossible to have this many successes drawn.
      return 0;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.pdf(N - m - n + k, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return jStat.hypgeom.pdf(n - k, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return jStat.hypgeom.pdf(m - k, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.pdf(k, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate product to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < k; i++) {
        // For every possible number of successes up to that observed...

        while(scaledPDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          scaledPDF *= 1 - (m / (N - samplesDone));

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledPDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledPDF));
    }
  },

  cdf: function cdf(x, N, m, n) {
    // Hypergeometric CDF.

    // This algorithm is due to Prof. Thomas S. Ferguson, <tom@math.ucla.edu>,
    // and comes from his hypergeometric test calculator at
    // <http://www.math.ucla.edu/~tom/distributions/Hypergeometric.html>.

    // x = number of successes drawn
    // N = population size
    // m = number of successes in population
    // n = number of items drawn from population

    if(x < 0 || x < m - (N - n)) {
      // It's impossible to have this few successes drawn or fewer.
      return 0;
    } else if(x >= n || x >= m) {
      // We will always have this many successes or fewer.
      return 1;
    } else if (m * 2 > N) {
      // More than half the population is successes.

      if(n * 2 > N) {
        // More than half the population is sampled.

        return jStat.hypgeom.cdf(N - m - n + x, N, N - m, N - n)
      } else {
        // Half or less of the population is sampled.

        return 1 - jStat.hypgeom.cdf(n - x - 1, N, N - m, n);
      }

    } else if(n * 2 > N) {
      // Half or less is successes.

      return 1 - jStat.hypgeom.cdf(m - x - 1, N, m, N - n);

    } else if(m < n) {
      // We want to have the number of things sampled to be less than the
      // successes available. So swap the definitions of successful and sampled.
      return jStat.hypgeom.cdf(x, N, n, m);
    } else {
      // If we get here, half or less of the population was sampled, half or
      // less of it was successes, and we had fewer sampled things than
      // successes. Now we can do this complicated iterative algorithm in an
      // efficient way.

      // The basic premise of the algorithm is that we partially normalize our
      // intermediate sum to keep it in a numerically good region, and then
      // finish the normalization at the end.

      // Holds the intermediate, scaled total CDF.
      var scaledCDF = 1;

      // This variable holds the scaled probability of the current number of
      // successes.
      var scaledPDF = 1;

      // This keeps track of how much we have normalized.
      var samplesDone = 0;

      for(var i = 0; i < x; i++) {
        // For every possible number of successes up to that observed...

        while(scaledCDF > 1 && samplesDone < n) {
          // Intermediate result is growing too big. Apply some of the
          // normalization to shrink everything.

          var factor = 1 - (m / (N - samplesDone));

          scaledPDF *= factor;
          scaledCDF *= factor;

          // Say we've normalized by this sample already.
          samplesDone++;
        }

        // Work out the partially-normalized hypergeometric PDF for the next
        // number of successes
        scaledPDF *= (n - i) * (m - i) / ((i + 1) * (N - m - n + i + 1));

        // Add to the CDF answer.
        scaledCDF += scaledPDF;
      }

      for(; samplesDone < n; samplesDone++) {
        // Apply all the rest of the normalization
        scaledCDF *= 1 - (m / (N - samplesDone));
      }

      // Bound answer sanely before returning.
      return Math.min(1, Math.max(0, scaledCDF));
    }
  }
});



// extend uniform function with static methods
jStat.extend(jStat.poisson, {
  pdf: function pdf(k, l) {
    return Math.pow(l, k) * Math.exp(-l) / jStat.factorial(k);
  },

  cdf: function cdf(x, l) {
    var sumarr = [],
    k = 0;
    if (x < 0) return 0;
    for (; k <= x; k++) {
      sumarr.push(jStat.poisson.pdf(k, l));
    }
    return jStat.sum(sumarr);
  },

  mean : function(l) {
    return l;
  },

  variance : function(l) {
    return l;
  },

  sample: function sample(l) {
    var p = 1, k = 0, L = Math.exp(-l);
    do {
      k++;
      p *= Math.random();
    } while (p > L);
    return k - 1;
  }
});

// extend triangular function with static methods
jStat.extend(jStat.triangular, {
  pdf: function pdf(x, a, b, c) {
    if (b <= a || c < a || c > b) {
      return NaN;
    } else {
      if (x < a || x > b) {
        return 0;
      } else if (x < c) {
          return (2 * (x - a)) / ((b - a) * (c - a));
      } else if (x === c) {
          return (2 / (b - a));
      } else { // x > c
          return (2 * (b - x)) / ((b - a) * (b - c));
      }
    }
  },

  cdf: function cdf(x, a, b, c) {
    if (b <= a || c < a || c > b)
      return NaN;
    if (x <= a)
      return 0;
    else if (x >= b)
      return 1;
    if (x <= c)
      return Math.pow(x - a, 2) / ((b - a) * (c - a));
    else // x > c
      return 1 - Math.pow(b - x, 2) / ((b - a) * (b - c));
  },

  inv: function inv(p, a, b, c) {
    if (b <= a || c < a || c > b) {
      return NaN;
    } else {
      if (p <= ((c - a) / (b - a))) {
        return a + (b - a) * Math.sqrt(p * ((c - a) / (b - a)));
      } else { // p > ((c - a) / (b - a))
        return a + (b - a) * (1 - Math.sqrt((1 - p) * (1 - ((c - a) / (b - a)))));
      }
    }
  },

  mean: function mean(a, b, c) {
    return (a + b + c) / 3;
  },

  median: function median(a, b, c) {
    if (c <= (a + b) / 2) {
      return b - Math.sqrt((b - a) * (b - c)) / Math.sqrt(2);
    } else if (c > (a + b) / 2) {
      return a + Math.sqrt((b - a) * (c - a)) / Math.sqrt(2);
    }
  },

  mode: function mode(a, b, c) {
    return c;
  },

  sample: function sample(a, b, c) {
    var u = Math.random();
    if (u < ((c - a) / (b - a)))
      return a + Math.sqrt(u * (b - a) * (c - a))
    return b - Math.sqrt((1 - u) * (b - a) * (b - c));
  },

  variance: function variance(a, b, c) {
    return (a * a + b * b + c * c - a * b - a * c - b * c) / 18;
  }
});

}(this.jStat, Math));
/* Provides functions for the solution of linear system of equations, integration, extrapolation,
 * interpolation, eigenvalue problems, differential equations and PCA analysis. */

(function(jStat, Math) {

var push = Array.prototype.push;
var isArray = jStat.utils.isArray;

jStat.extend({

  // add a vector/matrix to a vector/matrix or scalar
  add: function add(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value + arg[row][col];
      });
    }
    return jStat.map(arr, function(value) { return value + arg; });
  },

  // subtract a vector or scalar from the vector
  subtract: function subtract(arr, arg) {
    // check if arg is a vector or scalar
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.map(arr, function(value, row, col) {
        return value - arg[row][col] || 0;
      });
    }
    return jStat.map(arr, function(value) { return value - arg; });
  },

  // matrix division
  divide: function divide(arr, arg) {
    if (isArray(arg)) {
      if (!isArray(arg[0])) arg = [ arg ];
      return jStat.multiply(arr, jStat.inv(arg));
    }
    return jStat.map(arr, function(value) { return value / arg; });
  },

  // matrix multiplication
  multiply: function multiply(arr, arg) {
    var row, col, nrescols, sum,
    nrow = arr.length,
    ncol = arr[0].length,
    res = jStat.zeros(nrow, nrescols = (isArray(arg)) ? arg[0].length : ncol),
    rescols = 0;
    if (isArray(arg)) {
      for (; rescols < nrescols; rescols++) {
        for (row = 0; row < nrow; row++) {
          sum = 0;
          for (col = 0; col < ncol; col++)
          sum += arr[row][col] * arg[col][rescols];
          res[row][rescols] = sum;
        }
      }
      return (nrow === 1 && rescols === 1) ? res[0][0] : res;
    }
    return jStat.map(arr, function(value) { return value * arg; });
  },

  // Returns the dot product of two matricies
  dot: function dot(arr, arg) {
    if (!isArray(arr[0])) arr = [ arr ];
    if (!isArray(arg[0])) arg = [ arg ];
    // convert column to row vector
    var left = (arr[0].length === 1 && arr.length !== 1) ? jStat.transpose(arr) : arr,
    right = (arg[0].length === 1 && arg.length !== 1) ? jStat.transpose(arg) : arg,
    res = [],
    row = 0,
    nrow = left.length,
    ncol = left[0].length,
    sum, col;
    for (; row < nrow; row++) {
      res[row] = [];
      sum = 0;
      for (col = 0; col < ncol; col++)
      sum += left[row][col] * right[row][col];
      res[row] = sum;
    }
    return (res.length === 1) ? res[0] : res;
  },

  // raise every element by a scalar
  pow: function pow(arr, arg) {
    return jStat.map(arr, function(value) { return Math.pow(value, arg); });
  },

  // exponentiate every element
  exp: function exp(arr) {
    return jStat.map(arr, function(value) { return Math.exp(value); });
  },

  // generate the natural log of every element
  log: function exp(arr) {
    return jStat.map(arr, function(value) { return Math.log(value); });
  },

  // generate the absolute values of the vector
  abs: function abs(arr) {
    return jStat.map(arr, function(value) { return Math.abs(value); });
  },

  // computes the p-norm of the vector
  // In the case that a matrix is passed, uses the first row as the vector
  norm: function norm(arr, p) {
    var nnorm = 0,
    i = 0;
    // check the p-value of the norm, and set for most common case
    if (isNaN(p)) p = 2;
    // check if multi-dimensional array, and make vector correction
    if (isArray(arr[0])) arr = arr[0];
    // vector norm
    for (; i < arr.length; i++) {
      nnorm += Math.pow(Math.abs(arr[i]), p);
    }
    return Math.pow(nnorm, 1 / p);
  },

  // computes the angle between two vectors in rads
  // In case a matrix is passed, this uses the first row as the vector
  angle: function angle(arr, arg) {
    return Math.acos(jStat.dot(arr, arg) / (jStat.norm(arr) * jStat.norm(arg)));
  },

  // augment one matrix by another
  // Note: this function returns a matrix, not a jStat object
  aug: function aug(a, b) {
    var newarr = a.slice(),
    i = 0;
    for (; i < newarr.length; i++) {
      push.apply(newarr[i], b[i]);
    }
    return newarr;
  },

  // The inv() function calculates the inverse of a matrix
  // Create the inverse by augmenting the matrix by the identity matrix of the
  // appropriate size, and then use G-J elimination on the augmented matrix.
  inv: function inv(a) {
    var rows = a.length;
    var cols = a[0].length;
    var b = jStat.identity(rows, cols);
    var c = jStat.gauss_jordan(a, b);
    var result = [];
    var i = 0;
    var j;

    //We need to copy the inverse portion to a new matrix to rid G-J artifacts
    for (; i < rows; i++) {
      result[i] = [];
      for (j = cols; j < c[0].length; j++)
        result[i][j - cols] = c[i][j];
    }
    return result;
  },

  // calculate the determinant of a matrix
  det: function det(a) {
    var alen = a.length,
    alend = alen * 2,
    vals = new Array(alend),
    rowshift = alen - 1,
    colshift = alend - 1,
    mrow = rowshift - alen + 1,
    mcol = colshift,
    i = 0,
    result = 0,
    j;
    // check for special 2x2 case
    if (alen === 2) {
      return a[0][0] * a[1][1] - a[0][1] * a[1][0];
    }
    for (; i < alend; i++) {
      vals[i] = 1;
    }
    for (i = 0; i < alen; i++) {
      for (j = 0; j < alen; j++) {
        vals[(mrow < 0) ? mrow + alen : mrow ] *= a[i][j];
        vals[(mcol < alen) ? mcol + alen : mcol ] *= a[i][j];
        mrow++;
        mcol--;
      }
      mrow = --rowshift - alen + 1;
      mcol = --colshift;
    }
    for (i = 0; i < alen; i++) {
      result += vals[i];
    }
    for (; i < alend; i++) {
      result -= vals[i];
    }
    return result;
  },

  gauss_elimination: function gauss_elimination(a, b) {
    var i = 0,
    j = 0,
    n = a.length,
    m = a[0].length,
    factor = 1,
    sum = 0,
    x = [],
    maug, pivot, temp, k;
    a = jStat.aug(a, b);
    maug = a[0].length;
    for(i = 0; i < n; i++) {
      pivot = a[i][i];
      j = i;
      for (k = i + 1; k < m; k++) {
        if (pivot < Math.abs(a[k][i])) {
          pivot = a[k][i];
          j = k;
        }
      }
      if (j != i) {
        for(k = 0; k < maug; k++) {
          temp = a[i][k];
          a[i][k] = a[j][k];
          a[j][k] = temp;
        }
      }
      for (j = i + 1; j < n; j++) {
        factor = a[j][i] / a[i][i];
        for(k = i; k < maug; k++) {
          a[j][k] = a[j][k] - factor * a[i][k];
        }
      }
    }
    for (i = n - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j<= n - 1; j++) {
        sum = sum + x[j] * a[i][j];
      }
      x[i] =(a[i][maug - 1] - sum) / a[i][i];
    }
    return x;
  },

  gauss_jordan: function gauss_jordan(a, b) {
    var m = jStat.aug(a, b),
    h = m.length,
    w = m[0].length;
    // find max pivot
    for (var y = 0; y < h; y++) {
      var maxrow = y;
      for (var y2 = y+1; y2 < h; y2++) {
        if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
          maxrow = y2;
      }
      var tmp = m[y];
      m[y] = m[maxrow];
      m[maxrow] = tmp
      for (var y2 = y+1; y2 < h; y2++) {
        c = m[y2][y] / m[y][y];
        for (var x = y; x < w; x++) {
          m[y2][x] -= m[y][x] * c;
        }
      }
    }
    // backsubstitute
    for (var y = h-1; y >= 0; y--) {
      c = m[y][y];
      for (var y2 = 0; y2 < y; y2++) {
        for (var x = w-1; x > y-1; x--) {
          m[y2][x] -= m[y][x] * m[y2][y] / c;
        }
      }
      m[y][y] /= c;
      for (var x = h; x < w; x++) {
        m[y][x] /= c;
      }
    }
    return m;
  },

  lu: function lu(a, b) {
    throw new Error('lu not yet implemented');
  },

  cholesky: function cholesky(a, b) {
    throw new Error('cholesky not yet implemented');
  },

  gauss_jacobi: function gauss_jacobi(a, b, x, r) {
    var i = 0;
    var j = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(d), jStat.add(l, u)), -1);
    c = jStat.multiply(jStat.inv(d), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk,xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  gauss_seidel: function gauss_seidel(a, b, x, r) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d, l)), u), -1);
    c = jStat.multiply(jStat.inv(jStat.add(d, l)), b);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i = i + 1;
    }
    return xk;
  },

  SOR: function SOR(a, b, x, r, w) {
    var i = 0;
    var n = a.length;
    var l = [];
    var u = [];
    var d = [];
    var j, xv, c, h, xk;
    for (; i < n; i++) {
      l[i] = [];
      u[i] = [];
      d[i] = [];
      for (j = 0; j < n; j++) {
        if (i > j) {
          l[i][j] = a[i][j];
          u[i][j] = d[i][j] = 0;
        } else if (i < j) {
          u[i][j] = a[i][j];
          l[i][j] = d[i][j] = 0;
        } else {
          d[i][j] = a[i][j];
          l[i][j] = u[i][j] = 0;
        }
      }
    }
    h = jStat.multiply(jStat.inv(jStat.add(d, jStat.multiply(l, w))),
                       jStat.subtract(jStat.multiply(d, 1 - w),
                                      jStat.multiply(u, w)));
    c = jStat.multiply(jStat.multiply(jStat.inv(jStat.add(d,
        jStat.multiply(l, w))), b), w);
    xv = x;
    xk = jStat.add(jStat.multiply(h, x), c);
    i = 2;
    while (Math.abs(jStat.norm(jStat.subtract(xk, xv))) > r) {
      xv = xk;
      xk = jStat.add(jStat.multiply(h, xv), c);
      i++;
    }
    return xk;
  },

  householder: function householder(a) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var alpha, r, k, j, factor;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
      alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++) w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, jStat.multiply(a, p));
    }
    return a;
  },

  // TODO: not working properly.
  QR: function QR(a, b) {
    var m = a.length;
    var n = a[0].length;
    var i = 0;
    var w = [];
    var p = [];
    var x = [];
    var j, alpha, r, k, factor, sum;
    for (; i < m - 1; i++) {
      alpha = 0;
      for (j = i + 1; j < n; j++)
        alpha += (a[j][i] * a[j][i]);
      factor = (a[i + 1][i] > 0) ? -1 : 1;
      alpha = factor * Math.sqrt(alpha);
      r = Math.sqrt((((alpha * alpha) - a[i + 1][i] * alpha) / 2));
      w = jStat.zeros(m, 1);
      w[i + 1][0] = (a[i + 1][i] - alpha) / (2 * r);
      for (k = i + 2; k < m; k++)
        w[k][0] = a[k][i] / (2 * r);
      p = jStat.subtract(jStat.identity(m, n),
          jStat.multiply(jStat.multiply(w, jStat.transpose(w)), 2));
      a = jStat.multiply(p, a);
      b = jStat.multiply(p, b);
    }
    for (i = m - 1; i >= 0; i--) {
      sum = 0;
      for (j = i + 1; j <= n - 1; j++)
      sum = x[j] * a[i][j];
      x[i] = b[i][0] / a[i][i];
    }
    return x;
  },

  jacobi: function jacobi(a) {
    var condition = 1;
    var count = 0;
    var n = a.length;
    var e = jStat.identity(n, n);
    var ev = [];
    var b, i, j, p, q, maxim, theta, s;
    // condition === 1 only if tolerance is not reached
    while (condition === 1) {
      count++;
      maxim = a[0][1];
      p = 0;
      q = 1;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (i != j) {
            if (maxim < Math.abs(a[i][j])) {
              maxim = Math.abs(a[i][j]);
              p = i;
              q = j;
            }
          }
        }
      }
      if (a[p][p] === a[q][q])
        theta = (a[p][q] > 0) ? Math.PI / 4 : -Math.PI / 4;
      else
        theta = Math.atan(2 * a[p][q] / (a[p][p] - a[q][q])) / 2;
      s = jStat.identity(n, n);
      s[p][p] = Math.cos(theta);
      s[p][q] = -Math.sin(theta);
      s[q][p] = Math.sin(theta);
      s[q][q] = Math.cos(theta);
      // eigen vector matrix
      e = jStat.multiply(e, s);
      b = jStat.multiply(jStat.multiply(jStat.inv(s), a), s);
      a = b;
      condition = 0;
      for (i = 1; i < n; i++) {
        for (j = 1; j < n; j++) {
          if (i != j && Math.abs(a[i][j]) > 0.001) {
            condition = 1;
          }
        }
      }
    }
    for (i = 0; i < n; i++) ev.push(a[i][i]);
    //returns both the eigenvalue and eigenmatrix
    return [e, ev];
  },

  rungekutta: function rungekutta(f, h, p, t_j, u_j, order) {
    var k1, k2, u_j1, k3, k4;
    if (order === 2) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h, u_j + k1);
        u_j1 = u_j + (k1 + k2) / 2;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    if (order === 4) {
      while (t_j <= p) {
        k1 = h * f(t_j, u_j);
        k2 = h * f(t_j + h / 2, u_j + k1 / 2);
        k3 = h * f(t_j + h / 2, u_j + k2 / 2);
        k4 = h * f(t_j +h, u_j + k3);
        u_j1 = u_j + (k1 + 2 * k2 + 2 * k3 + k4) / 6;
        u_j = u_j1;
        t_j = t_j + h;
      }
    }
    return u_j;
  },

  romberg: function romberg(f, a, b, order) {
    var i = 0;
    var h = (b - a) / 2;
    var x = [];
    var h1 = [];
    var g = [];
    var m, a1, j, k, I, d;
    while (i < order / 2) {
      I = f(a);
      for (j = a, k = 0; j <= b; j = j + h, k++) x[k] = j;
      m = x.length;
      for (j = 1; j < m - 1; j++) {
        I += (((j % 2) !== 0) ? 4 : 2) * f(x[j]);
      }
      I = (h / 3) * (I + f(b));
      g[i] = I;
      h /= 2;
      i++;
    }
    a1 = g.length;
    m = 1;
    while (a1 !== 1) {
      for (j = 0; j < a1 - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a1 = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  richardson: function richardson(X, f, x, h) {
    function pos(X, x) {
      var i = 0;
      var n = X.length;
      var p;
      for (; i < n; i++)
        if (X[i] === x) p = i;
      return p;
    }
    var n = X.length,
    h_min = Math.abs(x - X[pos(X, x) + 1]),
    i = 0,
    g = [],
    h1 = [],
    y1, y2, m, a, j;
    while (h >= h_min) {
      y1 = pos(X, x + h);
      y2 = pos(X, x);
      g[i] = (f[y1] - 2 * f[y2] + f[2 * y2 - y1]) / (h * h);
      h /= 2;
      i++;
    }
    a = g.length;
    m = 1;
    while (a != 1) {
      for (j = 0; j < a - 1; j++)
      h1[j] = ((Math.pow(4, m)) * g[j + 1] - g[j]) / (Math.pow(4, m) - 1);
      a = h1.length;
      g = h1;
      h1 = [];
      m++;
    }
    return g;
  },

  simpson: function simpson(f, a, b, n) {
    var h = (b - a) / n;
    var I = f(a);
    var x = [];
    var j = a;
    var k = 0;
    var i = 1;
    var m;
    for (; j <= b; j = j + h, k++)
      x[k] = j;
    m = x.length;
    for (; i < m - 1; i++) {
      I += ((i % 2 !== 0) ? 4 : 2) * f(x[i]);
    }
    return (h / 3) * (I + f(b));
  },

  hermite: function hermite(X, F, dF, value) {
    var n = X.length;
    var p = 0;
    var i = 0;
    var l = [];
    var dl = [];
    var A = [];
    var B = [];
    var j;
    for (; i < n; i++) {
      l[i] = 1;
      for (j = 0; j < n; j++) {
        if (i != j) l[i] *= (value - X[j]) / (X[i] - X[j]);
      }
      dl[i] = 0;
      for (j = 0; j < n; j++) {
        if (i != j) dl[i] += 1 / (X [i] - X[j]);
      }
      A[i] = (1 - 2 * (value - X[i]) * dl[i]) * (l[i] * l[i]);
      B[i] = (value - X[i]) * (l[i] * l[i]);
      p += (A[i] * F[i] + B[i] * dF[i]);
    }
    return p;
  },

  lagrange: function lagrange(X, F, value) {
    var p = 0;
    var i = 0;
    var j, l;
    var n = X.length;
    for (; i < n; i++) {
      l = F[i];
      for (j = 0; j < n; j++) {
        // calculating the lagrange polynomial L_i
        if (i != j) l *= (value - X[j]) / (X[i] - X[j]);
      }
      // adding the lagrange polynomials found above
      p += l;
    }
    return p;
  },

  cubic_spline: function cubic_spline(X, F, value) {
    var n = X.length;
    var i = 0, j;
    var A = [];
    var B = [];
    var alpha = [];
    var c = [];
    var h = [];
    var b = [];
    var d = [];
    for (; i < n - 1; i++)
      h[i] = X[i + 1] - X[i];
    alpha[0] = 0;
    for (i = 1; i < n - 1; i++) {
      alpha[i] = (3 / h[i]) * (F[i + 1] - F[i]) -
          (3 / h[i-1]) * (F[i] - F[i-1]);
    }
    for (i = 1; i < n - 1; i++) {
      A[i] = [];
      B[i] = [];
      A[i][i-1] = h[i-1];
      A[i][i] = 2 * (h[i - 1] + h[i]);
      A[i][i+1] = h[i];
      B[i][0] = alpha[i];
    }
    c = jStat.multiply(jStat.inv(A), B);
    for (j = 0; j < n - 1; j++) {
      b[j] = (F[j + 1] - F[j]) / h[j] - h[j] * (c[j + 1][0] + 2 * c[j][0]) / 3;
      d[j] = (c[j + 1][0] - c[j][0]) / (3 * h[j]);
    }
    for (j = 0; j < n; j++) {
      if (X[j] > value) break;
    }
    j -= 1;
    return F[j] + (value - X[j]) * b[j] + jStat.sq(value-X[j]) *
        c[j] + (value - X[j]) * jStat.sq(value - X[j]) * d[j];
  },

  gauss_quadrature: function gauss_quadrature() {
    throw new Error('gauss_quadrature not yet implemented');
  },

  PCA: function PCA(X) {
    var m = X.length;
    var n = X[0].length;
    var flag = false;
    var i = 0;
    var j, temp1;
    var u = [];
    var D = [];
    var result = [];
    var temp2 = [];
    var Y = [];
    var Bt = [];
    var B = [];
    var C = [];
    var V = [];
    var Vt = [];
    for (i = 0; i < m; i++) {
      u[i] = jStat.sum(X[i]) / n;
    }
    for (i = 0; i < n; i++) {
      B[i] = [];
      for(j = 0; j < m; j++) {
        B[i][j] = X[j][i] - u[j];
      }
    }
    B = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      C[i] = [];
      for (j = 0; j < m; j++) {
        C[i][j] = (jStat.dot([B[i]], [B[j]])) / (n - 1);
      }
    }
    result = jStat.jacobi(C);
    V = result[0];
    D = result[1];
    Vt = jStat.transpose(V);
    for (i = 0; i < D.length; i++) {
      for (j = i; j < D.length; j++) {
        if(D[i] < D[j])  {
          temp1 = D[i];
          D[i] = D[j];
          D[j] = temp1;
          temp2 = Vt[i];
          Vt[i] = Vt[j];
          Vt[j] = temp2;
        }
      }
    }
    Bt = jStat.transpose(B);
    for (i = 0; i < m; i++) {
      Y[i] = [];
      for (j = 0; j < Bt.length; j++) {
        Y[i][j] = jStat.dot([Vt[i]], [Bt[j]]);
      }
    }
    return [X, D, Vt, Y];
  }
});

// extend jStat.fn with methods that require one argument
(function(funcs) {
  for (var i = 0; i < funcs.length; i++) (function(passfunc) {
    jStat.fn[passfunc] = function(arg, func) {
      var tmpthis = this;
      // check for callback
      if (func) {
        setTimeout(function() {
          func.call(tmpthis, jStat.fn[passfunc].call(tmpthis, arg));
        }, 15);
        return this;
      }
      if (typeof jStat[passfunc](this, arg) === 'number')
        return jStat[passfunc](this, arg);
      else
        return jStat(jStat[passfunc](this, arg));
    };
  }(funcs[i]));
}('add divide multiply subtract dot pow exp log abs norm angle'.split(' ')));

}(this.jStat, Math));
(function(jStat, Math) {

var slice = [].slice;
var isNumber = jStat.utils.isNumber;
var isArray = jStat.utils.isArray;

// flag==true denotes use of sample standard deviation
// Z Statistics
jStat.extend({
  // 2 different parameter lists:
  // (value, mean, sd)
  // (value, array, flag)
  zscore: function zscore() {
    var args = slice.call(arguments);
    if (isNumber(args[1])) {
      return (args[0] - args[1]) / args[2];
    }
    return (args[0] - jStat.mean(args[1])) / jStat.stdev(args[1], args[2]);
  },

  // 3 different paramter lists:
  // (value, mean, sd, sides)
  // (zscore, sides)
  // (value, array, sides, flag)
  ztest: function ztest() {
    var args = slice.call(arguments);
    var z;
    if (isArray(args[1])) {
      // (value, array, sides, flag)
      z = jStat.zscore(args[0],args[1],args[3]);
      return (args[2] === 1) ?
        (jStat.normal.cdf(-Math.abs(z), 0, 1)) :
        (jStat.normal.cdf(-Math.abs(z), 0, 1)*2);
    } else {
      if (args.length > 2) {
        // (value, mean, sd, sides)
        z = jStat.zscore(args[0],args[1],args[2]);
        return (args[3] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)* 2);
      } else {
        // (zscore, sides)
        z = args[0];
        return (args[1] === 1) ?
          (jStat.normal.cdf(-Math.abs(z),0,1)) :
          (jStat.normal.cdf(-Math.abs(z),0,1)*2);
      }
    }
  }
});

jStat.extend(jStat.fn, {
  zscore: function zscore(value, flag) {
    return (value - this.mean()) / this.stdev(flag);
  },

  ztest: function ztest(value, sides, flag) {
    var zscore = Math.abs(this.zscore(value, flag));
    return (sides === 1) ?
      (jStat.normal.cdf(-zscore, 0, 1)) :
      (jStat.normal.cdf(-zscore, 0, 1) * 2);
  }
});

// T Statistics
jStat.extend({
  // 2 parameter lists
  // (value, mean, sd, n)
  // (value, array)
  tscore: function tscore() {
    var args = slice.call(arguments);
    return (args.length === 4) ?
      ((args[0] - args[1]) / (args[2] / Math.sqrt(args[3]))) :
      ((args[0] - jStat.mean(args[1])) /
       (jStat.stdev(args[1], true) / Math.sqrt(args[1].length)));
  },

  // 3 different paramter lists:
  // (value, mean, sd, n, sides)
  // (tscore, n, sides)
  // (value, array, sides)
  ttest: function ttest() {
    var args = slice.call(arguments);
    var tscore;
    if (args.length === 5) {
      tscore = Math.abs(jStat.tscore(args[0], args[1], args[2], args[3]));
      return (args[4] === 1) ?
        (jStat.studentt.cdf(-tscore, args[3]-1)) :
        (jStat.studentt.cdf(-tscore, args[3]-1)*2);
    }
    if (isNumber(args[1])) {
      tscore = Math.abs(args[0])
      return (args[2] == 1) ?
        (jStat.studentt.cdf(-tscore, args[1]-1)) :
        (jStat.studentt.cdf(-tscore, args[1]-1) * 2);
    }
    tscore = Math.abs(jStat.tscore(args[0], args[1]))
    return (args[2] == 1) ?
      (jStat.studentt.cdf(-tscore, args[1].length-1)) :
      (jStat.studentt.cdf(-tscore, args[1].length-1) * 2);
  }
});

jStat.extend(jStat.fn, {
  tscore: function tscore(value) {
    return (value - this.mean()) / (this.stdev(true) / Math.sqrt(this.cols()));
  },

  ttest: function ttest(value, sides) {
    return (sides === 1) ?
      (1 - jStat.studentt.cdf(Math.abs(this.tscore(value)), this.cols()-1)) :
      (jStat.studentt.cdf(-Math.abs(this.tscore(value)), this.cols()-1)*2);
  }
});

// F Statistics
jStat.extend({
  // Paramter list is as follows:
  // (array1, array2, array3, ...)
  // or it is an array of arrays
  // array of arrays conversion
  anovafscore: function anovafscore() {
    var args = slice.call(arguments),
    expVar, sample, sampMean, sampSampMean, tmpargs, unexpVar, i, j;
    if (args.length === 1) {
      tmpargs = new Array(args[0].length);
      for (i = 0; i < args[0].length; i++) {
        tmpargs[i] = args[0][i];
      }
      args = tmpargs;
    }
    // 2 sample case
    if (args.length === 2) {
      return jStat.variance(args[0]) / jStat.variance(args[1]);
    }
    // Builds sample array
    sample = new Array();
    for (i = 0; i < args.length; i++) {
      sample = sample.concat(args[i]);
    }
    sampMean = jStat.mean(sample);
    // Computes the explained variance
    expVar = 0;
    for (i = 0; i < args.length; i++) {
      expVar = expVar + args[i].length * Math.pow(jStat.mean(args[i]) - sampMean, 2);
    }
    expVar /= (args.length - 1);
    // Computes unexplained variance
    unexpVar = 0;
    for (i = 0; i < args.length; i++) {
      sampSampMean = jStat.mean(args[i]);
      for (j = 0; j < args[i].length; j++) {
        unexpVar += Math.pow(args[i][j] - sampSampMean, 2);
      }
    }
    unexpVar /= (sample.length - args.length);
    return expVar / unexpVar;
  },

  // 2 different paramter setups
  // (array1, array2, array3, ...)
  // (anovafscore, df1, df2)
  anovaftest: function anovaftest() {
    var args = slice.call(arguments),
    df1, df2, n, i;
    if (isNumber(args[0])) {
      return 1 - jStat.centralF.cdf(args[0], args[1], args[2]);
    }
    anovafscore = jStat.anovafscore(args);
    df1 = args.length - 1;
    n = 0;
    for (i = 0; i < args.length; i++) {
      n = n + args[i].length;
    }
    df2 = n - df1 - 1;
    return 1 - jStat.centralF.cdf(anovafscore, df1, df2);
  },

  ftest: function ftest(fscore, df1, df2) {
    return 1 - jStat.centralF.cdf(fscore, df1, df2);
  }
});

jStat.extend(jStat.fn, {
  anovafscore: function anovafscore() {
    return jStat.anovafscore(this.toArray());
  },

  anovaftes: function anovaftes() {
    var n = 0;
    var i;
    for (i = 0; i < this.length; i++) {
      n = n + this[i].length;
    }
    return jStat.ftest(this.anovafscore(), this.length - 1, n - this.length);
  }
});

// Error Bounds
jStat.extend({
  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  normalci: function normalci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.normal.inv(args[1] / 2, 0, 1) *
                        jStat.stdev(args[2]) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  // 2 different parameter setups
  // (value, alpha, sd, n)
  // (value, alpha, array)
  tci: function tci() {
    var args = slice.call(arguments),
    ans = new Array(2),
    change;
    if (args.length === 4) {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[3] - 1) *
                        args[2] / Math.sqrt(args[3]));
    } else {
      change = Math.abs(jStat.studentt.inv(args[1] / 2, args[2].length - 1) *
                        jStat.stdev(args[2], true) / Math.sqrt(args[2].length));
    }
    ans[0] = args[0] - change;
    ans[1] = args[0] + change;
    return ans;
  },

  significant: function significant(pvalue, alpha) {
    return pvalue < alpha;
  }
});

jStat.extend(jStat.fn, {
  normalci: function normalci(value, alpha) {
    return jStat.normalci(value, alpha, this.toArray());
  },

  tci: function tci(value, alpha) {
    return jStat.tci(value, alpha, this.toArray());
  }
});

// internal method for calculating the z-score for a difference of proportions test
function differenceOfProportions(p1, n1, p2, n2) {
  if (p1 > 1 || p2 > 1 || p1 <= 0 || p2 <= 0) {
    throw new Error("Proportions should be greater than 0 and less than 1")
  }
  var pooled = (p1 * n1 + p2 * n2) / (n1 + n2);
  var se = Math.sqrt(pooled * (1 - pooled) * ((1/n1) + (1/n2)));
  return (p1 - p2) / se;
}

// Difference of Proportions
jStat.extend(jStat.fn, {
  oneSidedDifferenceOfProportions: function oneSidedDifferenceOfProportions(p1, n1, p2, n2) {
    var z = differenceOfProportions(p1, n1, p2, n2);
    return jStat.ztest(z, 1);
  },

  twoSidedDifferenceOfProportions: function twoSidedDifferenceOfProportions(p1, n1, p2, n2) {
    var z = differenceOfProportions(p1, n1, p2, n2);
    return jStat.ztest(z, 2);
  }
});

}(this.jStat, Math));

return this.jStat;

});
define('js/statistics/chiSquare',["require", "exports", "jstat"], function (require, exports, jStat) {
    "use strict";
    // Derived from: https://en.wikipedia.org/wiki/Pearson's_chi-squared_test
    function chiSquare(observed, expected, degreesOfFreedom) {
        if (degreesOfFreedom === void 0) { degreesOfFreedom = undefined; }
        if (observed.length !== expected.length) {
            throw new Error("chiSquare: observed.length !== expected.length");
        }
        if (!degreesOfFreedom)
            degreesOfFreedom = observed.length - 1;
        if (degreesOfFreedom >= observed.length) {
            throw new Error("chiSquare: degreesOfFreedom is too large for length: " + degreesOfFreedom + " " + observed.length);
        }
        var x2 = 0;
        var observedTotal = 0;
        var expectedTotal = 0;
        for (var i = 0; i < observed.length; i++) {
            x2 += Math.pow(observed[i] - expected[i], 2) / expected[i];
            observedTotal += observed[i];
            expectedTotal += expected[i];
        }
        if (observedTotal !== Math.round(expectedTotal)) {
            console.log("Error chiSquare observedTotal", observedTotal, "expectedTotal", expectedTotal, "observed", observed, "expected", expected);
            throw new Error("chiSquare: observedTotal !== expectedTotal");
        }
        // var p = 1 - jStat.lowRegGamma(degreesOfFreedom / 2, x2 / 2) / jStat.gammafn(degreesOfFreedom / 2);
        var p = 1 - jStat.chisquare.cdf(x2, degreesOfFreedom);
        var result = { x2: x2, p: p, k: degreesOfFreedom, n: observed.length };
        // console.log("chiSquare", result);
        return result;
    }
    exports.chiSquare = chiSquare;
    // Data from Apache Commons Math ChiSquareTestTest.java
    function test() {
        var observed = [10, 9, 11];
        var expected = [10, 10, 10];
        // expected x2 = 0.2
        // expected p = 0.904837418036
        console.log("chiSquare", chiSquare(observed, expected));
        // was { x2: 0.2, p: 0.9048374180359595 }
        // The original test data seems buggy!!! Missing 90 somewhere in expected
        var observed1 = [500, 623, 72, 70, 31];
        var expected1 = [485, 541, 82, 61, 37];
        // Expected x2 = 9.023307936427388
        // Expected p = 0.06051952647453607
        // console.log("chiSquare", chiSquare(observed1, expected1));
        // was // { x2: 16.413107036160778, p: 0.002512095663000702 }
        // Data from Wikipedia
        var observed2 = [5, 8, 9, 8, 10, 20];
        var expected2 = [10, 10, 10, 10, 10, 10];
        // Expect x2 = 13.4
        // Expected p = ???
        console.log("chiSquare", chiSquare(observed2, expected2));
        // Was  { x2: 13.4, p: 0.019905220334774376 }
    }
});
// test(); 

define('js/statistics/statisticsCommon',["require", "exports"], function (require, exports) {
    function repeatCounts(array) {
        var values = {};
        for (var i = 0; i < array.length; i++) {
            var value = array[i];
            if (values[value] !== undefined) {
                values[value] += 1;
            }
            else {
                values[value] = 1;
            }
        }
        var result = [];
        for (var key in values) {
            var count = values[key];
            if (count > 1)
                result.push(count);
        }
        return result;
    }
    exports.repeatCounts = repeatCounts;
    function rankdata(a) {
        /*
        Ranks the data in a, dealing with ties appropriately.
    
        Equal values are assigned a rank that is the average of the ranks that
        would have been otherwise assigned to all of the values within that set.
        Ranks begin at 1, not 0.
    
        Example
        -------
        In [15]: stats.rankdata([0, 2, 2, 3])
        Out[15]: array([ 1. ,  2.5,  2.5,  4. ])
    
        Parameters
        ----------
        a : array
    
        Returns
        -------
        An array of length equal to the size of a, containing rank scores.
       
        */
        var n = a.length;
        var i;
        var j;
        var sortedArray = [];
        for (i = 0; i < n; i++) {
            sortedArray.push({ originalPosition: i, value: a[i] });
        }
        sortedArray.sort(function (a, b) { return a.value - b.value; });
        var newarray = newFilledArray(n);
        var sumranks = 0;
        var dupcount = 0;
        for (i = 0; i < n; i++) {
            sumranks += i;
            dupcount += 1;
            if (i === n - 1 || sortedArray[i].value !== sortedArray[i + 1].value) {
                var averank = sumranks / dupcount + 1;
                for (j = i - dupcount + 1; j < i + 1; j++) {
                    newarray[sortedArray[j].originalPosition] = averank;
                }
                sumranks = 0;
                dupcount = 0;
            }
        }
        return newarray;
    }
    exports.rankdata = rankdata;
    function rankdata_test() {
        var result = rankdata([0, 2, 2, 3]);
        console.log("rankdata self-test", result);
        // Should be: [ 1, 2.5, 2.5, 4 ]
    }
    // rankdata_test();
    function newFilledArray(length, val) {
        if (val === void 0) { val = 0; }
        var array = [];
        for (var i = 0; i < length; i++) {
            array[i] = val;
        }
        return array;
    }
    exports.newFilledArray = newFilledArray;
});

define('js/statistics/mannWhitneyU',["require", "exports", "jstat", "./statisticsCommon"], function (require, exports, jStat, statisticsCommon) {
    "use strict";
    // Calculates Mann-Whitney U test
    // Derived from older SciPy: http://web.mit.edu/6.863/spring2011/packages/scipy_src/scipy/stats/stats.py
    // Calculates a Mann-Whitney U statistic on the provided scores and returns the result.
    // Use only when the n in each condition is < 20 and you have 2 independent samples of ranks.
    // REMEMBER: Mann-Whitney U is significant if the u-obtained is LESS THAN or equal to the critical value of U.
    // Returns: u-statistic, one-tailed p-value (i.e., p(z(U)))
    function mannWhitneyU(x, y) {
        var n1 = x.length;
        var n2 = y.length;
        var allValues = x.concat(y);
        // console.log("mannWhitneyU allValues", allValues);
        var ranked = statisticsCommon.rankdata(allValues);
        // console.log("mannWhitneyU ranked", ranked);
        // get the x-ranks
        var rankx = ranked.slice(0, n1);
        // the rest are y-ranks
        var ranky = ranked.slice(n1);
        // console.log("mannWhitneyU rankx, ranky", rankx, ranky);
        // calc U for x
        var u1 = n1 * n2 + (n1 * (n1 + 1)) / 2.0 - jStat.sum(rankx);
        // remainder is U for y
        var u2 = n1 * n2 - u1;
        var bigu = Math.max(u1, u2);
        var smallu = Math.min(u1, u2);
        // console.log("mannWhitneyU bigu smallu", bigu, smallu);
        // correction factor for tied scores
        var T = Math.sqrt(tiecorrect(ranked));
        if (T === 0) {
            throw new Error("ValueError: All numbers are identical in mannWhitneyU");
        }
        // console.log("mannWhitneyU T tiecorrect", T);
        var sd = Math.sqrt(T * n1 * n2 * (n1 + n2 + 1) / 12.0);
        // console.log("mannWhitneyU sd", sd);
        // normal approximation for prob calc
        var z = Math.abs((bigu - n1 * n2 / 2.0) / sd);
        // console.log("mannWhitneyU z", z);
        var p = 1.0 - jStat.normal.cdf(z, 0, 1);
        // console.log("mannWhitneyU p", p);
        return { p: p, u: smallu, n1: n1, n2: n2 };
    }
    function tiecorrect(rankvals) {
        /*
        Tie-corrector for ties in Mann Whitney U and Kruskal Wallis H tests.
        See Siegel, S. (1956) Nonparametric Statistics for the Behavioral
        Sciences.  New York: McGraw-Hill.  Code adapted from |Stat rankind.c
        code.
    
        Returns: T correction factor for U or H
        */
        var sorted = rankvals.slice().sort(function (a, b) {
            return a - b;
        });
        var n = sorted.length;
        var T = 0.0;
        var i = 0;
        while (i < n - 1) {
            if (sorted[i] === sorted[i + 1]) {
                var nties = 1;
                while ((i < n - 1) && (sorted[i] === sorted[i + 1])) {
                    nties = nties + 1;
                    i = i + 1;
                }
                T = T + nties * nties * nties - nties;
            }
            i = i + 1;
        }
        T = T / (n * n * n - n);
        return 1.0 - T;
    }
    function test() {
        console.log("mannWhitneyU self diagnostic");
        var result1 = mannWhitneyU([1, 2, 3], [1, 2, 4]);
        console.log("result1", result1);
        // Result { u: 4, p: 0.4123703981236436 }
        // Values from: http://www.stat.purdue.edu/~tqin/system101/method/method_wilcoxon_rank_sum_sas.htm
        var result2 = mannWhitneyU([17, 20, 170, 315, 22, 190, 64], [22, 29, 13, 16, 15, 18, 15, 6]);
        console.log("result2", result2);
        // Result { u: 6.5, p: 0.006380543605407185 }
        // Values from: http://geographyfieldwork.com/Mann%20Whitney.htm
        var result3 = mannWhitneyU([7, 3, 6, 2, 4, 3, 5, 5], [3, 5, 6, 4, 6, 5, 7, 5]);
        console.log("result3", result3);
        // result3 { u: 23, p: 0.16955853681823607 }
        // Useful for comparing, but off a bit for p: http://www.socscistatistics.com/tests/mannwhitney/default2.aspx
    }
    return mannWhitneyU;
});

define('js/calculateStatistics',["require", "exports", "jstat", "./statistics/chiSquare", "./statistics/mannWhitneyU"], function (require, exports, jStat, chiSquare, mannWhitneyU) {
    "use strict";
    function collectDataForField(stories, fieldName, conversionFunction) {
        if (conversionFunction === void 0) { conversionFunction = null; }
        var result = [];
        for (var i = 0; i < stories.length; i++) {
            var value = stories[i].fieldValue(fieldName);
            if (value === null || value === undefined || value === "")
                continue;
            if (conversionFunction)
                value = conversionFunction(value);
            result.push(value);
        }
        return result;
    }
    function isValidNumber(value) {
        // console.log("isValidNumber", JSON.stringify(value));
        return value !== "" && !isNaN(value);
    }
    function collectXYDataForFields(stories, xFieldName, yFieldName) {
        var xResult = [];
        var yResult = [];
        for (var i = 0; i < stories.length; i++) {
            var xValue = stories[i].fieldValue(xFieldName);
            if (!isValidNumber(xValue))
                continue;
            var yValue = stories[i].fieldValue(yFieldName);
            if (!isValidNumber(yValue))
                continue;
            xResult.push(xValue);
            yResult.push(yValue);
        }
        return { x: xResult, y: yResult };
    }
    function addValue(arrayHolder, fieldName, value) {
        var values = arrayHolder[fieldName];
        if (!values)
            values = [];
        values.push(value);
        arrayHolder[fieldName] = values;
    }
    function valuesForFieldChoices(stories, scaleQuestionID, choiceQuestionID) {
        // console.log("countsForFieldChoices", stories, field1, field2);
        // TODO: Need to add in fields that were not selected with a zero count, using definition from questionnaire
        var values = {};
        for (var i = 0; i < stories.length; i++) {
            var scaleValue = stories[i].fieldValue(scaleQuestionID);
            if (scaleValue === null || scaleValue === undefined || scaleValue === "")
                continue; // value1 = "{N/A}";
            var choiceValue = stories[i].fieldValue(choiceQuestionID);
            if (choiceValue === null || choiceValue === undefined || scaleValue === "")
                continue; // value1 = "{N/A}";
            addValue(values, choiceValue, scaleValue);
        }
        return values;
    }
    /*
    function countsForFieldChoices(stories: surveyCollection.Story[], field1, field2) {
        // console.log("countsForFieldChoices", stories, field1, field2);
        // TODO: Need to add in fields that were not selected with a zero count, using definition from questionnaire
        var counts = {};
        for (var i = 0; i < stories.length; i++) {
            var value1 = stories[i].fieldValue(field1);
            var value2 = stories[i].fieldValue(field2);
            var value = JSON.stringify([value1, value2]);
            // console.log("value", value, value1, value2);
            var count = counts[value];
            if (!count) count = 0;
            count++;
            counts[value] = count;
        }
        return counts;
    }
    */
    /*
    function countsForFieldChoice(stories: surveyCollection.Story[], field1) {
        // console.log("countsForFieldChoice", stories, field1);
        // TODO: Need to add in fields that were not selected with a zero count, using definition from questionnaire
        var counts = {};
        for (var i = 0; i < stories.length; i++) {
            var value1 = stories[i].fieldValue(field1);
            if (value1 === null || value1 === undefined) continue; // value1 = "{N/A}";
            increment(counts, "" + value1);
        }
        return counts;
    }
    */
    function increment(countHolder, fieldName) {
        var count = countHolder[fieldName];
        if (!count)
            count = 0;
        count++;
        countHolder[fieldName] = count;
    }
    function valueTag(field1, field2) {
        if (field1 === null || field1 === undefined || field1 === "")
            field1 = "{N/A}";
        if (field2 === null || field2 === undefined || field2 === "")
            field2 = "{N/A}";
        var result = JSON.stringify([field1, field2]);
        // console.log("valueTag", result);
        return result;
    }
    function countsForTableChoices(stories, field1, field2) {
        // console.log("countsForFieldChoices", stories, field1, field2);
        // TODO: Maybe need to add in fields that were not selected with a zero count, using definition from questionnaire?
        var counts = {};
        var field1Options = {};
        var field2Options = {};
        var total = 0;
        for (var i = 0; i < stories.length; i++) {
            var value1 = stories[i].fieldValue(field1);
            if (value1 === null || value1 === undefined || value1 === "")
                continue; // value1 = "{N/A}";
            var value2 = stories[i].fieldValue(field2);
            if (value2 === null || value2 === undefined || value2 === "")
                continue; // value2 = "{N/A}";
            increment(counts, valueTag(value1, value2));
            increment(field1Options, "" + value1);
            increment(field2Options, "" + value2);
            total++;
        }
        var result = { counts: counts, field1Options: field1Options, field2Options: field2Options, total: total };
        // console.log("countsForTableChoices", result);
        return result;
    }
    /*
    function collectValues(valueHolder) {
        var values = [];
        for (var key in valueHolder) {
            values.push(valueHolder[key]);
        }
        return values;
    }
    */
    function calculateStatisticsForBarGraph(nominalQuestion, stories, minimumStoryCountRequiredForTest) {
        // not calculating statistics for bar graph
        var values = collectDataForField(stories, nominalQuestion.id);
        var n = values.length;
        return { significance: "None", calculated: ["n"], n: n };
    }
    exports.calculateStatisticsForBarGraph = calculateStatisticsForBarGraph;
    function calculateStatisticsForHistogram(ratioQuestion, stories, minimumStoryCountRequiredForTest) {
        // TODO: ? look for differences of means on a distribution using Student's T test if normal, otherwise Kruskal-Wallis or maybe Mann-Whitney
        // TODO: Fix this - could report on normality
        // var counts = collectDataForField(stories, ratioQuestion.id);
        // console.log("counts", counts);
        var values = collectDataForField(stories, ratioQuestion.id, parseFloat);
        // console.log("calculateStatisticsForHistogram values", values);
        var n = values.length;
        var mean = jStat.mean(values);
        var median = jStat.median(values);
        var sd = jStat.stdev(values, true);
        var skewness = jStat.skewness(values);
        var kurtosis = jStat.kurtosis(values);
        return { significance: "None", calculated: ["mean", "median", "sd", "skewness", "kurtosis", "n"], mean: mean, median: median, sd: sd, skewness: skewness, kurtosis: kurtosis, n: n };
    }
    exports.calculateStatisticsForHistogram = calculateStatisticsForHistogram;
    function calculateStatisticsForMultipleHistogram(ratioQuestion, nominalQuestion, stories, minimumStoryCountRequiredForTest) {
        // One of each continuous and not
        // for each option, look for differences of means on a distribution using Student's T test if normal, otherwise Kruskal-Wallis or maybe Mann-Whitney
        // TODO: use t-test when normal 
        // Can't calculate a statistic if one or both are mutiple answer checkboxes
        if (nominalQuestion.displayType === "checkboxes") {
            return { significance: "None (choices not mutually exclusive)", calculated: [] };
        }
        // var data = collectDataForField(stories, nominalQuestion.id);
        // var counts = countsForFieldChoice(stories, nominalQuestion.id);
        var values = valuesForFieldChoices(stories, ratioQuestion.id, nominalQuestion.id);
        var options = Object.keys(values);
        // console.log("calculateStatisticsForMultipleHistogram options", options, values);
        // For every pair, compute test, and take best p score
        var pLowest = Number.MAX_VALUE;
        var uLowest = NaN;
        var n = 0;
        var allResults = {};
        for (var i = 0; i < options.length; i++) {
            var x = values[options[i]];
            if (x.length < minimumStoryCountRequiredForTest)
                continue;
            n += x.length;
            for (var j = i + 1; j < options.length; j++) {
                var y = values[options[j]];
                if (y.length < minimumStoryCountRequiredForTest)
                    continue;
                var statResult = mannWhitneyU(x, y);
                allResults[options[i] + " X " + options[j]] = { p: statResult.p, u: statResult.u, n1: statResult.n1, n2: statResult.n2 };
                // console.log("calculateStatisticsForMultipleHistogram statResult", statResult);
                if (statResult.p <= pLowest) {
                    pLowest = statResult.p;
                    uLowest = statResult.u;
                }
            }
        }
        if (pLowest === Number.MAX_VALUE) {
            return { significance: "None (count below threshold)", calculated: [] };
        }
        var significance = " p=" + pLowest.toFixed(3) + " U=" + uLowest + " n=" + n;
        return { significance: significance, calculated: ["p", "U", "n"], p: pLowest, U: uLowest, n: n, allResults: allResults };
    }
    exports.calculateStatisticsForMultipleHistogram = calculateStatisticsForMultipleHistogram;
    function calculateStatisticsForScatterPlot(rationQuestion1, rationQuestion2, stories, minimumStoryCountRequiredForTest) {
        // TODO: both continuous -- look for correlation with Pearson's R (if normal distribution) or Spearman's R / Kendall's Tau (if not normal distribution)"
        var data = collectXYDataForFields(stories, rationQuestion1.id, rationQuestion2.id);
        if (data.x.length < minimumStoryCountRequiredForTest) {
            return { significance: "None (count below threshold)", calculated: [] };
        }
        // TODO: Add a flag somewhere to use Kendall's Tau instead of Pearson/Spearman's R
        // var statResult = kendallsTau(data.x, data.y);
        // TODO: Use Pearson's R instead of Spearman if normally distributed
        var r = jStat.spearmancoeff(data.x, data.y);
        // https://en.wikipedia.org/wiki/Spearman's_rank_correlation_coefficient#Determining_significance
        var n = data.x.length;
        var p;
        if (r >= 1) {
            // Perfectly correlated; handle sepearetly to avoid divide by zero error otherwise
            p = 0;
        }
        else {
            var t = r * Math.sqrt((n - 2.0) / (1.0 - r * r));
            p = jStat.ttest(t, n, 2);
        }
        var significance = " p=" + p.toFixed(3) + " rho=" + r.toFixed(3) + " n=" + n;
        //  + " tt=" + statResult.test.toFixed(3) + " tz=" + statResult.z.toFixed(3) + " tp=" + statResult.prob.toFixed(3) ;
        // console.log("calculateStatisticsForScatterPlot", rationQuestion1, rationQuestion2, n, t, p);
        return { significance: significance, calculated: ["p", "rho", "n"], p: p, rho: r, n: n };
    }
    exports.calculateStatisticsForScatterPlot = calculateStatisticsForScatterPlot;
    function calculateStatisticsForTable(nominalQuestion1, nominalQuestion2, stories, minimumStoryCountRequiredForTest) {
        // both not continuous -- look for a 'correspondence' between counts using Chi-squared test
        // Can't calculate a statistic if one or both are mutiple answer checkboxes
        // console.log("calculateStatisticsForTable", nominalQuestion1, nominalQuestion2);
        if (nominalQuestion1.displayType === "checkboxes" || nominalQuestion2.displayType === "checkboxes") {
            return { significance: "None (choices not mutually exclusive)", calculated: [] };
        }
        var counts = countsForTableChoices(stories, nominalQuestion1.id, nominalQuestion2.id);
        // console.log("counts", counts);
        var observed = [];
        var expected = [];
        // Only calculate observed and expected considering the fields which pass threshold and are actually used
        var field1OptionsUsed = {};
        var field2OptionsUsed = {};
        var field1Option;
        var field2Option;
        var field1Total;
        var field2Total;
        var observedValue;
        for (field1Option in counts.field1Options) {
            field1Total = counts.field1Options[field1Option];
            if (field1Total < minimumStoryCountRequiredForTest)
                continue;
            field1OptionsUsed[field1Option] = 0;
        }
        for (field2Option in counts.field2Options) {
            field2Total = counts.field2Options[field2Option];
            if (field2Total < minimumStoryCountRequiredForTest)
                continue;
            field2OptionsUsed[field2Option] = 0;
        }
        var usedTotal = 0;
        for (field1Option in field1OptionsUsed) {
            field1Total = 0;
            for (field2Option in field2OptionsUsed) {
                observedValue = counts.counts[valueTag(field1Option, field2Option)] || 0;
                field1Total += observedValue;
                usedTotal += observedValue;
            }
            field1OptionsUsed[field1Option] = field1Total;
        }
        for (field2Option in field2OptionsUsed) {
            field2Total = 0;
            for (field1Option in field1OptionsUsed) {
                observedValue = counts.counts[valueTag(field1Option, field2Option)] || 0;
                field2Total += observedValue;
            }
            field2OptionsUsed[field1Option] = field2Total;
        }
        for (field1Option in field1OptionsUsed) {
            field1Total = field1OptionsUsed[field1Option];
            for (field2Option in field2OptionsUsed) {
                field2Total = field2OptionsUsed[field2Option];
                observedValue = counts.counts[valueTag(field1Option, field2Option)] || 0;
                observed.push(observedValue);
                var expectedValue = field1Total * field2Total / usedTotal;
                expected.push(expectedValue);
            }
        }
        var n1 = Object.keys(field1OptionsUsed).length;
        var n2 = Object.keys(field2OptionsUsed).length;
        if (n1 <= 1 || n2 <= 1) {
            return { significance: "None (counts below threshold)", calculated: [] };
        }
        var degreesOfFreedom = (n1 - 1) * (n2 - 1);
        // Conditions needed for test according to: https://en.wikipedia.org/wiki/Pearson's_chi-squared_test
        var tooLowCount = 0;
        var zeroInCell = false;
        for (var i = 0; i < expected.length; i++) {
            if (expected[i] < 5)
                tooLowCount++;
            if (expected[i] === 0)
                zeroInCell = true;
        }
        if (zeroInCell) {
            return { significance: "None (zero in expected cell)", calculated: [] };
        }
        if (n1 <= 2 && n2 <= 2 && tooLowCount > 0) {
            return { significance: "None (2X2 with expected cell < 5)", calculated: [] };
        }
        if (tooLowCount / observed.length > 0.2) {
            return { significance: "None (less than 80% expected cells >= 5)", calculated: [] };
        }
        // console.log("observed", observed);
        // console.log("expected", expected);
        // console.log("degreesOfFreedom", degreesOfFreedom);
        var statResult = chiSquare.chiSquare(observed, expected, degreesOfFreedom);
        // console.log("statResult.n", statResult.n);
        if (statResult.n !== n1 * n2) {
            console.log("unexpected n1 * n2: ", n1, n2, statResult, observed, expected);
            throw new Error("unexpected n1 * n2");
        }
        if (statResult.n === degreesOfFreedom) {
            throw new Error("unexpected statResult.n");
        }
        var significance = " p=" + statResult.p.toFixed(3) + " x2=" + statResult.x2.toFixed(3) + " k=" + statResult.k + " n=" + statResult.n;
        return { significance: significance, calculated: ["p", "x2", "k", "n"], p: statResult.p, x2: statResult.x2, k: statResult.k, n: statResult.n };
    }
    exports.calculateStatisticsForTable = calculateStatisticsForTable;
});

/**
 * @license
 * lodash 3.3.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash compat -o ./lodash.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.3.1';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      REARG_FLAG = 128,
      ARY_FLAG = 256;

  /** Used as default options for `_.trunc`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 0,
      LAZY_MAP_FLAG = 1,
      LAZY_WHILE_FLAG = 2;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g,
      reUnescapedHtml = /[&<>"'`]/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /**
   * Used to match ES template delimiters.
   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-template-literal-lexical-components)
   * for more details.
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect named functions. */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to detect hexadecimal string values. */
  var reHexPrefix = /^0[xX]/;

  /** Used to detect host constructors (Safari > 5). */
  var reHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to match latin-1 supplementary letters (excluding mathematical operators). */
  var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /**
   * Used to match `RegExp` special characters.
   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
   * for more details.
   */
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to detect functions containing a `this` reference. */
  var reThis = /\bthis\b/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to match words to create compound words. */
  var reWords = (function() {
    var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]',
        lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';

    return RegExp(upper + '{2,}(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
  }());

  /** Used to detect and test for whitespace. */
  var whitespace = (
    // Basic whitespace characters.
    ' \t\x0b\f\xa0\ufeff' +

    // Line terminators.
    '\n\r\u2028\u2029' +

    // Unicode category "Zs" space separators.
    '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000'
  );

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'ArrayBuffer', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Math', 'Number',
    'Object', 'RegExp', 'Set', 'String', '_', 'clearTimeout', 'document',
    'isFinite', 'parseInt', 'setTimeout', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    'window', 'WinRTError'
  ];

  /** Used to fix the JScript `[[DontEnum]]` bug. */
  var shadowProps = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used as an internal `_.debounce` options object by `_.throttle`. */
  var debounceOptions = {
    'leading': false,
    'maxWait': 0,
    'trailing': false
  };

  /** Used to map latin-1 supplementary letters to basic latin letters. */
  var deburredLetters = {
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcC': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xeC': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&#96;': '`'
  };

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it is the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = (objectTypes[typeof window] && window !== (this && this.window)) ? window : this;

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root`. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;
  if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
    root = freeGlobal;
  }

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `compareAscending` which compares values and
   * sorts them in ascending order without guaranteeing a stable sort.
   *
   * @private
   * @param {*} value The value to compare to `other`.
   * @param {*} other The value to compare to `value`.
   * @returns {number} Returns the sort order indicator for `value`.
   */
  function baseCompareAscending(value, other) {
    if (value !== other) {
      var valIsReflexive = value === value,
          othIsReflexive = other === other;

      if (value > other || !valIsReflexive || (typeof value == 'undefined' && othIsReflexive)) {
        return 1;
      }
      if (value < other || !othIsReflexive || (typeof other == 'undefined' && valIsReflexive)) {
        return -1;
      }
    }
    return 0;
  }

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = (fromIndex || 0) - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * The base implementation of `_.sortBy` and `_.sortByAll` which uses `comparer`
   * to define the sort order of `array` and replaces criteria objects with their
   * corresponding values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * Converts `value` to a string if it is not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /**
   * Used by `_.max` and `_.min` as the default callback for string values.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the code unit of the first character of the string.
   */
  function charAtCallback(string) {
    return string.charCodeAt(0);
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the first character not found in `chars`.
   */
  function charsLeftIndex(string, chars) {
    var index = -1,
        length = string.length;

    while (++index < length && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last character
   * of `string` that is not found in `chars`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @param {string} chars The characters to find.
   * @returns {number} Returns the index of the last character not found in `chars`.
   */
  function charsRightIndex(string, chars) {
    var index = string.length;

    while (index-- && chars.indexOf(string.charAt(index)) > -1) {}
    return index;
  }

  /**
   * Used by `_.sortBy` to compare transformed elements of a collection and stable
   * sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareAscending(object, other) {
    return baseCompareAscending(object.criteria, other.criteria) || (object.index - other.index);
  }

  /**
   * Used by `_.sortByAll` to compare multiple properties of each element
   * in a collection and stable sort them in ascending order.
   *
   * @private
   * @param {Object} object The object to compare to `other`.
   * @param {Object} other The object to compare to `object`.
   * @returns {number} Returns the sort order indicator for `object`.
   */
  function compareMultipleAscending(object, other) {
    var index = -1,
        objCriteria = object.criteria,
        othCriteria = other.criteria,
        length = objCriteria.length;

    while (++index < length) {
      var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        return result;
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to provide the same value for
    // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
    // for more details.
    //
    // This also ensures a stable sort in V8 and other engines.
    // See https://code.google.com/p/v8/issues/detail?id=90 for more details.
    return object.index - other.index;
  }

  /**
   * Used by `_.deburr` to convert latin-1 supplementary letters to basic latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  function deburrLetter(letter) {
    return deburredLetters[letter];
  }

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(chr) {
    return htmlEscapes[chr];
  }

  /**
   * Used by `_.template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   * If `fromRight` is provided elements of `array` are iterated from right to left.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} [fromIndex] The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromRight ? (fromIndex || length) : ((fromIndex || 0) - 1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */
  var isHostObject = (function() {
    try {
      Object({ 'toString': 0 } + '');
    } catch(e) {
      return function() { return false; };
    }
    return function(value) {
      // IE < 9 presents many host objects as `Object` objects that can coerce
      // to strings despite having improperly defined `toString` methods.
      return typeof value.toString != 'function' && typeof (value + '') == 'string';
    };
  }());

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return (value && typeof value == 'object') || false;
  }

  /**
   * Used by `trimmedLeftIndex` and `trimmedRightIndex` to determine if a
   * character code is whitespace.
   *
   * @private
   * @param {number} charCode The character code to inspect.
   * @returns {boolean} Returns `true` if `charCode` is whitespace, else `false`.
   */
  function isSpace(charCode) {
    return ((charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160) || charCode == 5760 || charCode == 6158 ||
      (charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279)));
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /**
   * An implementation of `_.uniq` optimized for sorted arrays without support
   * for callback shorthands and `this` binding.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} [iteratee] The function invoked per iteration.
   * @returns {Array} Returns the new duplicate-value-free array.
   */
  function sortedUniq(array, iteratee) {
    var seen,
        index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index],
          computed = iteratee ? iteratee(value, index, array) : value;

      if (!index || seen !== computed) {
        seen = computed;
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * Used by `_.trim` and `_.trimLeft` to get the index of the first non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the first non-whitespace character.
   */
  function trimmedLeftIndex(string) {
    var index = -1,
        length = string.length;

    while (++index < length && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimRight` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedRightIndex(string) {
    var index = string.length;

    while (index-- && isSpace(string.charCodeAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(chr) {
    return htmlUnescapes[chr];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the given `context` object.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'add': function(a, b) { return a + b; } });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'sub': function(a, b) { return a - b; } });
   *
   * _.isFunction(_.add);
   * // => true
   * _.isFunction(_.sub);
   * // => false
   *
   * lodash.isFunction(lodash.add);
   * // => false
   * lodash.isFunction(lodash.sub);
   * // => true
   *
   * // using `context` to mock `Date#getTime` use in `_.now`
   * var mock = _.runInContext({
   *   'Date': function() {
   *     return { 'getTime': getTimeMock };
   *   }
   * });
   *
   * // or creating a suped-up `defer` in Node.js
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  function runInContext(context) {
    // Avoid issues with some ES3 environments that attempt to use values, named
    // after built-in constructors like `Object`, for the creation of literals.
    // ES5 clears this up by stating that literals must use built-in constructors.
    // See https://es5.github.io/#x11.1.5 for more details.
    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;

    /** Native constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Number = context.Number,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for native method references. */
    var arrayProto = Array.prototype,
        errorProto = Error.prototype,
        objectProto = Object.prototype,
        stringProto = String.prototype;

    /** Used to detect DOM support. */
    var document = (document = context.window) && document.document;

    /** Used to resolve the decompiled source of functions. */
    var fnToString = Function.prototype.toString;

    /** Used to the length of n-tuples for `_.unzip`. */
    var getLength = baseProperty('length');

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /**
     * Used to resolve the `toStringTag` of values.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
     * for more details.
     */
    var objToString = objectProto.toString;

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = context._;

    /** Used to detect if a method is native. */
    var reNative = RegExp('^' +
      escapeRegExp(objToString)
      .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Native method references. */
    var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer,
        bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
        ceil = Math.ceil,
        clearTimeout = context.clearTimeout,
        floor = Math.floor,
        getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
        push = arrayProto.push,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        Set = isNative(Set = context.Set) && Set,
        setTimeout = context.setTimeout,
        splice = arrayProto.splice,
        Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array,
        WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;

    /** Used to clone array buffers. */
    var Float64Array = (function() {
      // Safari 5 errors when using an array buffer to initialize a typed array
      // where the array buffer's `byteLength` is not a multiple of the typed
      // array's `BYTES_PER_ELEMENT`.
      try {
        var func = isNative(func = context.Float64Array) && func,
            result = new func(new ArrayBuffer(10), 0, 1) && func;
      } catch(e) {}
      return result;
    }());

    /* Native method references for those with the same name as other `lodash` methods. */
    var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
        nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
        nativeIsFinite = context.isFinite,
        nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = isNative(nativeNow = Date.now) && nativeNow,
        nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random;

    /** Used as references for `-Infinity` and `Infinity`. */
    var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY,
        POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

    /** Used as references for the maximum length and index of an array. */
    var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
        MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

    /** Used as the size, in bytes, of each `Float64Array` element. */
    var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

    /**
     * Used as the maximum length of an array-like value.
     * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
     * for more details.
     */
    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup a type array constructors by `toStringTag`. */
    var ctorByTag = {};
    ctorByTag[float32Tag] = context.Float32Array;
    ctorByTag[float64Tag] = context.Float64Array;
    ctorByTag[int8Tag] = context.Int8Array;
    ctorByTag[int16Tag] = context.Int16Array;
    ctorByTag[int32Tag] = context.Int32Array;
    ctorByTag[uint8Tag] = context.Uint8Array;
    ctorByTag[uint8ClampedTag] = context.Uint8ClampedArray;
    ctorByTag[uint16Tag] = context.Uint16Array;
    ctorByTag[uint32Tag] = context.Uint32Array;

    /** Used to avoid iterating over non-enumerable properties in IE < 9. */
    var nonEnumProps = {};
    nonEnumProps[arrayTag] = nonEnumProps[dateTag] = nonEnumProps[numberTag] = { 'constructor': true, 'toLocaleString': true, 'toString': true, 'valueOf': true };
    nonEnumProps[boolTag] = nonEnumProps[stringTag] = { 'constructor': true, 'toString': true, 'valueOf': true };
    nonEnumProps[errorTag] = nonEnumProps[funcTag] = nonEnumProps[regexpTag] = { 'constructor': true, 'toString': true };
    nonEnumProps[objectTag] = { 'constructor': true };

    arrayEach(shadowProps, function(key) {
      for (var tag in nonEnumProps) {
        if (hasOwnProperty.call(nonEnumProps, tag)) {
          var props = nonEnumProps[tag];
          props[key] = hasOwnProperty.call(props, key);
        }
      }
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit chaining.
     * Methods that operate on and return arrays, collections, and functions can
     * be chained together. Methods that return a boolean or single value will
     * automatically end the chain returning the unwrapped value. Explicit chaining
     * may be enabled using `_.chain`. The execution of chained methods is lazy,
     * that is, execution is deferred until `_#value` is implicitly or explicitly
     * called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
     * fusion is an optimization that merges iteratees to avoid creating intermediate
     * arrays and reduce the number of iteratee executions.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * The wrapper methods that support shortcut fusion are:
     * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
     * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
     * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
     * and `where`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
     * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
     * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
     * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
     * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
     * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`, `merge`,
     * `mixin`, `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
     * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
     * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
     * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `splice`, `spread`,
     * `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`, `throttle`,
     * `thru`, `times`, `toArray`, `toPlainObject`, `transform`, `union`, `uniq`,
     * `unshift`, `unzip`, `values`, `valuesIn`, `where`, `without`, `wrap`, `xor`,
     * `zip`, and `zipObject`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
     * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
     * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
     * `identity`, `includes`, `indexOf`, `isArguments`, `isArray`, `isBoolean`,
     * `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`, `isFinite`,
     * `isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
     * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
     * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
     * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
     * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
     * `startCase`, `startsWith`, `template`, `trim`, `trimLeft`, `trimRight`,
     * `trunc`, `unescape`, `uniqueId`, `value`, and `words`
     *
     * The wrapper method `sample` will return a wrapped value when `n` is provided,
     * otherwise an unwrapped value is returned.
     *
     * @name _
     * @constructor
     * @category Chain
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, n) {
     *   return sum + n;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(n) {
     *   return n * n;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The function whose prototype all chaining wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable chaining for all wrapper methods.
     * @param {Array} [actions=[]] Actions to peform to resolve the unwrapped value.
     */
    function LodashWrapper(value, chainAll, actions) {
      this.__wrapped__ = value;
      this.__actions__ = actions || [];
      this.__chain__ = !!chainAll;
    }

    /**
     * An object environment feature flags.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    var support = lodash.support = {};

    (function(x) {
      var Ctor = function() { this.x = 1; },
          object = { '0': 1, 'length': 1 },
          props = [];

      Ctor.prototype = { 'valueOf': 1, 'y': 1 };
      for (var key in new Ctor) { props.push(key); }

      /**
       * Detect if the `toStringTag` of `arguments` objects is resolvable
       * (all but Firefox < 4, IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.argsTag = objToString.call(arguments) == argsTag;

      /**
       * Detect if `name` or `message` properties of `Error.prototype` are
       * enumerable by default (IE < 9, Safari < 5.1).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.enumErrorProps = propertyIsEnumerable.call(errorProto, 'message') ||
        propertyIsEnumerable.call(errorProto, 'name');

      /**
       * Detect if `prototype` properties are enumerable by default.
       *
       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
       * (if the prototype or a property on the prototype has been set)
       * incorrectly set the `[[Enumerable]]` value of a function's `prototype`
       * property to `true`.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.enumPrototypes = propertyIsEnumerable.call(Ctor, 'prototype');

      /**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but Firefox OS certified apps, older Opera mobile browsers, and
       * the PlayStation 3; forced `false` for Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);

      /**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.funcNames = typeof Function.name == 'string';

      /**
       * Detect if the `toStringTag` of DOM nodes is resolvable (all but IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.nodeTag = objToString.call(document) != objectTag;

      /**
       * Detect if string indexes are non-enumerable
       * (IE < 9, RingoJS, Rhino, Narwhal).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.nonEnumStrings = !propertyIsEnumerable.call('x', 0);

      /**
       * Detect if properties shadowing those on `Object.prototype` are
       * non-enumerable.
       *
       * In IE < 9 an object's own properties, shadowing non-enumerable ones,
       * are made non-enumerable as well (a.k.a the JScript `[[DontEnum]]` bug).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.nonEnumShadows = !/valueOf/.test(props);

      /**
       * Detect if own properties are iterated after inherited properties (IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
      support.ownLast = props[0] != 'x';

      /**
       * Detect if `Array#shift` and `Array#splice` augment array-like objects
       * correctly.
       *
       * Firefox < 10, compatibility modes of IE 8, and IE < 9 have buggy Array `shift()`
       * and `splice()` functions that fail to remove the last element, `value[0]`,
       * of array-like objects even though the `length` property is set to `0`.
       * The `shift()` method is buggy in compatibility modes of IE 8, while `splice()`
       * is buggy regardless of mode in IE < 9.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.spliceObjects = (splice.call(object, 0, 1), !object[0]);

      /**
       * Detect lack of support for accessing string characters by index.
       *
       * IE < 8 can't access characters by index. IE 8 can only access characters
       * by index on string literals, not string objects.
       *
       * @memberOf _.support
       * @type boolean
       */
      support.unindexedChars = ('x'[0] + Object('x')[0]) != 'xx';

      /**
       * Detect if the DOM is supported.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.dom = document.createDocumentFragment().nodeType === 11;
      } catch(e) {
        support.dom = false;
      }

      /**
       * Detect if `arguments` object indexes are non-enumerable.
       *
       * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
       * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
       * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
       * checks for indexes that exceed their function's formal parameters with
       * associated values of `0`.
       *
       * @memberOf _.support
       * @type boolean
       */
      try {
        support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
      } catch(e) {
        support.nonEnumArgs = true;
      }
    }(0, 0));

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB). Change the following template settings to use
     * alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
        '_': lodash
      }
    };

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = null;
      this.__dir__ = 1;
      this.__dropCount__ = 0;
      this.__filtered__ = false;
      this.__iteratees__ = null;
      this.__takeCount__ = POSITIVE_INFINITY;
      this.__views__ = null;
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var actions = this.__actions__,
          iteratees = this.__iteratees__,
          views = this.__views__,
          result = new LazyWrapper(this.__wrapped__);

      result.__actions__ = actions ? arrayCopy(actions) : null;
      result.__dir__ = this.__dir__;
      result.__dropCount__ = this.__dropCount__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = views ? arrayCopy(views) : null;
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value();
      if (!isArray(array)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var dir = this.__dir__,
          isRight = dir < 0,
          view = getView(0, array.length, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          dropCount = this.__dropCount__,
          takeCount = nativeMin(length, this.__takeCount__),
          index = isRight ? end : start - 1,
          iteratees = this.__iteratees__,
          iterLength = iteratees ? iteratees.length : 0,
          resIndex = 0,
          result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              computed = iteratee(value, index, array),
              type = data.type;

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        if (dropCount) {
          dropCount--;
        } else {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a cache object to store key/value pairs.
     *
     * @private
     * @static
     * @name Cache
     * @memberOf _.memoize
     */
    function MapCache() {
      this.__data__ = {};
    }

    /**
     * Removes `key` and its value from the cache.
     *
     * @private
     * @name delete
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed successfully, else `false`.
     */
    function mapDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }

    /**
     * Gets the cached value for `key`.
     *
     * @private
     * @name get
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the cached value.
     */
    function mapGet(key) {
      return key == '__proto__' ? undefined : this.__data__[key];
    }

    /**
     * Checks if a cached value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapHas(key) {
      return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
    }

    /**
     * Adds `value` to `key` of the cache.
     *
     * @private
     * @name set
     * @memberOf _.memoize.Cache
     * @param {string} key The key of the value to cache.
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache object.
     */
    function mapSet(key, value) {
      if (key != '__proto__') {
        this.__data__[key] = value;
      }
      return this;
    }

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates a cache object to store unique values.
     *
     * @private
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var length = values ? values.length : 0;

      this.data = { 'hash': nativeCreate(null), 'set': new Set };
      while (length--) {
        this.push(values[length]);
      }
    }

    /**
     * Checks if `value` is in `cache` mimicking the return signature of
     * `_.indexOf` by returning `0` if the value is found, else `-1`.
     *
     * @private
     * @param {Object} cache The cache to search.
     * @param {*} value The value to search for.
     * @returns {number} Returns `0` if `value` is found, else `-1`.
     */
    function cacheIndexOf(cache, value) {
      var data = cache.data,
          result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

      return result ? 0 : -1;
    }

    /**
     * Adds `value` to the cache.
     *
     * @private
     * @name push
     * @memberOf SetCache
     * @param {*} value The value to cache.
     */
    function cachePush(value) {
      var data = this.data;
      if (typeof value == 'string' || isObject(value)) {
        data.set.add(value);
      } else {
        data.hash[value] = true;
      }
    }

    /*------------------------------------------------------------------------*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function arrayCopy(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * A specialized version of `_.forEach` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.forEachRight` for arrays without support for
     * callback shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEachRight(array, iteratee) {
      var length = array.length;

      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }

    /**
     * A specialized version of `_.every` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */
    function arrayEvery(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.map` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * A specialized version of `_.max` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     */
    function arrayMax(array) {
      var index = -1,
          length = array.length,
          result = NEGATIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value > result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.min` for arrays without support for iteratees.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     */
    function arrayMin(array) {
      var index = -1,
          length = array.length,
          result = POSITIVE_INFINITY;

      while (++index < length) {
        var value = array[index];
        if (value < result) {
          result = value;
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the first element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initFromArray) {
      var index = -1,
          length = array.length;

      if (initFromArray && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.reduceRight` for arrays without support for
     * callback shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initFromArray] Specify using the last element of `array`
     *  as the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
      var length = array.length;
      if (initFromArray && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }

    /**
     * A specialized version of `_.some` for arrays without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Used by `_.defaults` to customize its `_.assign` use.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignDefaults(objectValue, sourceValue) {
      return typeof objectValue == 'undefined' ? sourceValue : objectValue;
    }

    /**
     * Used by `_.template` to customize its `_.assign` use.
     *
     * **Note:** This method is like `assignDefaults` except that it ignores
     * inherited property values when checking if a property is `undefined`.
     *
     * @private
     * @param {*} objectValue The destination object property value.
     * @param {*} sourceValue The source object property value.
     * @param {string} key The key associated with the object and source values.
     * @param {Object} object The destination object.
     * @returns {*} Returns the value to assign to the destination object.
     */
    function assignOwnDefaults(objectValue, sourceValue, key, object) {
      return (typeof objectValue == 'undefined' || !hasOwnProperty.call(object, key))
        ? sourceValue
        : objectValue;
    }

    /**
     * The base implementation of `_.assign` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize assigning values.
     * @returns {Object} Returns the destination object.
     */
    function baseAssign(object, source, customizer) {
      var props = keys(source);
      if (!customizer) {
        return baseCopy(source, object, props);
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index],
            value = object[key],
            result = customizer(value, source[key], key, object, source);

        if ((result === result ? result !== value : value === value) ||
            (typeof value == 'undefined' && !(key in object))) {
          object[key] = result;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.at` without support for strings and individual
     * key arguments.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {number[]|string[]} [props] The property names or indexes of elements to pick.
     * @returns {Array} Returns the new array of picked elements.
     */
    function baseAt(collection, props) {
      var index = -1,
          length = collection.length,
          isArr = isLength(length),
          propsLength = props.length,
          result = Array(propsLength);

      while(++index < propsLength) {
        var key = props[index];
        if (isArr) {
          key = parseFloat(key);
          result[index] = isIndex(key, length) ? collection[key] : undefined;
        } else {
          result[index] = collection[key];
        }
      }
      return result;
    }

    /**
     * Copies the properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Array} props The property names to copy.
     * @returns {Object} Returns `object`.
     */
    function baseCopy(source, object, props) {
      if (!props) {
        props = object;
        object = {};
      }
      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];
        object[key] = source[key];
      }
      return object;
    }

    /**
     * The base implementation of `_.bindAll` without support for individual
     * method name arguments.
     *
     * @private
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {string[]} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     */
    function baseBindAll(object, methodNames) {
      var index = -1,
          length = methodNames.length;

      while (++index < length) {
        var key = methodNames[index];
        object[key] = createWrapper(object[key], BIND_FLAG, object);
      }
      return object;
    }

    /**
     * The base implementation of `_.callback` which supports specifying the
     * number of arguments to provide to `func`.
     *
     * @private
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function baseCallback(func, thisArg, argCount) {
      var type = typeof func;
      if (type == 'function') {
        return (typeof thisArg != 'undefined' && isBindable(func))
          ? bindCallback(func, thisArg, argCount)
          : func;
      }
      if (func == null) {
        return identity;
      }
      if (type == 'object') {
        return baseMatches(func);
      }
      return typeof thisArg == 'undefined'
        ? baseProperty(func + '')
        : baseMatchesProperty(func + '', thisArg);
    }

    /**
     * The base implementation of `_.clone` without support for argument juggling
     * and `this` binding `customizer` functions.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The object `value` belongs to.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object) : customizer(value);
      }
      if (typeof result != 'undefined') {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return arrayCopy(value, result);
        }
      } else {
        var tag = objToString.call(value),
            isFunc = tag == funcTag;

        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return baseCopy(value, result, keys(value));
          }
        } else {
          return cloneableTags[tag]
            ? initCloneByTag(value, tag, isDeep)
            : (object ? value : {});
        }
      }
      // Check for circular references and return corresponding clone.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == value) {
          return stackB[length];
        }
      }
      // Add the source value to the stack of traversed objects and associate it with its clone.
      stackA.push(value);
      stackB.push(result);

      // Recursively populate clone (susceptible to call stack limits).
      (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
        result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
      });
      return result;
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} prototype The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || context.Object();
      };
    }());

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts an index
     * of where to slice the arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Object} args The `arguments` object to slice and provide to `func`.
     * @returns {number} Returns the timer id.
     */
    function baseDelay(func, wait, args, fromIndex) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);
    }

    /**
     * The base implementation of `_.difference` which accepts a single array
     * of values to exclude.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values) {
      var length = array ? array.length : 0,
          result = [];

      if (!length) {
        return result;
      }
      var index = -1,
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf,
          cache = (isCommon && values.length >= 200) ? createCache(values) : null,
          valuesLength = values.length;

      if (cache) {
        indexOf = cacheIndexOf;
        isCommon = false;
        values = cache;
      }
      outer:
      while (++index < length) {
        var value = array[index];

        if (isCommon && value === value) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === value) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (indexOf(values, value) < 0) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEach(collection, iteratee) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        return baseForOwn(collection, iteratee);
      }
      var index = -1,
          iterable = toObject(collection);

      while (++index < length) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    }

    /**
     * The base implementation of `_.forEachRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object|string} Returns `collection`.
     */
    function baseEachRight(collection, iteratee) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        return baseForOwnRight(collection, iteratee);
      }
      var iterable = toObject(collection);
      while (length--) {
        if (iteratee(iterable[length], length, iterable) === false) {
          break;
        }
      }
      return collection;
    }

    /**
     * The base implementation of `_.every` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end >>> 0;
      start >>>= 0;

      while (start < length) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.find`, `_.findLast`, `_.findKey`, and `_.findLastKey`,
     * without support for callback shorthands and `this` binding, which iterates
     * over `collection` using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @param {boolean} [retKey] Specify returning the key of the found element
     *  instead of the element itself.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */
    function baseFind(collection, predicate, eachFunc, retKey) {
      var result;
      eachFunc(collection, function(value, key, collection) {
        if (predicate(value, key, collection)) {
          result = retKey ? key : value;
          return false;
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with added support for restricting
     * flattening and specifying the start index.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param {boolean} [isStrict] Restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, isDeep, isStrict, fromIndex) {
      var index = (fromIndex || 0) - 1,
          length = array.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
          if (isDeep) {
            // Recursively flatten arrays (susceptible to call stack limits).
            value = baseFlatten(value, isDeep, isStrict);
          }
          var valIndex = -1,
              valLength = value.length;

          result.length += valLength;
          while (++valIndex < valLength) {
            result[++resIndex] = value[valIndex];
          }
        } else if (!isStrict) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForIn` and `baseForOwn` which iterates
     * over `object` properties returned by `keysFunc` invoking `iteratee` for
     * each property. Iterator functions may exit iteration early by explicitly
     * returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseFor(object, iteratee, keysFunc) {
      var index = -1,
          iterable = toObject(object),
          props = keysFunc(object),
          length = props.length;

      while (++index < length) {
        var key = props[index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    function baseForRight(object, iteratee, keysFunc) {
      var iterable = toObject(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[length];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    }

    /**
     * The base implementation of `_.forIn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForIn(object, iteratee) {
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * The base implementation of `_.forOwn` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for callback
     * shorthands and `this` binding.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from those provided.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the new array of filtered property names.
     */
    function baseFunctions(object, props) {
      var index = -1,
          length = props.length,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var key = props[index];
        if (isFunction(object[key])) {
          result[++resIndex] = key;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invoke` which requires additional arguments
     * to be provided as an array of arguments rather than individually.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {Array} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     */
    function baseInvoke(collection, methodName, args) {
      var index = -1,
          isFunc = typeof methodName == 'function',
          length = collection ? collection.length : 0,
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var func = isFunc ? methodName : (value != null && value[methodName]);
        result[++index] = func ? func.apply(value, args) : undefined;
      });
      return result;
    }

    /**
     * The base implementation of `_.isEqual` without support for `this` binding
     * `customizer` functions.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
      // Exit early for identical values.
      if (value === other) {
        // Treat `+0` vs. `-0` as not equal.
        return value !== 0 || (1 / value == 1 / other);
      }
      var valType = typeof value,
          othType = typeof other;

      // Exit early for unlike primitive values.
      if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
          value == null || other == null) {
        // Return `false` unless both values are `NaN`.
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `value` objects.
     * @param {Array} [stackB=[]] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = arrayTag,
          othTag = arrayTag;

      if (!objIsArr) {
        objTag = objToString.call(object);
        if (objTag == argsTag) {
          objTag = objectTag;
        } else if (objTag != objectTag) {
          objIsArr = isTypedArray(object);
        }
      }
      if (!othIsArr) {
        othTag = objToString.call(other);
        if (othTag == argsTag) {
          othTag = objectTag;
        } else if (othTag != objectTag) {
          othIsArr = isTypedArray(other);
        }
      }
      var objIsObj = objTag == objectTag && !isHostObject(object),
          othIsObj = othTag == objectTag && !isHostObject(other),
          isSameTag = objTag == othTag;

      if (isSameTag && !(objIsArr || objIsObj)) {
        return equalByTag(object, other, objTag);
      }
      var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (valWrapped || othWrapped) {
        return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
      }
      if (!isSameTag) {
        return false;
      }
      // Assume cyclic values are equal.
      // For more information on detecting circular references see https://es5.github.io/#JO.
      stackA || (stackA = []);
      stackB || (stackB = []);

      var length = stackA.length;
      while (length--) {
        if (stackA[length] == object) {
          return stackB[length] == other;
        }
      }
      // Add `object` and `other` to the stack of traversed objects.
      stackA.push(object);
      stackB.push(other);

      var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

      stackA.pop();
      stackB.pop();

      return result;
    }

    /**
     * The base implementation of `_.isMatch` without support for callback
     * shorthands or `this` binding.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The source property names to match.
     * @param {Array} values The source values to match.
     * @param {Array} strictCompareFlags Strict comparison flags for source values.
     * @param {Function} [customizer] The function to customize comparing objects.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      var index = -1,
          noCustomizer = !customizer;

      while (++index < length) {
        if ((noCustomizer && strictCompareFlags[index])
              ? values[index] !== object[props[index]]
              : !hasOwnProperty.call(object, props[index])
            ) {
          return false;
        }
      }
      index = -1;
      while (++index < length) {
        var key = props[index];
        if (noCustomizer && strictCompareFlags[index]) {
          var result = hasOwnProperty.call(object, key);
        } else {
          var objValue = object[key],
              srcValue = values[index];

          result = customizer ? customizer(objValue, srcValue, key) : undefined;
          if (typeof result == 'undefined') {
            result = baseIsEqual(srcValue, objValue, customizer, true);
          }
        }
        if (!result) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.map` without support for callback shorthands
     * or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var result = [];
      baseEach(collection, function(value, key, collection) {
        result.push(iteratee(value, key, collection));
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which does not clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     */
    function baseMatches(source) {
      var props = keys(source),
          length = props.length;

      if (length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return function(object) {
            return object != null && object[key] === value && hasOwnProperty.call(object, key);
          };
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = source[props[length]];
        values[length] = value;
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return function(object) {
        return baseIsMatch(object, props, values, strictCompareFlags);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which does not coerce `key`
     * to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     */
    function baseMatchesProperty(key, value) {
      if (isStrictComparable(value)) {
        return function(object) {
          return object != null && object[key] === value;
        };
      }
      return function(object) {
        return object != null && baseIsEqual(value, object[key], null, true);
      };
    }

    /**
     * The base implementation of `_.merge` without support for argument juggling,
     * multiple sources, and `this` binding `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {Object} Returns the destination object.
     */
    function baseMerge(object, source, customizer, stackA, stackB) {
      if (!isObject(object)) {
        return object;
      }
      var isSrcArr = isLength(source.length) && (isArray(source) || isTypedArray(source));
      (isSrcArr ? arrayEach : baseForOwn)(source, function(srcValue, key, source) {
        if (isObjectLike(srcValue)) {
          stackA || (stackA = []);
          stackB || (stackB = []);
          return baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
        }
        var value = object[key],
            result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
            isCommon = typeof result == 'undefined';

        if (isCommon) {
          result = srcValue;
        }
        if ((isSrcArr || typeof result != 'undefined') &&
            (isCommon || (result === result ? result !== value : value === value))) {
          object[key] = result;
        }
      });
      return object;
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
      var length = stackA.length,
          srcValue = source[key];

      while (length--) {
        if (stackA[length] == srcValue) {
          object[key] = stackB[length];
          return;
        }
      }
      var value = object[key],
          result = customizer ? customizer(value, srcValue, key, object, source) : undefined,
          isCommon = typeof result == 'undefined';

      if (isCommon) {
        result = srcValue;
        if (isLength(srcValue.length) && (isArray(srcValue) || isTypedArray(srcValue))) {
          result = isArray(value)
            ? value
            : (value ? arrayCopy(value) : []);
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          result = isArguments(value)
            ? toPlainObject(value)
            : (isPlainObject(value) ? value : {});
        }
        else {
          isCommon = false;
        }
      }
      // Add the source value to the stack of traversed objects and associate
      // it with its merged value.
      stackA.push(srcValue);
      stackB.push(result);

      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
      } else if (result === result ? result !== value : value === value) {
        object[key] = result;
      }
    }

    /**
     * The base implementation of `_.property` which does not coerce `key` to a string.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * index arguments.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     */
    function basePullAt(array, indexes) {
      var length = indexes.length,
          result = baseAt(array, indexes);

      indexes.sort(baseCompareAscending);
      while (length--) {
        var index = parseFloat(indexes[length]);
        if (index != previous && isIndex(index)) {
          var previous = index;
          splice.call(array, index, 1);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.random` without support for argument juggling
     * and returning floating-point numbers.
     *
     * @private
     * @param {number} min The minimum possible value.
     * @param {number} max The maximum possible value.
     * @returns {number} Returns the random number.
     */
    function baseRandom(min, max) {
      return min + floor(nativeRandom() * (max - min + 1));
    }

    /**
     * The base implementation of `_.reduce` and `_.reduceRight` without support
     * for callback shorthands or `this` binding, which iterates over `collection`
     * using the provided `eachFunc`.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initFromCollection Specify using the first or last element
     *  of `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */
    function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
      eachFunc(collection, function(value, index, collection) {
        accumulator = initFromCollection
          ? (initFromCollection = false, value)
          : iteratee(accumulator, value, index, collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `setData` without support for hot loop detection.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      start = start == null ? 0 : (+start || 0);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : (end - start) >>> 0;
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for callback shorthands
     * or `this` binding.
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * and `this` binding.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The function invoked per iteration.
     * @returns {Array} Returns the new duplicate-value-free array.
     */
    function baseUniq(array, iteratee) {
      var index = -1,
          indexOf = getIndexOf(),
          length = array.length,
          isCommon = indexOf == baseIndexOf,
          isLarge = isCommon && length >= 200,
          seen = isLarge ? createCache() : null,
          result = [];

      if (seen) {
        indexOf = cacheIndexOf;
        isCommon = false;
      } else {
        isLarge = false;
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value, index, array) : value;

        if (isCommon && value === value) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (indexOf(seen, computed) < 0) {
          if (iteratee || isLarge) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * returned by `keysFunc`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      var index = -1,
          length = props.length,
          result = Array(length);

      while (++index < length) {
        result[index] = object[props[index]];
      }
      return result;
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to peform to resolve the unwrapped value.
     * @returns {*} Returns the resolved unwrapped value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      var index = -1,
          length = actions.length;

      while (++index < length) {
        var args = [result],
            action = actions[index];

        push.apply(args, action.args);
        result = action.func.apply(action.thisArg, args);
      }
      return result;
    }

    /**
     * Performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest, instead
     *  of the lowest, index at which a value should be inserted into `array`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndex(array, value, retHighest) {
      var low = 0,
          high = array ? array.length : low;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (retHighest ? (computed <= value) : (computed < value)) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return binaryIndexBy(array, value, identity, retHighest);
    }

    /**
     * This function is like `binaryIndex` except that it invokes `iteratee` for
     * `value` and each element of `array` to compute their sort ranking. The
     * iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [retHighest] Specify returning the highest, instead
     *  of the lowest, index at which a value should be inserted into `array`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function binaryIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array ? array.length : 0,
          valIsNaN = value !== value,
          valIsUndef = typeof value == 'undefined';

      while (low < high) {
        var mid = floor((low + high) / 2),
            computed = iteratee(array[mid]),
            isReflexive = computed === computed;

        if (valIsNaN) {
          var setLow = isReflexive || retHighest;
        } else if (valIsUndef) {
          setLow = isReflexive && (retHighest || typeof computed != 'undefined');
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * A specialized version of `baseCallback` which only supports `this` binding
     * and specifying the number of arguments to provide to `func`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {number} [argCount] The number of arguments to provide to `func`.
     * @returns {Function} Returns the callback.
     */
    function bindCallback(func, thisArg, argCount) {
      if (typeof func != 'function') {
        return identity;
      }
      if (typeof thisArg == 'undefined') {
        return func;
      }
      switch (argCount) {
        case 1: return function(value) {
          return func.call(thisArg, value);
        };
        case 3: return function(value, index, collection) {
          return func.call(thisArg, value, index, collection);
        };
        case 4: return function(accumulator, value, index, collection) {
          return func.call(thisArg, accumulator, value, index, collection);
        };
        case 5: return function(value, other, key, object, source) {
          return func.call(thisArg, value, other, key, object, source);
        };
      }
      return function() {
        return func.apply(thisArg, arguments);
      };
    }

    /**
     * Creates a clone of the given array buffer.
     *
     * @private
     * @param {ArrayBuffer} buffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function bufferClone(buffer) {
      return bufferSlice.call(buffer, 0);
    }
    if (!bufferSlice) {
      // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
      bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
        var byteLength = buffer.byteLength,
            floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
            offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
            result = new ArrayBuffer(byteLength);

        if (floatLength) {
          var view = new Float64Array(result, 0, floatLength);
          view.set(new Float64Array(buffer, 0, floatLength));
        }
        if (byteLength != offset) {
          view = new Uint8Array(result, offset);
          view.set(new Uint8Array(buffer, offset));
        }
        return result;
      };
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders) {
      var holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          leftIndex = -1,
          leftLength = partials.length,
          result = Array(argsLength + leftLength);

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        result[holders[argsIndex]] = args[argsIndex];
      }
      while (argsLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array|Object} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders) {
      var holdersIndex = -1,
          holdersLength = holders.length,
          argsIndex = -1,
          argsLength = nativeMax(args.length - holdersLength, 0),
          rightIndex = -1,
          rightLength = partials.length,
          result = Array(argsLength + rightLength);

      while (++argsIndex < argsLength) {
        result[argsIndex] = args[argsIndex];
      }
      var pad = argsIndex;
      while (++rightIndex < rightLength) {
        result[pad + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        result[pad + holders[holdersIndex]] = args[argsIndex++];
      }
      return result;
    }

    /**
     * Creates a function that aggregates a collection, creating an accumulator
     * object composed from the results of running each element in the collection
     * through an iteratee.
     *
     * @private
     * @param {Function} setter The function to set keys and values of the accumulator object.
     * @param {Function} [initializer] The function to initialize the accumulator object.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee, thisArg) {
        var result = initializer ? initializer() : {};
        iteratee = getCallback(iteratee, thisArg, 3);

        if (isArray(collection)) {
          var index = -1,
              length = collection.length;

          while (++index < length) {
            var value = collection[index];
            setter(result, value, iteratee(value, index, collection), collection);
          }
        } else {
          baseEach(collection, function(value, key, collection) {
            setter(result, value, iteratee(value, key, collection), collection);
          });
        }
        return result;
      };
    }

    /**
     * Creates a function that assigns properties of source object(s) to a given
     * destination object.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return function() {
        var length = arguments.length,
            object = arguments[0];

        if (length < 2 || object == null) {
          return object;
        }
        if (length > 3 && isIterateeCall(arguments[1], arguments[2], arguments[3])) {
          length = 2;
        }
        // Juggle arguments.
        if (length > 3 && typeof arguments[length - 2] == 'function') {
          var customizer = bindCallback(arguments[--length - 1], arguments[length--], 5);
        } else if (length > 2 && typeof arguments[length - 1] == 'function') {
          customizer = arguments[--length];
        }
        var index = 0;
        while (++index < length) {
          var source = arguments[index];
          if (source) {
            assigner(object, source, customizer);
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with the `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new bound function.
     */
    function createBindWrapper(func, thisArg) {
      var Ctor = createCtorWrapper(func);

      function wrapper() {
        return (this instanceof wrapper ? Ctor : func).apply(thisArg, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a `Set` cache object to optimize linear searches of large arrays.
     *
     * @private
     * @param {Array} [values] The values to cache.
     * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
     */
    var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
      return new SetCache(values);
    };

    /**
     * Creates a function that produces compound words out of the words in a
     * given string.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        var index = -1,
            array = words(deburr(string)),
            length = array.length,
            result = '';

        while (++index < length) {
          result = callback(result, array[index], index);
        }
        return result;
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtorWrapper(Ctor) {
      return function() {
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, arguments);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that gets the extremum value of a collection.
     *
     * @private
     * @param {Function} arrayFunc The function to get the extremum value from an array.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the maximum,
     *  extremum value.
     * @returns {Function} Returns the new extremum function.
     */
    function createExtremum(arrayFunc, isMin) {
      return function(collection, iteratee, thisArg) {
        if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
          iteratee = null;
        }
        var func = getCallback(),
            noIteratee = iteratee == null;

        if (!(func === baseCallback && noIteratee)) {
          noIteratee = false;
          iteratee = func(iteratee, thisArg, 3);
        }
        if (noIteratee) {
          var isArr = isArray(collection);
          if (!isArr && isString(collection)) {
            iteratee = charAtCallback;
          } else {
            return arrayFunc(isArr ? collection : toIterable(collection));
          }
        }
        return extremumBy(collection, iteratee, isMin);
      };
    }

    /**
     * Creates a function that wraps `func` and invokes it with optional `this`
     * binding of, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & ARY_FLAG,
          isBind = bitmask & BIND_FLAG,
          isBindKey = bitmask & BIND_KEY_FLAG,
          isCurry = bitmask & CURRY_FLAG,
          isCurryBound = bitmask & CURRY_BOUND_FLAG,
          isCurryRight = bitmask & CURRY_RIGHT_FLAG;

      var Ctor = !isBindKey && createCtorWrapper(func),
          key = func;

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it to other functions.
        var length = arguments.length,
            index = length,
            args = Array(length);

        while (index--) {
          args[index] = arguments[index];
        }
        if (partials) {
          args = composeArgs(args, partials, holders);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight);
        }
        if (isCurry || isCurryRight) {
          var placeholder = wrapper.placeholder,
              argsHolders = replaceHolders(args, placeholder);

          length -= argsHolders.length;
          if (length < arity) {
            var newArgPos = argPos ? arrayCopy(argPos) : null,
                newArity = nativeMax(arity - length, 0),
                newsHolders = isCurry ? argsHolders : null,
                newHoldersRight = isCurry ? null : argsHolders,
                newPartials = isCurry ? args : null,
                newPartialsRight = isCurry ? null : args;

            bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
            bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

            if (!isCurryBound) {
              bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
            }
            var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
            result.placeholder = placeholder;
            return result;
          }
        }
        var thisBinding = isBind ? thisArg : this;
        if (isBindKey) {
          func = thisBinding[key];
        }
        if (argPos) {
          args = reorder(args, argPos);
        }
        if (isAry && ary < args.length) {
          args.length = ary;
        }
        return (this instanceof wrapper ? (Ctor || createCtorWrapper(func)) : func).apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates the pad required for `string` based on the given padding length.
     * The `chars` string may be truncated if the number of padding characters
     * exceeds the padding length.
     *
     * @private
     * @param {string} string The string to create padding for.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the pad for `string`.
     */
    function createPad(string, length, chars) {
      var strLength = string.length;
      length = +length;

      if (strLength >= length || !nativeIsFinite(length)) {
        return '';
      }
      var padLength = length - strLength;
      chars = chars == null ? ' ' : (chars + '');
      return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
    }

    /**
     * Creates a function that wraps `func` and invokes it with the optional `this`
     * binding of `thisArg` and the `partials` prepended to those provided to
     * the wrapper.
     *
     * @private
     * @param {Function} func The function to partially apply arguments to.
     * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to the new function.
     * @returns {Function} Returns the new bound function.
     */
    function createPartialWrapper(func, bitmask, thisArg, partials) {
      var isBind = bitmask & BIND_FLAG,
          Ctor = createCtorWrapper(func);

      function wrapper() {
        // Avoid `arguments` object use disqualifying optimizations by
        // converting it to an array before providing it `func`.
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(argsLength + leftLength);

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return (this instanceof wrapper ? Ctor : func).apply(isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of flags.
     *  The bitmask may be composed of the following flags:
     *     1 - `_.bind`
     *     2 - `_.bindKey`
     *     4 - `_.curry` or `_.curryRight` of a bound function
     *     8 - `_.curry`
     *    16 - `_.curryRight`
     *    32 - `_.partial`
     *    64 - `_.partialRight`
     *   128 - `_.rearg`
     *   256 - `_.ary`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
        partials = holders = null;
      }
      length -= (holders ? holders.length : 0);
      if (bitmask & PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = null;
      }
      var data = !isBindKey && getData(func),
          newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

      if (data && data !== true) {
        mergeData(newData, data);
        bitmask = newData[1];
        arity = newData[9];
      }
      newData[9] = arity == null
        ? (isBindKey ? 0 : func.length)
        : (nativeMax(arity - length, 0) || 0);

      if (bitmask == BIND_FLAG) {
        var result = createBindWrapper(newData[0], newData[2]);
      } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
        result = createPartialWrapper.apply(undefined, newData);
      } else {
        result = createHybridWrapper.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setter(result, newData);
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing arrays.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var index = -1,
          arrLength = array.length,
          othLength = other.length,
          result = true;

      if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
        return false;
      }
      // Deep compare the contents, ignoring non-numeric properties.
      while (result && ++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        result = undefined;
        if (customizer) {
          result = isWhere
            ? customizer(othValue, arrValue, index)
            : customizer(arrValue, othValue, index);
        }
        if (typeof result == 'undefined') {
          // Recursively compare arrays (susceptible to call stack limits).
          if (isWhere) {
            var othIndex = othLength;
            while (othIndex--) {
              othValue = other[othIndex];
              result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
              if (result) {
                break;
              }
            }
          } else {
            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
          }
        }
      }
      return !!result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} value The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag) {
      switch (tag) {
        case boolTag:
        case dateTag:
          // Coerce dates and booleans to numbers, dates to milliseconds and booleans
          // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
          return +object == +other;

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case numberTag:
          // Treat `NaN` vs. `NaN` as equal.
          return (object != +object)
            ? other != +other
            // But, treat `-0` vs. `+0` as not equal.
            : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings primitives and string
          // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
          return object == (other + '');
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {boolean} [isWhere] Specify performing partial comparisons.
     * @param {Array} [stackA] Tracks traversed `value` objects.
     * @param {Array} [stackB] Tracks traversed `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
      var objProps = keys(object),
          objLength = objProps.length,
          othProps = keys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isWhere) {
        return false;
      }
      var hasCtor,
          index = -1;

      while (++index < objLength) {
        var key = objProps[index],
            result = hasOwnProperty.call(other, key);

        if (result) {
          var objValue = object[key],
              othValue = other[key];

          result = undefined;
          if (customizer) {
            result = isWhere
              ? customizer(othValue, objValue, key)
              : customizer(objValue, othValue, key);
          }
          if (typeof result == 'undefined') {
            // Recursively compare objects (susceptible to call stack limits).
            result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
          }
        }
        if (!result) {
          return false;
        }
        hasCtor || (hasCtor = key == 'constructor');
      }
      if (!hasCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Gets the extremum value of `collection` invoking `iteratee` for each value
     * in `collection` to generate the criterion by which the value is ranked.
     * The `iteratee` is invoked with three arguments; (value, index, collection).
     *
     * @private
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {boolean} [isMin] Specify returning the minimum, instead of the
     *  maximum, extremum value.
     * @returns {*} Returns the extremum value.
     */
    function extremumBy(collection, iteratee, isMin) {
      var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY,
          computed = exValue,
          result = computed;

      baseEach(collection, function(value, index, collection) {
        var current = iteratee(value, index, collection);
        if ((isMin ? current < computed : current > computed) || (current === exValue && current === result)) {
          computed = current;
          result = value;
        }
      });
      return result;
    }

    /**
     * Gets the appropriate "callback" function. If the `_.callback` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseCallback` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function} Returns the chosen function or its result.
     */
    function getCallback(func, thisArg, argCount) {
      var result = lodash.callback || callback;
      result = result === callback ? baseCallback : result;
      return argCount ? result(func, thisArg, argCount) : result;
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized this function returns the custom method, otherwise it returns
     * the `baseIndexOf` function. If arguments are provided the chosen function
     * is invoked with them and its result is returned.
     *
     * @private
     * @returns {Function|number} Returns the chosen function or its result.
     */
    function getIndexOf(collection, target, fromIndex) {
      var result = lodash.indexOf || indexOf;
      result = result === indexOf ? baseIndexOf : result;
      return collection ? result(collection, target, fromIndex) : result;
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} [transforms] The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms ? transforms.length : 0;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add array properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      var Ctor = object.constructor;
      if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
        Ctor = Object;
      }
      return new Ctor;
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return bufferClone(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          // Safari 5 mobile incorrectly has `Object` as the constructor of typed arrays.
          if (Ctor instanceof Ctor) {
            Ctor = ctorByTag[tag];
          }
          var buffer = object.buffer;
          return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          var result = new Ctor(object.source, reFlags.exec(object));
          result.lastIndex = object.lastIndex;
      }
      return result;
    }

    /**
     * Checks if `func` is eligible for `this` binding.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
     */
    function isBindable(func) {
      var support = lodash.support,
          result = !(support.funcNames ? func.name : support.funcDecomp);

      if (!result) {
        var source = fnToString.call(func);
        if (!support.funcNames) {
          result = !reFuncName.test(source);
        }
        if (!result) {
          // Check if `func` references the `this` keyword and store the result.
          result = reThis.test(source) || isNative(func);
          baseSetData(func, result);
        }
      }
      return result;
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      value = +value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return value > -1 && value % 1 == 0 && value < length;
    }

    /**
     * Checks if the provided arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number') {
        var length = object.length,
            prereq = isLength(length) && isIndex(index, length);
      } else {
        prereq = type == 'string' && index in object;
      }
      if (prereq) {
        var other = object[index];
        return value === value ? value === other : other !== other;
      }
      return false;
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This function is based on ES `ToLength`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
     * for more details.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     */
    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers required to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
     * augment function arguments, making the order in which they are executed important,
     * preventing the merging of metadata. However, we make an exception for a safe
     * common case where curried functions have `_.ary` and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask;

      var arityFlags = ARY_FLAG | REARG_FLAG,
          bindFlags = BIND_FLAG | BIND_KEY_FLAG,
          comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

      var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
          isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
          argPos = (isRearg ? data : source)[7],
          ary = (isAry ? data : source)[8];

      var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
        !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

      var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
        (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = arrayCopy(value);
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties specified
     * by the `props` array.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} props The property names to pick.
     * @returns {Object} Returns the new object.
     */
    function pickByArray(object, props) {
      object = toObject(object);

      var index = -1,
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.pick` that picks `object` properties `predicate`
     * returns truthy for.
     *
     * @private
     * @param {Object} object The source object.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Object} Returns the new object.
     */
    function pickByCallback(object, predicate) {
      var result = {};
      baseForIn(object, function(value, key, object) {
        if (predicate(value, key, object)) {
          result[key] = value;
        }
      });
      return result;
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = arrayCopy(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity function
     * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = (function() {
      var count = 0,
          lastCalled = 0;

      return function(key, value) {
        var stamp = now(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return key;
          }
        } else {
          count = 0;
        }
        return baseSetData(key, value);
      };
    }());

    /**
     * A fallback implementation of `_.isPlainObject` which checks if `value`
     * is an object created by the `Object` constructor or has a `[[Prototype]]`
     * of `null`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
    function shimIsPlainObject(value) {
      var Ctor,
          support = lodash.support;

      // Exit early for non `Object` objects.
      if (!(isObjectLike(value) && objToString.call(value) == objectTag && !isHostObject(value)) ||
          (!hasOwnProperty.call(value, 'constructor') &&
            (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor))) ||
          (!support.argsTag && isArguments(value))) {
        return false;
      }
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      var result;
      if (support.ownLast) {
        baseForIn(value, function(subValue, key, object) {
          result = hasOwnProperty.call(object, key);
          return false;
        });
        return result !== false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      baseForIn(value, function(subValue, key) {
        result = key;
      });
      return typeof result == 'undefined' || hasOwnProperty.call(value, result);
    }

    /**
     * A fallback implementation of `Object.keys` which creates an array of the
     * own enumerable property names of `object`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     */
    function shimKeys(object) {
      var props = keysIn(object),
          propsLength = props.length,
          length = propsLength && object.length,
          support = lodash.support;

      var allowIndexes = length && isLength(length) &&
        (isArray(object) || (support.nonEnumStrings && isString(object)) ||
          (support.nonEnumArgs && isArguments(object)));

      var index = -1,
          result = [];

      while (++index < propsLength) {
        var key = props[index];
        if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to an array-like object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Array|Object} Returns the array-like object.
     */
    function toIterable(value) {
      if (value == null) {
        return [];
      }
      if (!isLength(value.length)) {
        return values(value);
      }
      if (lodash.support.unindexedChars && isString(value)) {
        return value.split('');
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Converts `value` to an object if it is not one.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {Object} Returns the object.
     */
    function toObject(value) {
      if (lodash.support.unindexedChars && isString(value)) {
        var index = -1,
            length = value.length,
            result = Object(value);

        while (++index < length) {
          result[index] = value.charAt(index);
        }
        return result;
      }
      return isObject(value) ? value : Object(value);
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      return wrapper instanceof LazyWrapper
        ? wrapper.clone()
        : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `collection` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new array containing chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if (guard ? isIterateeCall(array, size, guard) : size == null) {
        size = 1;
      } else {
        size = nativeMax(+size || 1, 1);
      }
      var index = 0,
          length = array ? array.length : 0,
          resIndex = -1,
          result = Array(ceil(length / size));

      while (index < length) {
        result[++resIndex] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array ? array.length : 0,
          resIndex = -1,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[++resIndex] = value;
        }
      }
      return result;
    }

    /**
     * Creates an array excluding all values of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The arrays of values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3], [4, 2]);
     * // => [1, 3]
     */
    function difference() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var value = arguments[index];
        if (isArray(value) || isArguments(value)) {
          break;
        }
      }
      return baseDifference(value, baseFlatten(arguments, false, true, ++index));
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that match the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [1]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropRightWhile(users, { 'user': pebbles, 'active': false }), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active', false), 'user');
     * // => ['barney']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropRightWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      predicate = getCallback(predicate, thisArg, 3);
      while (length-- && predicate(array[length], length, array)) {}
      return baseSlice(array, 0, length + 1);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.dropWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.dropWhile(users, 'active', false), 'user');
     * // => ['pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.dropWhile(users, 'active'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var index = -1;
      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length && predicate(array[index], index, array)) {}
      return baseSlice(array, index);
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function fill(array, value, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(chr) {
     *   return chr.user == 'barney';
     * });
     * // => 0
     *
     * // using the `_.matches` callback shorthand
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findIndex(users, 'active', false);
     * // => 0
     *
     * // using the `_.property` callback shorthand
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, thisArg) {
      var index = -1,
          length = array ? array.length : 0;

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(chr) {
     *   return chr.user == 'pebbles';
     * });
     * // => 2
     *
     * // using the `_.matches` callback shorthand
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastIndex(users, 'active', false);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      predicate = getCallback(predicate, thisArg, 3);
      while (length--) {
        if (predicate(array[length], length, array)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias head
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([]);
     * // => undefined
     */
    function first(array) {
      return array ? array[0] : undefined;
    }

    /**
     * Flattens a nested array. If `isDeep` is `true` the array is recursively
     * flattened, otherwise it is only flattened a single level.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {boolean} [isDeep] Specify a deep flatten.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, 3, [4]]]);
     * // => [1, 2, 3, [4]];
     *
     * // using `isDeep`
     * _.flatten([1, [2, 3, [4]]], true);
     * // => [1, 2, 3, 4];
     */
    function flatten(array, isDeep, guard) {
      var length = array ? array.length : 0;
      if (guard && isIterateeCall(array, isDeep, guard)) {
        isDeep = false;
      }
      return length ? baseFlatten(array, isDeep) : [];
    }

    /**
     * Recursively flattens a nested array.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to recursively flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, 3, [4]]]);
     * // => [1, 2, 3, 4];
     */
    function flattenDeep(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, true) : [];
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
     * it is used as the offset from the end of `array`. If `array` is sorted
     * providing `true` for `fromIndex` performs a faster binary search.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // using `fromIndex`
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     *
     * // performing a binary search
     * _.indexOf([1, 1, 2, 2], 2, true);
     * // => 2
     */
    function indexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      } else if (fromIndex) {
        var index = binaryIndex(array, value),
            other = array[index];

        return (value === value ? value === other : other !== other) ? index : -1;
      }
      return baseIndexOf(array, value, fromIndex);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      return dropRight(array, 1);
    }

    /**
     * Creates an array of unique values in all provided arrays using `SameValueZero`
     * for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of shared values.
     * @example
     * _.intersection([1, 2], [4, 2], [2, 1]);
     * // => [2]
     */
    function intersection() {
      var args = [],
          argsIndex = -1,
          argsLength = arguments.length,
          caches = [],
          indexOf = getIndexOf(),
          isCommon = indexOf == baseIndexOf;

      while (++argsIndex < argsLength) {
        var value = arguments[argsIndex];
        if (isArray(value) || isArguments(value)) {
          args.push(value);
          caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
        }
      }
      argsLength = args.length;
      var array = args[0],
          index = -1,
          length = array ? array.length : 0,
          result = [],
          seen = caches[0];

      outer:
      while (++index < length) {
        value = array[index];
        if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value)) < 0) {
          argsIndex = argsLength;
          while (--argsIndex) {
            var cache = caches[argsIndex];
            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(value);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array ? array.length : 0;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=array.length-1] The index to search from
     *  or `true` to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // using `fromIndex`
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     *
     * // performing a binary search
     * _.lastIndexOf([1, 1, 2, 2], 2, true);
     * // => 3
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array ? array.length : 0;
      if (!length) {
        return -1;
      }
      var index = length;
      if (typeof fromIndex == 'number') {
        index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
      } else if (fromIndex) {
        index = binaryIndex(array, value, true) - 1;
        var other = array[index];
        return (value === value ? value === other : other !== other) ? index : -1;
      }
      if (value !== value) {
        return indexOfNaN(array, index, true);
      }
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }

    /**
     * Removes all provided values from `array` using `SameValueZero` for equality
     * comparisons.
     *
     * **Notes:**
     *  - Unlike `_.without`, this method mutates `array`.
     *  - `SameValueZero` comparisons are like strict equality comparisons, e.g. `===`,
     *    except that `NaN` matches `NaN`. See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     *    for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     *
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
    function pull() {
      var array = arguments[0];
      if (!(array && array.length)) {
        return array;
      }
      var index = 0,
          indexOf = getIndexOf(),
          length = arguments.length;

      while (++index < length) {
        var fromIndex = 0,
            value = arguments[index];

        while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * Removes elements from `array` corresponding to the given indexes and returns
     * an array of the removed elements. Indexes may be specified as an array of
     * indexes or as individual arguments.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [5, 10, 15, 20];
     * var evens = _.pullAt(array, 1, 3);
     *
     * console.log(array);
     * // => [5, 15]
     *
     * console.log(evens);
     * // => [10, 20]
     */
    function pullAt(array) {
      return basePullAt(array || [], baseFlatten(arguments, false, false, 1));
    }

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate, thisArg) {
      var index = -1,
          length = array ? array.length : 0,
          result = [];

      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          splice.call(array, index--, 1);
          length--;
        }
      }
      return result;
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @alias tail
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     */
    function rest(array) {
      return drop(array, 1);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This function is used instead of `Array#slice` to support node
     * lists in IE < 9 and to ensure dense arrays are returned.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value` should
     * be inserted into `array` in order to maintain its sort order. If an iteratee
     * function is provided it is invoked for `value` and each element of `array`
     * to compute their sort ranking. The iteratee is bound to `thisArg` and
     * invoked with one argument; (value).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     *
     * _.sortedIndex([4, 4, 5, 5], 5);
     * // => 2
     *
     * var dict = { 'data': { 'thirty': 30, 'forty': 40, 'fifty': 50 } };
     *
     * // using an iteratee function
     * _.sortedIndex(['thirty', 'fifty'], 'forty', function(word) {
     *   return this.data[word];
     * }, dict);
     * // => 1
     *
     * // using the `_.property` callback shorthand
     * _.sortedIndex([{ 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 1
     */
    function sortedIndex(array, value, iteratee, thisArg) {
      var func = getCallback(iteratee);
      return (func === baseCallback && iteratee == null)
        ? binaryIndex(array, value)
        : binaryIndexBy(array, value, func(iteratee, thisArg, 1));
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 4, 5, 5], 5);
     * // => 4
     */
    function sortedLastIndex(array, value, iteratee, thisArg) {
      var func = getCallback(iteratee);
      return (func === baseCallback && iteratee == null)
        ? binaryIndex(array, value, true)
        : binaryIndexBy(array, value, func(iteratee, thisArg, 1), true);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (guard ? isIterateeCall(array, n, guard) : n == null) {
        n = 1;
      }
      n = length - (+n || 0);
      return baseSlice(array, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRightWhile([1, 2, 3], function(n) {
     *   return n > 1;
     * });
     * // => [2, 3]
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeRightWhile(users, { 'user': 'pebbles', 'active': false }), 'user');
     * // => ['pebbles']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active', false), 'user');
     * // => ['fred', 'pebbles']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeRightWhile(users, 'active'), 'user');
     * // => []
     */
    function takeRightWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      predicate = getCallback(predicate, thisArg, 3);
      while (length-- && predicate(array[length], length, array)) {}
      return baseSlice(array, length + 1);
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is bound to
     * `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeWhile([1, 2, 3], function(n) {
     *   return n < 3;
     * });
     * // => [1, 2]
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false},
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.takeWhile(users, { 'user': 'barney', 'active': false }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.takeWhile(users, 'active', false), 'user');
     * // => ['barney', 'fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.takeWhile(users, 'active'), 'user');
     * // => []
     */
    function takeWhile(array, predicate, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      var index = -1;
      predicate = getCallback(predicate, thisArg, 3);
      while (++index < length && predicate(array[index], index, array)) {}
      return baseSlice(array, 0, index);
    }

    /**
     * Creates an array of unique values, in order, of the provided arrays using
     * `SameValueZero` for equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([1, 2], [4, 2], [2, 1]);
     * // => [1, 2, 4]
     */
    function union() {
      return baseUniq(baseFlatten(arguments, false, true));
    }

    /**
     * Creates a duplicate-value-free version of an array using `SameValueZero`
     * for equality comparisons. Providing `true` for `isSorted` performs a faster
     * search algorithm for sorted arrays. If an iteratee function is provided it
     * is invoked for each value in the array to generate the criterion by which
     * uniqueness is computed. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {boolean} [isSorted] Specify the array is sorted.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1]);
     * // => [1, 2]
     *
     * // using `isSorted`
     * _.uniq([1, 1, 2], true);
     * // => [1, 2]
     *
     * // using an iteratee function
     * _.uniq([1, 2.5, 1.5, 2], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => [1, 2.5]
     *
     * // using the `_.property` callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniq(array, isSorted, iteratee, thisArg) {
      var length = array ? array.length : 0;
      if (!length) {
        return [];
      }
      if (isSorted != null && typeof isSorted != 'boolean') {
        thisArg = iteratee;
        iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
        isSorted = false;
      }
      var func = getCallback();
      if (!(func === baseCallback && iteratee == null)) {
        iteratee = func(iteratee, thisArg, 3);
      }
      return (isSorted && getIndexOf() == baseIndexOf)
        ? sortedUniq(array, iteratee)
        : baseUniq(array, iteratee);
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-`_.zip`
     * configuration.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     *
     * _.unzip(zipped);
     * // => [['fred', 'barney'], [30, 40], [true, false]]
     */
    function unzip(array) {
      var index = -1,
          length = (array && array.length && arrayMax(arrayMap(array, getLength))) >>> 0,
          result = Array(length);

      while (++index < length) {
        result[index] = arrayMap(array, baseProperty(index));
      }
      return result;
    }

    /**
     * Creates an array excluding all provided values using `SameValueZero` for
     * equality comparisons.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {Array} array The array to filter.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 3], 1, 2);
     * // => [3]
     */
    function without(array) {
      return baseDifference(array, baseSlice(arguments, 1));
    }

    /**
     * Creates an array that is the symmetric difference of the provided arrays.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Symmetric_difference) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of values.
     * @example
     *
     * _.xor([1, 2], [4, 2]);
     * // => [1, 4]
     */
    function xor() {
      var index = -1,
          length = arguments.length;

      while (++index < length) {
        var array = arguments[index];
        if (isArray(array) || isArguments(array)) {
          var result = result
            ? baseDifference(result, array).concat(baseDifference(array, result))
            : array;
        }
      }
      return result ? baseUniq(result) : [];
    }

    /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second elements
     * of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['fred', 'barney'], [30, 40], [true, false]);
     * // => [['fred', 30, true], ['barney', 40, false]]
     */
    function zip() {
      var length = arguments.length,
          array = Array(length);

      while (length--) {
        array[length] = arguments[length];
      }
      return unzip(array);
    }

    /**
     * Creates an object composed from arrays of property names and values. Provide
     * either a single two dimensional array, e.g. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of property names and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Array
     * @param {Array} props The property names.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['fred', 'barney'], [30, 40]);
     * // => { 'fred': 30, 'barney': 40 }
     */
    function zipObject(props, values) {
      var index = -1,
          length = props ? props.length : 0,
          result = {};

      if (length && !values && !isArray(props[0])) {
        values = [];
      }
      while (++index < length) {
        var key = props[index];
        if (values) {
          result[key] = values[index];
        } else if (key) {
          result[key[0]] = key[1];
        }
      }
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object that wraps `value` with explicit method
     * chaining enabled.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _.chain(users)
     *   .sortBy('age')
     *   .map(function(chr) {
     *     return chr.user + ' is ' + chr.age;
     *   })
     *   .first()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor is
     * bound to `thisArg` and invoked with one argument; (value). The purpose of
     * this method is to "tap into" a method chain in order to perform operations
     * on intermediate results within the chain.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor, thisArg) {
      interceptor.call(thisArg, value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     *
     * @static
     * @memberOf _
     * @category Chain
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @param {*} [thisArg] The `this` binding of `interceptor`.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _([1, 2, 3])
     *  .last()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => [3]
     */
    function thru(value, interceptor, thisArg) {
      return interceptor.call(thisArg, value);
    }

    /**
     * Enables explicit method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // without explicit chaining
     * _(users).first();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // with explicit chaining
     * _(users).chain()
     *   .first()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chained sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapper = wrapper.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapper.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Creates a clone of the chained sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapper = _(array).map(function(value) {
     *   return Math.pow(value, 2);
     * });
     *
     * var other = [3, 4];
     * var otherWrapper = wrapper.plant(other);
     *
     * otherWrapper.value();
     * // => [9, 16]
     *
     * wrapper.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * Reverses the wrapped array so the first element becomes the last, the
     * second element becomes the second to last, and so on.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @category Chain
     * @returns {Object} Returns the new reversed `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        if (this.__actions__.length) {
          value = new LazyWrapper(this);
        }
        return new LodashWrapper(value.reverse(), this.__chain__);
      }
      return this.thru(function(value) {
        return value.reverse();
      });
    }

    /**
     * Produces the result of coercing the unwrapped value to a string.
     *
     * @name toString
     * @memberOf _
     * @category Chain
     * @returns {string} Returns the coerced string value.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
    function wrapperToString() {
      return (this.value() + '');
    }

    /**
     * Executes the chained sequence to extract the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @alias run, toJSON, valueOf
     * @category Chain
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements corresponding to the given keys, or indexes,
     * of `collection`. Keys may be specified as individual arguments or as arrays
     * of keys.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [props] The property names
     *  or indexes of elements to pick, specified individually or in arrays.
     * @returns {Array} Returns the new array of picked elements.
     * @example
     *
     * _.at(['a', 'b', 'c'], [0, 2]);
     * // => ['a', 'c']
     *
     * _.at(['fred', 'barney', 'pebbles'], 0, 2);
     * // => ['fred', 'pebbles']
     */
    function at(collection) {
      var length = collection ? collection.length : 0;
      if (isLength(length)) {
        collection = toIterable(collection);
      }
      return baseAt(collection, baseFlatten(arguments, false, false, 1));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the number of times the key was returned by `iteratee`.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy([4.3, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': 1, '6': 2 }
     *
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      hasOwnProperty.call(result, key) ? ++result[key] : (result[key] = 1);
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * The predicate is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'active': false },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.every(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.filter([4, 5, 6], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [4, 6]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.filter(users, { 'age': 36, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.filter(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.filter(users, 'active'), 'user');
     * // => ['barney']
     */
    function filter(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, predicate);
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.result(_.find(users, function(chr) {
     *   return chr.age < 40;
     * }), 'user');
     * // => 'barney'
     *
     * // using the `_.matches` callback shorthand
     * _.result(_.find(users, { 'age': 1, 'active': true }), 'user');
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.result(_.find(users, 'active', false), 'user');
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.result(_.find(users, 'active'), 'user');
     * // => 'barney'
     */
    function find(collection, predicate, thisArg) {
      if (isArray(collection)) {
        var index = findIndex(collection, predicate, thisArg);
        return index > -1 ? collection[index] : undefined;
      }
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(collection, predicate, baseEach);
    }

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    function findLast(collection, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(collection, predicate, baseEachRight);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning the first element that has equivalent property
     * values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.result(_.findWhere(users, { 'age': 36, 'active': true }), 'user');
     * // => 'barney'
     *
     * _.result(_.findWhere(users, { 'age': 40, 'active': false }), 'user');
     * // => 'fred'
     */
    function findWhere(collection, source) {
      return find(collection, baseMatches(source));
    }

    /**
     * Iterates over elements of `collection` invoking `iteratee` for each element.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Iterator functions may exit iteration early
     * by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a `length` property
     * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
     * may be used for object iteration.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEach(function(n) {
     *   console.log(n);
     * }).value();
     * // => logs each value from left to right and returns the array
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
     *   console.log(n, key);
     * });
     * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
     */
    function forEach(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
        ? arrayEach(collection, iteratee)
        : baseEach(collection, bindCallback(iteratee, thisArg, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2]).forEachRight(function(n) {
     *   console.log(n);
     * }).join(',');
     * // => logs each value from right to left and returns the array
     */
    function forEachRight(collection, iteratee, thisArg) {
      return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
        ? arrayEachRight(collection, iteratee)
        : baseEachRight(collection, bindCallback(iteratee, thisArg, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is an array of the elements responsible for generating the key.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return Math.floor(n);
     * });
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * _.groupBy([4.2, 6.1, 6.4], function(n) {
     *   return this.floor(n);
     * }, Math);
     * // => { '4': [4.2], '6': [6.1, 6.4] }
     *
     * // using the `_.property` callback shorthand
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });

    /**
     * Checks if `value` is in `collection` using `SameValueZero` for equality
     * comparisons. If `fromIndex` is negative, it is used as the offset from
     * the end of `collection`.
     *
     * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
     * e.g. `===`, except that `NaN` matches `NaN`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
     * for more details.
     *
     * @static
     * @memberOf _
     * @alias contains, include
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {*} target The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if a matching element is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'user': 'fred', 'age': 40 }, 'fred');
     * // => true
     *
     * _.includes('pebbles', 'eb');
     * // => true
     */
    function includes(collection, target, fromIndex) {
      var length = collection ? collection.length : 0;
      if (!isLength(length)) {
        collection = values(collection);
        length = collection.length;
      }
      if (!length) {
        return false;
      }
      if (typeof fromIndex == 'number') {
        fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : (fromIndex || 0);
      } else {
        fromIndex = 0;
      }
      return (typeof collection == 'string' || !isArray(collection) && isString(collection))
        ? (fromIndex < length && collection.indexOf(target, fromIndex) > -1)
        : (getIndexOf(collection, target, fromIndex) > -1);
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` through `iteratee`. The corresponding value
     * of each key is the last element responsible for generating the key. The
     * iteratee function is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var keyData = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.indexBy(keyData, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return String.fromCharCode(object.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.indexBy(keyData, function(object) {
     *   return this.fromCharCode(object.code);
     * }, String);
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     */
    var indexBy = createAggregator(function(result, value, key) {
      result[key] = value;
    });

    /**
     * Invokes the method named by `methodName` on each element in `collection`,
     * returning an array of the results of each invoked method. Any additional
     * arguments are provided to each invoked method. If `methodName` is a function
     * it is invoked for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    function invoke(collection, methodName) {
      return baseInvoke(collection, methodName, baseSlice(arguments, 2));
    }

    /**
     * Creates an array of values by running each element in `collection` through
     * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
     * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
     * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
     * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     *  create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function timesThree(n) {
     *   return n * 3;
     * }
     *
     * _.map([1, 2], timesThree);
     * // => [3, 6]
     *
     * _.map({ 'a': 1, 'b': 2 }, timesThree);
     * // => [3, 6] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee, thisArg) {
      var func = isArray(collection) ? arrayMap : baseMap;
      iteratee = getCallback(iteratee, thisArg, 3);
      return func(collection, iteratee);
    }

    /**
     * Gets the maximum value of `collection`. If `collection` is empty or falsey
     * `-Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => -Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.max(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'fred', 'age': 40 };
     *
     * // using the `_.property` callback shorthand
     * _.max(users, 'age');
     * // => { 'user': 'fred', 'age': 40 };
     */
    var max = createExtremum(arrayMax);

    /**
     * Gets the minimum value of `collection`. If `collection` is empty or falsey
     * `Infinity` is returned. If an iteratee function is provided it is invoked
     * for each value in `collection` to generate the criterion by which the value
     * is ranked. The `iteratee` is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [iteratee] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => Infinity
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.min(users, function(chr) {
     *   return chr.age;
     * });
     * // => { 'user': 'barney', 'age': 36 };
     *
     * // using the `_.property` callback shorthand
     * _.min(users, 'age');
     * // => { 'user': 'barney', 'age': 36 };
     */
    var min = createExtremum(arrayMin, true);

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, while the second of which
     * contains elements `predicate` returns falsey for. The predicate is bound
     * to `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * _.partition([1, 2, 3], function(n) {
     *   return n % 2;
     * });
     * // => [[1, 3], [2]]
     *
     * _.partition([1.2, 2.3, 3.4], function(n) {
     *   return this.floor(n) % 2;
     * }, Math);
     * // => [[1, 3], [2]]
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * var mapper = function(array) {
     *   return _.pluck(array, 'user');
     * };
     *
     * // using the `_.matches` callback shorthand
     * _.map(_.partition(users, { 'age': 1, 'active': false }), mapper);
     * // => [['pebbles'], ['barney', 'fred']]
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.map(_.partition(users, 'active', false), mapper);
     * // => [['barney', 'pebbles'], ['fred']]
     *
     * // using the `_.property` callback shorthand
     * _.map(_.partition(users, 'active'), mapper);
     * // => [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Gets the value of `key` from all elements in `collection`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {string} key The key of the property to pluck.
     * @returns {Array} Returns the property values.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * _.pluck(users, 'user');
     * // => ['barney', 'fred']
     *
     * var userIndex = _.indexBy(users, 'user');
     * _.pluck(userIndex, 'age');
     * // => [36, 40] (iteration order is not guaranteed)
     */
    function pluck(collection, key) {
      return map(collection, baseProperty(key));
    }

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` through `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not provided the first element of `collection` is used as the initial
     * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as interatees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `merge`, and `sortAllBy`
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * });
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator, thisArg) {
      var func = isArray(collection) ? arrayReduce : baseReduce;
      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator, thisArg) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce;
      return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * _.reject([1, 2, 3, 4], function(n) {
     *   return n % 2 == 0;
     * });
     * // => [1, 3]
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.pluck(_.reject(users, { 'age': 40, 'active': true }), 'user');
     * // => ['barney']
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.pluck(_.reject(users, 'active', false), 'user');
     * // => ['fred']
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.reject(users, 'active'), 'user');
     * // => ['barney']
     */
    function reject(collection, predicate, thisArg) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      predicate = getCallback(predicate, thisArg, 3);
      return func(collection, function(value, index, collection) {
        return !predicate(value, index, collection);
      });
    }

    /**
     * Gets a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {*} Returns the random sample(s).
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
    function sample(collection, n, guard) {
      if (guard ? isIterateeCall(collection, n, guard) : n == null) {
        collection = toIterable(collection);
        var length = collection.length;
        return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
      }
      var result = shuffle(collection);
      result.length = nativeMin(n < 0 ? 0 : (+n || 0), result.length);
      return result;
    }

    /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See [Wikipedia](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      collection = toIterable(collection);

      var index = -1,
          length = collection.length,
          result = Array(length);

      while (++index < length) {
        var rand = baseRandom(0, index);
        if (index != rand) {
          result[index] = result[rand];
        }
        result[rand] = collection[index];
      }
      return result;
    }

    /**
     * Gets the size of `collection` by returning `collection.length` for
     * array-like values or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the size of `collection`.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      var length = collection ? collection.length : 0;
      return isLength(length) ? length : keys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * The function returns as soon as it finds a passing value and does not iterate
     * over the entire collection. The predicate is bound to `thisArg` and invoked
     * with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // using the `_.matches` callback shorthand
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.some(users, 'active', false);
     * // => true
     *
     * // using the `_.property` callback shorthand
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, thisArg) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
        predicate = getCallback(predicate, thisArg, 3);
      }
      return func(collection, predicate);
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through `iteratee`. This method performs
     * a stable sort, that is, it preserves the original sort order of equal elements.
     * The `iteratee` is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection).
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Array|Function|Object|string} [iteratee=_.identity] The function
     *  invoked per iteration. If a property name or an object is provided it is
     *  used to create a `_.property` or `_.matches` style callback respectively.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return Math.sin(n);
     * });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(n) {
     *   return this.sin(n);
     * }, Math);
     * // => [3, 1, 2]
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' },
     *   { 'user': 'barney' }
     * ];
     *
     * // using the `_.property` callback shorthand
     * _.pluck(_.sortBy(users, 'user'), 'user');
     * // => ['barney', 'fred', 'pebbles']
     */
    function sortBy(collection, iteratee, thisArg) {
      var index = -1,
          length = collection ? collection.length : 0,
          result = isLength(length) ? Array(length) : [];

      if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
        iteratee = null;
      }
      iteratee = getCallback(iteratee, thisArg, 3);
      baseEach(collection, function(value, key, collection) {
        result[++index] = { 'criteria': iteratee(value, key, collection), 'index': index, 'value': value };
      });
      return baseSortBy(result, compareAscending);
    }

    /**
     * This method is like `_.sortBy` except that it sorts by property names
     * instead of an iteratee function.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(string|string[])} props The property names to sort by,
     *  specified as individual property names or arrays of property names.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 26 },
     *   { 'user': 'fred',   'age': 30 }
     * ];
     *
     * _.map(_.sortByAll(users, ['user', 'age']), _.values);
     * // => [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
     */
    function sortByAll(collection) {
      var args = arguments;
      if (args.length > 3 && isIterateeCall(args[1], args[2], args[3])) {
        args = [collection, args[1]];
      }
      var index = -1,
          length = collection ? collection.length : 0,
          props = baseFlatten(args, false, false, 1),
          result = isLength(length) ? Array(length) : [];

      baseEach(collection, function(value) {
        var length = props.length,
            criteria = Array(length);

        while (length--) {
          criteria[length] = value == null ? undefined : value[props[length]];
        }
        result[++index] = { 'criteria': criteria, 'index': index, 'value': value };
      });
      return baseSortBy(result, compareMultipleAscending);
    }

    /**
     * Performs a deep comparison between each element in `collection` and the
     * source object, returning an array of all elements that have equivalent
     * property values.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Collection
     * @param {Array|Object|string} collection The collection to search.
     * @param {Object} source The object of property values to match.
     * @returns {Array} Returns the new filtered array.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy'] },
     *   { 'user': 'fred',   'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }
     * ];
     *
     * _.pluck(_.where(users, { 'age': 36, 'active': false }), 'user');
     * // => ['barney']
     *
     * _.pluck(_.where(users, { 'pets': ['dino'] }), 'user');
     * // => ['fred']
     */
    function where(collection, source) {
      return filter(collection, baseMatches(source));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Gets the number of milliseconds that have elapsed since the Unix epoch
     * (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @category Date
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => logs the number of milliseconds it took for the deferred function to be invoked
     */
    var now = nativeNow || function() {
      return new Date().getTime();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it is called `n` or more times.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'done saving!' after the two async saves have completed
     */
    function after(n, func) {
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      n = nativeIsFinite(n = +n) ? n : 0;
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that accepts up to `n` arguments ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      if (guard && isIterateeCall(func, n, guard)) {
        n = null;
      }
      n = (func && n == null) ? func.length : nativeMax(+n || 0, 0);
      return createWrapper(func, ARY_FLAG, null, null, null, null, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it is called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery('#add').on('click', _.before(5, addContactToList));
     * // => allows adding up to 4 contacts to the list
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        if (typeof n == 'function') {
          var temp = n;
          n = func;
          func = temp;
        } else {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
      }
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        } else {
          func = null;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and prepends any additional `_.bind` arguments to those provided to the
     * bound function.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind` this method does not set the `length`
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var greet = function(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * };
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // using placeholders
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    function bind(func, thisArg) {
      var bitmask = BIND_FLAG;
      if (arguments.length > 2) {
        var partials = baseSlice(arguments, 2),
            holders = replaceHolders(partials, bind.placeholder);

        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(func, bitmask, thisArg, partials, holders);
    }

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all enumerable function
     * properties, own and inherited, of `object` are bound.
     *
     * **Note:** This method does not set the `length` property of bound functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} [methodNames] The object method names to bind,
     *  specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'onClick': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs' when the element is clicked
     */
    function bindAll(object) {
      return baseBindAll(object,
        arguments.length > 1
          ? baseFlatten(arguments, false, false, 1)
          : functions(object)
      );
    }

    /**
     * Creates a function that invokes the method at `object[key]` and prepends
     * any additional `_.bindKey` arguments to those provided to the bound function.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist.
     * See [Peter Michaux's article](http://michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // using placeholders
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    function bindKey(object, key) {
      var bitmask = BIND_FLAG | BIND_KEY_FLAG;
      if (arguments.length > 2) {
        var partials = baseSlice(arguments, 2),
            holders = replaceHolders(partials, bindKey.placeholder);

        bitmask |= PARTIAL_FLAG;
      }
      return createWrapper(key, bitmask, object, partials, holders);
    }

    /**
     * Creates a function that accepts one or more arguments of `func` that when
     * called either invokes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` may be specified
     * if `func.length` is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      if (guard && isIterateeCall(func, arity, guard)) {
        arity = null;
      }
      var result = createWrapper(func, CURRY_FLAG, null, null, null, null, null, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method does not set the `length` property of curried functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // using placeholders
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      if (guard && isIterateeCall(func, arity, guard)) {
        arity = null;
      }
      var result = createWrapper(func, CURRY_RIGHT_FLAG, null, null, null, null, null, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a function that delays invoking `func` until after `wait` milliseconds
     * have elapsed since the last time it was invoked. The created function comes
     * with a `cancel` method to cancel delayed invocations. Provide an options
     * object to indicate that `func` should be invoked on the leading and/or
     * trailing edge of the `wait` timeout. Subsequent calls to the debounced
     * function return the result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify invoking on the leading
     *  edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be
     *  delayed before it is invoked.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // invoke `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // ensure `batchLog` is invoked once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }));
     *
     * // cancel a debounced call
     * var todoChanges = _.debounce(batchLog, 1000);
     * Object.observe(models.todo, todoChanges);
     *
     * Object.observe(models, function(changes) {
     *   if (_.find(changes, { 'user': 'todo', 'type': 'delete'})) {
     *     todoChanges.cancel();
     *   }
     * }, ['delete']);
     *
     * // ...at some point `models.todo` is changed
     * models.todo.completed = true;
     *
     * // ...before 1 second has passed `models.todo` is deleted
     * // which cancels the debounced `todoChanges` call
     * delete models.todo;
     */
    function debounce(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = wait < 0 ? 0 : (+wait || 0);
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if (isObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }

      function cancel() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
      }

      function delayed() {
        var remaining = wait - (now() - stamp);
        if (remaining <= 0 || remaining > wait) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      }

      function maxDelayed() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      }

      function debounced() {
        args = arguments;
        stamp = now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0 || remaining > maxWait;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      }
      debounced.cancel = cancel;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // logs 'deferred' after one or more milliseconds
     */
    function defer(func) {
      return baseDelay(func, 1, arguments, 1);
    }

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => logs 'later' after one second
     */
    function delay(func, wait) {
      return baseDelay(func, wait, arguments, 2);
    }

    /**
     * Creates a function that returns the result of invoking the provided
     * functions with the `this` binding of the created function, where each
     * successive invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function add(x, y) {
     *   return x + y;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow(add, square);
     * addSquare(1, 2);
     * // => 9
     */
    function flow() {
      var funcs = arguments,
          length = funcs.length;

      if (!length) {
        return function() { return arguments[0]; };
      }
      if (!arrayEvery(funcs, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var index = 0,
            result = funcs[index].apply(this, arguments);

        while (++index < length) {
          result = funcs[index].call(this, result);
        }
        return result;
      };
    }

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the provided functions from right to left.
     *
     * @static
     * @memberOf _
     * @alias backflow, compose
     * @category Function
     * @param {...Function} [funcs] Functions to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function add(x, y) {
     *   return x + y;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight(square, add);
     * addSquare(1, 2);
     * // => 9
     */
    function flowRight() {
      var funcs = arguments,
          fromIndex = funcs.length - 1;

      if (fromIndex < 0) {
        return function() { return arguments[0]; };
      }
      if (!arrayEvery(funcs, baseIsFunction)) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var index = fromIndex,
            result = funcs[index].apply(this, arguments);

        while (index--) {
          result = funcs[index].call(this, result);
        }
        return result;
      };
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is coerced to a string and used as the
     * cache key. The `func` is invoked with the `this` binding of the memoized
     * function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the ES `Map` method interface
     * of `get`, `has`, and `set`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-properties-of-the-map-prototype-object)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var upperCase = _.memoize(function(string) {
     *   return string.toUpperCase();
     * });
     *
     * upperCase('fred');
     * // => 'FRED'
     *
     * // modifying the result cache
     * upperCase.cache.set('fred', 'BARNEY');
     * upperCase('fred');
     * // => 'BARNEY'
     *
     * // replacing `_.memoize.Cache`
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'barney' };
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'fred' }
     *
     * _.memoize.Cache = WeakMap;
     * var identity = _.memoize(_.identity);
     *
     * identity(object);
     * // => { 'user': 'fred' }
     * identity(other);
     * // => { 'user': 'barney' }
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var cache = memoized.cache,
            key = resolver ? resolver.apply(this, arguments) : arguments[0];

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, arguments);
        cache.set(key, result);
        return result;
      };
      memoized.cache = new memoize.Cache;
      return memoized;
    }

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        return !predicate.apply(this, arguments);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first call. The `func` is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` invokes `createApplication` once
     */
    function once(func) {
      return before(func, 2);
    }

    /**
     * Creates a function that invokes `func` with `partial` arguments prepended
     * to those provided to the new function. This method is like `_.bind` except
     * it does **not** alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // using placeholders
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    function partial(func) {
      var partials = baseSlice(arguments, 1),
          holders = replaceHolders(partials, partial.placeholder);

      return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
    }

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to those provided to the new function.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method does not set the `length` property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [args] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) {
     *   return greeting + ' ' + name;
     * };
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // using placeholders
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    function partialRight(func) {
      var partials = baseSlice(arguments, 1),
          holders = replaceHolders(partials, partialRight.placeholder);

      return createWrapper(func, PARTIAL_RIGHT_FLAG, null, partials, holders);
    }

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified indexes where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes,
     *  specified as individual indexes or arrays of indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, 2, 0, 1);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     *
     * var map = _.rearg(_.map, [1, 0]);
     * map(function(n) {
     *   return n * 3;
     * }, [1, 2, 3]);
     * // => [3, 6, 9]
     */
    function rearg(func) {
      var indexes = baseFlatten(arguments, false, false, 1);
      return createWrapper(func, REARG_FLAG, null, null, null, indexes);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and the array of arguments provided to the created
     * function much like [Function#apply](http://es5.github.io/#x15.3.4.3).
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @returns {*} Returns the new function.
     * @example
     *
     * var spread = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * spread(['Fred', 'hello']);
     * // => 'Fred says hello'
     *
     * // with a Promise
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function(array) {
        return func.apply(this, array);
      };
    }

    /**
     * Creates a function that only invokes `func` at most once per every `wait`
     * milliseconds. The created function comes with a `cancel` method to cancel
     * delayed invocations. Provide an options object to indicate that `func`
     * should be invoked on the leading and/or trailing edge of the `wait` timeout.
     * Subsequent calls to the throttled function return the result of the last
     * `func` call.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * See [David Corbacho's article](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify invoking on the leading
     *  edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify invoking on the trailing
     *  edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // invoke `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     *
     * // cancel a trailing throttled call
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (options === false) {
        leading = false;
      } else if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      debounceOptions.leading = leading;
      debounceOptions.maxWait = +wait;
      debounceOptions.trailing = trailing;
      return debounce(func, wait, debounceOptions);
    }

    /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Any additional arguments provided to the function are
     * appended to those provided to the wrapper function. The wrapper is invoked
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      wrapper = wrapper == null ? identity : wrapper;
      return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
     * otherwise they are assigned by reference. If `customizer` is provided it is
     * invoked to produce the cloned values. If `customizer` returns `undefined`
     * cloning is handled by the method instead. The `customizer` is bound to
     * `thisArg` and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the structured clone algorithm.
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var shallow = _.clone(users);
     * shallow[0] === users[0];
     * // => true
     *
     * var deep = _.clone(users, true);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.clone(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 0
     */
    function clone(value, isDeep, customizer, thisArg) {
      if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
        isDeep = false;
      }
      else if (typeof isDeep == 'function') {
        thisArg = customizer;
        customizer = isDeep;
        isDeep = false;
      }
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, isDeep, customizer);
    }

    /**
     * Creates a deep clone of `value`. If `customizer` is provided it is invoked
     * to produce the cloned values. If `customizer` returns `undefined` cloning
     * is handled by the method instead. The `customizer` is bound to `thisArg`
     * and invoked with two argument; (value [, index|key, object]).
     *
     * **Note:** This method is loosely based on the structured clone algorithm.
     * The enumerable properties of `arguments` objects and objects created by
     * constructors other than `Object` are cloned to plain `Object` objects. An
     * empty object is returned for uncloneable values such as functions, DOM nodes,
     * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to deep clone.
     * @param {Function} [customizer] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {*} Returns the deep cloned value.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * var deep = _.cloneDeep(users);
     * deep[0] === users[0];
     * // => false
     *
     * // using a customizer callback
     * var el = _.cloneDeep(document.body, function(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * });
     *
     * el === document.body
     * // => false
     * el.nodeName
     * // => BODY
     * el.childNodes.length;
     * // => 20
     */
    function cloneDeep(value, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
      return baseClone(value, true, customizer);
    }

    /**
     * Checks if `value` is classified as an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      var length = isObjectLike(value) ? value.length : undefined;
      return (isLength(length) && objToString.call(value) == argsTag) || false;
    }
    // Fallback for environments without a `toStringTag` for `arguments` objects.
    if (!support.argsTag) {
      isArguments = function(value) {
        var length = isObjectLike(value) ? value.length : undefined;
        return (isLength(length) && hasOwnProperty.call(value, 'callee') &&
          !propertyIsEnumerable.call(value, 'callee')) || false;
      };
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(function() { return arguments; }());
     * // => false
     */
    var isArray = nativeIsArray || function(value) {
      return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
    };

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return (value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag) || false;
    }

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    function isDate(value) {
      return (isObjectLike(value) && objToString.call(value) == dateTag) || false;
    }

    /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return (value && value.nodeType === 1 && isObjectLike(value) &&
        (lodash.support.nodeTag ? objToString.call(value).indexOf('Element') > -1 : isHostObject(value))) || false;
    }
    // Fallback for environments without DOM support.
    if (!support.dom) {
      isElement = function(value) {
        return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
      };
    }

    /**
     * Checks if a value is empty. A value is considered empty unless it is an
     * `arguments` object, array, string, or jQuery-like collection with a length
     * greater than `0` or an object with own enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      var length = value.length;
      if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||
          (isObjectLike(value) && isFunction(value.splice)))) {
        return !length;
      }
      return !keys(value).length;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent. If `customizer` is provided it is invoked to compare values.
     * If `customizer` returns `undefined` comparisons are handled by the method
     * instead. The `customizer` is bound to `thisArg` and invoked with three
     * arguments; (value, other [, index|key]).
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. Functions and DOM nodes
     * are **not** supported. Provide a customizer function to extend support
     * for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var other = { 'user': 'fred' };
     *
     * object == other;
     * // => false
     *
     * _.isEqual(object, other);
     * // => true
     *
     * // using a customizer callback
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqual(array, other, function(value, other) {
     *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
     *     return true;
     *   }
     * });
     * // => true
     */
    function isEqual(value, other, customizer, thisArg) {
      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
        return value === other;
      }
      var result = customizer ? customizer(value, other) : undefined;
      return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      return (isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag) || false;
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on ES `Number.isFinite`. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.isfinite)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(10);
     * // => true
     *
     * _.isFinite('10');
     * // => false
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite(Object(10));
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
    var isFinite = nativeNumIsFinite || function(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    };

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in older versions of Chrome and Safari which return 'function' for regexes
      // and Safari 8 equivalents which return 'object' for typed array constructors.
      return objToString.call(value) == funcTag;
    };

    /**
     * Checks if `value` is the language type of `Object`.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
    function isObject(value) {
      // Avoid a V8 JIT bug in Chrome 19-20.
      // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
      var type = typeof value;
      return type == 'function' || (value && type == 'object') || false;
    }

    /**
     * Performs a deep comparison between `object` and `source` to determine if
     * `object` contains equivalent property values. If `customizer` is provided
     * it is invoked to compare values. If `customizer` returns `undefined`
     * comparisons are handled by the method instead. The `customizer` is bound
     * to `thisArg` and invoked with three arguments; (value, other, index|key).
     *
     * **Note:** This method supports comparing properties of arrays, booleans,
     * `Date` objects, numbers, `Object` objects, regexes, and strings. Functions
     * and DOM nodes are **not** supported. Provide a customizer function to extend
     * support for comparing other values.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.isMatch(object, { 'age': 40 });
     * // => true
     *
     * _.isMatch(object, { 'age': 36 });
     * // => false
     *
     * // using a customizer callback
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatch(object, source, function(value, other) {
     *   return _.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/) || undefined;
     * });
     * // => true
     */
    function isMatch(object, source, customizer, thisArg) {
      var props = keys(source),
          length = props.length;

      customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
      if (!customizer && length == 1) {
        var key = props[0],
            value = source[key];

        if (isStrictComparable(value)) {
          return object != null && value === object[key] && hasOwnProperty.call(object, key);
        }
      }
      var values = Array(length),
          strictCompareFlags = Array(length);

      while (length--) {
        value = values[length] = source[props[length]];
        strictCompareFlags[length] = isStrictComparable(value);
      }
      return baseIsMatch(object, props, values, strictCompareFlags, customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is not the same as native `isNaN` which returns `true`
     * for `undefined` and other non-numeric values. See the [ES5 spec](https://es5.github.io/#x15.1.2.4)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some host objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a native function.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (value == null) {
        return false;
      }
      if (objToString.call(value) == funcTag) {
        return reNative.test(fnToString.call(value));
      }
      return (isObjectLike(value) &&
        (isHostObject(value) ? reNative : reHostCtor).test(value)) || false;
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
     * as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isNumber(8.4);
     * // => true
     *
     * _.isNumber(NaN);
     * // => true
     *
     * _.isNumber('8.4');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * **Note:** This method assumes objects created by the `Object` constructor
     * have no inherited enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
      if (!(value && objToString.call(value) == objectTag) || (!lodash.support.argsTag && isArguments(value))) {
        return false;
      }
      var valueOf = value.valueOf,
          objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

      return objProto
        ? (value == objProto || getPrototypeOf(value) == objProto)
        : shimIsPlainObject(value);
    };

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    function isRegExp(value) {
      return (isObject(value) && objToString.call(value) == regexpTag) || false;
    }

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    function isTypedArray(value) {
      return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
    }

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return typeof value == 'undefined';
    }

    /**
     * Converts `value` to an array.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * (function() {
     *   return _.toArray(arguments).slice(1);
     * }(1, 2, 3));
     * // => [2, 3]
     */
    function toArray(value) {
      var length = value ? value.length : 0;
      if (!isLength(length)) {
        return values(value);
      }
      if (!length) {
        return [];
      }
      return (lodash.support.unindexedChars && isString(value))
        ? value.split('')
        : arrayCopy(value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable
     * properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return baseCopy(value, keysIn(value));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object. Subsequent sources overwrite property assignments of previous sources.
     * If `customizer` is provided it is invoked to produce the assigned values.
     * The `customizer` is bound to `thisArg` and invoked with five arguments;
     * (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize assigning values.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
     * // => { 'user': 'fred', 'age': 40 }
     *
     * // using a customizer callback
     * var defaults = _.partialRight(_.assign, function(value, other) {
     *   return typeof value == 'undefined' ? other : value;
     * });
     *
     * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    var assign = createAssigner(baseAssign);

    /**
     * Creates an object that inherits from the given `prototype` object. If a
     * `properties` object is provided its own enumerable properties are assigned
     * to the created object.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties, guard) {
      var result = baseCreate(prototype);
      if (guard && isIterateeCall(prototype, properties, guard)) {
        properties = null;
      }
      return properties ? baseCopy(properties, result, keys(properties)) : result;
    }

    /**
     * Assigns own enumerable properties of source object(s) to the destination
     * object for all destination properties that resolve to `undefined`. Once a
     * property is set, additional defaults of the same property are ignored.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
     * // => { 'user': 'barney', 'age': 36 }
     */
    function defaults(object) {
      if (object == null) {
        return object;
      }
      var args = arrayCopy(arguments);
      args.push(assignDefaults);
      return assign.apply(undefined, args);
    }

    /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element `predicate` returns truthy for, instead of the element itself.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // using the `_.matches` callback shorthand
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(object, predicate, baseForOwn, true);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * If a property name is provided for `predicate` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `predicate` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [predicate=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {string|undefined} Returns the key of the matched element, else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(chr) {
     *   return chr.age < 40;
     * });
     * // => returns `pebbles` assuming `_.findKey` returns `barney`
     *
     * // using the `_.matches` callback shorthand
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // using the `_.matchesProperty` callback shorthand
     * _.findLastKey(users, 'active', false);
     * // => 'fred'
     *
     * // using the `_.property` callback shorthand
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return baseFind(object, predicate, baseForOwnRight, true);
    }

    /**
     * Iterates over own and inherited enumerable properties of an object invoking
     * `iteratee` for each property. The `iteratee` is bound to `thisArg` and invoked
     * with three arguments; (value, key, object). Iterator functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a', 'b', and 'c' (iteration order is not guaranteed)
     */
    function forIn(object, iteratee, thisArg) {
      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
        iteratee = bindCallback(iteratee, thisArg, 3);
      }
      return baseFor(object, iteratee, keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'c', 'b', and 'a' assuming `_.forIn ` logs 'a', 'b', and 'c'
     */
    function forInRight(object, iteratee, thisArg) {
      iteratee = bindCallback(iteratee, thisArg, 3);
      return baseForRight(object, iteratee, keysIn);
    }

    /**
     * Iterates over own enumerable properties of an object invoking `iteratee`
     * for each property. The `iteratee` is bound to `thisArg` and invoked with
     * three arguments; (value, key, object). Iterator functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'a' and 'b' (iteration order is not guaranteed)
     */
    function forOwn(object, iteratee, thisArg) {
      if (typeof iteratee != 'function' || typeof thisArg != 'undefined') {
        iteratee = bindCallback(iteratee, thisArg, 3);
      }
      return baseForOwn(object, iteratee);
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'b' and 'a' assuming `_.forOwn` logs 'a' and 'b'
     */
    function forOwnRight(object, iteratee, thisArg) {
      iteratee = bindCallback(iteratee, thisArg, 3);
      return baseForRight(object, iteratee, keys);
    }

    /**
     * Creates an array of function property names from all enumerable properties,
     * own and inherited, of `object`.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of property names.
     * @example
     *
     * _.functions(_);
     * // => ['after', 'ary', 'assign', ...]
     */
    function functions(object) {
      return baseFunctions(object, keysIn(object));
    }

    /**
     * Checks if `key` exists as a direct property of `object` instead of an
     * inherited property.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {string} key The key to check.
     * @returns {boolean} Returns `true` if `key` is a direct property, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 3 };
     *
     * _.has(object, 'b');
     * // => true
     */
    function has(object, key) {
      return object ? hasOwnProperty.call(object, key) : false;
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite property
     * assignments of previous values unless `multiValue` is `true`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to invert.
     * @param {boolean} [multiValue] Allow multiple values per key.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     *
     * // with `multiValue`
     * _.invert(object, true);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function invert(object, multiValue, guard) {
      if (guard && isIterateeCall(object, multiValue, guard)) {
        multiValue = null;
      }
      var index = -1,
          props = keys(object),
          length = props.length,
          result = {};

      while (++index < length) {
        var key = props[index],
            value = object[key];

        if (multiValue) {
          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }
        else {
          result[value] = key;
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    var keys = !nativeKeys ? shimKeys : function(object) {
      if (object) {
        var Ctor = object.constructor,
            length = object.length;
      }
      if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
         (typeof object == 'function' ? lodash.support.enumPrototypes : (length && isLength(length)))) {
        return shimKeys(object);
      }
      return isObject(object) ? nativeKeys(object) : [];
    };

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      if (object == null) {
        return [];
      }
      if (!isObject(object)) {
        object = Object(object);
      }
      var length = object.length,
          support = lodash.support;

      length = (length && isLength(length) &&
        (isArray(object) || (support.nonEnumStrings && isString(object)) ||
          (support.nonEnumArgs && isArguments(object))) && length) || 0;

      var Ctor = object.constructor,
          index = -1,
          proto = (isFunction(Ctor) && Ctor.prototype) || objectProto,
          isProto = proto === object,
          result = Array(length),
          skipIndexes = length > 0,
          skipErrorProps = support.enumErrorProps && (object === errorProto || object instanceof Error),
          skipProto = support.enumPrototypes && isFunction(object);

      while (++index < length) {
        result[index] = (index + '');
      }
      // lodash skips the `constructor` property when it infers it is iterating
      // over a `prototype` object because IE < 9 can't set the `[[Enumerable]]`
      // attribute of an existing property and the `constructor` property of a
      // prototype defaults to non-enumerable.
      for (var key in object) {
        if (!(skipProto && key == 'prototype') &&
            !(skipErrorProps && (key == 'message' || key == 'name')) &&
            !(skipIndexes && isIndex(key, length)) &&
            !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      if (support.nonEnumShadows && object !== objectProto) {
        var tag = object === stringProto ? stringTag : object === errorProto ? errorTag : objToString.call(object),
            nonEnums = nonEnumProps[tag] || nonEnumProps[objectTag];

        if (tag == objectTag) {
          proto = objectProto;
        }
        length = shadowProps.length;
        while (length--) {
          key = shadowProps[length];
          var nonEnum = nonEnums[key];
          if (!(isProto && nonEnum) &&
              (nonEnum ? hasOwnProperty.call(object, key) : object[key] !== proto[key])) {
            result.push(key);
          }
        }
      }
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated by
     * running each own enumerable property of `object` through `iteratee`. The
     * iteratee function is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * If a property name is provided for `iteratee` the created `_.property`
     * style callback returns the property value of the given element.
     *
     * If a value is also provided for `thisArg` the created `_.matchesProperty`
     * style callback returns `true` for elements that have a matching property
     * value, else `false`.
     *
     * If an object is provided for `iteratee` the created `_.matches` style
     * callback returns `true` for elements that have the properties of the given
     * object, else `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function|Object|string} [iteratee=_.identity] The function invoked
     *  per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Object} Returns the new mapped object.
     * @example
     *
     * _.mapValues({ 'a': 1, 'b': 2 }, function(n) {
     *   return n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * // using the `_.property` callback shorthand
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee, thisArg) {
      var result = {};
      iteratee = getCallback(iteratee, thisArg, 3);

      baseForOwn(object, function(value, key, object) {
        result[key] = iteratee(value, key, object);
      });
      return result;
    }

    /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * overwrite property assignments of previous sources. If `customizer` is
     * provided it is invoked to produce the merged values of the destination and
     * source properties. If `customizer` returns `undefined` merging is handled
     * by the method instead. The `customizer` is bound to `thisArg` and invoked
     * with five arguments; (objectValue, sourceValue, key, object, source).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @param {Function} [customizer] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `customizer`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var users = {
     *   'data': [{ 'user': 'barney' }, { 'user': 'fred' }]
     * };
     *
     * var ages = {
     *   'data': [{ 'age': 36 }, { 'age': 40 }]
     * };
     *
     * _.merge(users, ages);
     * // => { 'data': [{ 'user': 'barney', 'age': 36 }, { 'user': 'fred', 'age': 40 }] }
     *
     * // using a customizer callback
     * var object = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var other = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(object, other, function(a, b) {
     *   if (_.isArray(a)) {
     *     return a.concat(b);
     *   }
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }
     */
    var merge = createAssigner(baseMerge);

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable properties of `object` that are not omitted.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If `predicate` is provided it is invoked for each property
     * of `object` omitting the properties `predicate` returns truthy for. The
     * predicate is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to omit, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.omit(object, 'age');
     * // => { 'user': 'fred' }
     *
     * _.omit(object, _.isNumber);
     * // => { 'user': 'fred' }
     */
    function omit(object, predicate, thisArg) {
      if (object == null) {
        return {};
      }
      if (typeof predicate != 'function') {
        var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
        return pickByArray(object, baseDifference(keysIn(object), props));
      }
      predicate = bindCallback(predicate, thisArg, 3);
      return pickByCallback(object, function(value, key, object) {
        return !predicate(value, key, object);
      });
    }

    /**
     * Creates a two dimensional array of the key-value pairs for `object`,
     * e.g. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'barney': 36, 'fred': 40 });
     * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
     */
    function pairs(object) {
      var index = -1,
          props = keys(object),
          length = props.length,
          result = Array(length);

      while (++index < length) {
        var key = props[index];
        result[index] = [key, object[key]];
      }
      return result;
    }

    /**
     * Creates an object composed of the picked `object` properties. Property
     * names may be specified as individual arguments or as arrays of property
     * names. If `predicate` is provided it is invoked for each property of `object`
     * picking the properties `predicate` returns truthy for. The predicate is
     * bound to `thisArg` and invoked with three arguments; (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {Function|...(string|string[])} [predicate] The function invoked per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `predicate`.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'user': 'fred', 'age': 40 };
     *
     * _.pick(object, 'user');
     * // => { 'user': 'fred' }
     *
     * _.pick(object, _.isString);
     * // => { 'user': 'fred' }
     */
    function pick(object, predicate, thisArg) {
      if (object == null) {
        return {};
      }
      return typeof predicate == 'function'
        ? pickByCallback(object, bindCallback(predicate, thisArg, 3))
        : pickByArray(object, baseFlatten(arguments, false, false, 1));
    }

    /**
     * Resolves the value of property `key` on `object`. If the value of `key` is
     * a function it is invoked with the `this` binding of `object` and its result
     * is returned, else the property value is returned. If the property value is
     * `undefined` the `defaultValue` is used in its place.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to resolve.
     * @param {*} [defaultValue] The value returned if the property value
     *  resolves to `undefined`.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'user': 'fred', 'age': _.constant(40) };
     *
     * _.result(object, 'user');
     * // => 'fred'
     *
     * _.result(object, 'age');
     * // => 40
     *
     * _.result(object, 'status', 'busy');
     * // => 'busy'
     *
     * _.result(object, 'status', _.constant('busy'));
     * // => 'busy'
     */
    function result(object, key, defaultValue) {
      var value = object == null ? undefined : object[key];
      if (typeof value == 'undefined') {
        value = defaultValue;
      }
      return isFunction(value) ? value.call(object) : value;
    }

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own enumerable
     * properties through `iteratee`, with each invocation potentially mutating
     * the `accumulator` object. The `iteratee` is bound to `thisArg` and invoked
     * with four arguments; (accumulator, value, key, object). Iterator functions
     * may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Array|Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * });
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2 }, function(result, n, key) {
     *   result[key] = n * 3;
     * });
     * // => { 'a': 3, 'b': 6 }
     */
    function transform(object, iteratee, accumulator, thisArg) {
      var isArr = isArray(object) || isTypedArray(object);
      iteratee = getCallback(iteratee, thisArg, 4);

      if (accumulator == null) {
        if (isArr || isObject(object)) {
          var Ctor = object.constructor;
          if (isArr) {
            accumulator = isArray(object) ? new Ctor : [];
          } else {
            accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
          }
        } else {
          accumulator = {};
        }
      }
      (isArr ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Creates an array of the own enumerable property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable property values
     * of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Checks if `n` is between `start` and up to but not including, `end`. If
     * `end` is not specified it defaults to `start` with `start` becoming `0`.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} n The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `n` is in the range, else `false`.
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     */
    function inRange(value, start, end) {
      start = +start || 0;
      if (typeof end === 'undefined') {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      return value >= start && value < end;
    }

    /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number is returned.
     * If `floating` is `true`, or either `min` or `max` are floats, a floating-point
     * number is returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Number
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(min, max, floating) {
      if (floating && isIterateeCall(min, max, floating)) {
        max = floating = null;
      }
      var noMin = min == null,
          noMax = max == null;

      if (floating == null) {
        if (noMax && typeof min == 'boolean') {
          floating = min;
          min = 1;
        }
        else if (typeof max == 'boolean') {
          floating = max;
          noMax = true;
        }
      }
      if (noMin && noMax) {
        max = 1;
        noMax = false;
      }
      min = +min || 0;
      if (noMax) {
        max = min;
        min = 0;
      } else {
        max = +max || 0;
      }
      if (floating || min % 1 || max % 1) {
        var rand = nativeRandom();
        return nativeMin(min + (rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1)))), max);
      }
      return baseRandom(min, max);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to camel case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/CamelCase) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar');
     * // => 'fooBar'
     *
     * _.camelCase('__foo_bar__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? (word.charAt(0).toUpperCase() + word.slice(1)) : word);
    });

    /**
     * Capitalizes the first character of `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('fred');
     * // => 'Fred'
     */
    function capitalize(string) {
      string = baseToString(string);
      return string && (string.charAt(0).toUpperCase() + string.slice(1));
    }

    /**
     * Deburrs `string` by converting latin-1 supplementary letters to basic latin letters.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = baseToString(string);
      return string && string.replace(reLatin1, deburrLetter);
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search from.
     * @returns {boolean} Returns `true` if `string` ends with `target`, else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = baseToString(string);
      target = (target + '');

      var length = string.length;
      position = (typeof position == 'undefined' ? length : nativeMin(position < 0 ? 0 : (+position || 0), length)) - target.length;
      return position >= 0 && string.indexOf(target, position) == position;
    }

    /**
     * Converts the characters "&", "<", ">", '"', "'", and '`', in `string` to
     * their corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional characters
     * use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't require escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value.
     * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * Backticks are escaped because in Internet Explorer < 9, they can break out
     * of attribute values or HTML comments. See [#102](https://html5sec.org/#102),
     * [#108](https://html5sec.org/#108), and [#133](https://html5sec.org/#133) of
     * the [HTML5 Security Cheatsheet](https://html5sec.org/) for more details.
     *
     * When working with HTML you should always quote attribute values to reduce
     * XSS vectors. See [Ryan Grove's article](http://wonko.com/post/html-escaping)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      // Reset `lastIndex` because in IE < 9 `String#replace` does not.
      string = baseToString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
     * "+", "(", ")", "[", "]", "{" and "}" in `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = baseToString(string);
      return (string && reHasRegExpChars.test(string))
        ? string.replace(reRegExpChars, '\\$&')
        : string;
    }

    /**
     * Converts `string` to kebab case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles) for
     * more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__foo_bar__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Pads `string` on the left and right sides if it is shorter then the given
     * padding length. The `chars` string may be truncated if the number of padding
     * characters can't be evenly divided by the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = baseToString(string);
      length = +length;

      var strLength = string.length;
      if (strLength >= length || !nativeIsFinite(length)) {
        return string;
      }
      var mid = (length - strLength) / 2,
          leftLength = floor(mid),
          rightLength = ceil(mid);

      chars = createPad('', rightLength, chars);
      return chars.slice(0, leftLength) + string + chars;
    }

    /**
     * Pads `string` on the left side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padLeft('abc', 6);
     * // => '   abc'
     *
     * _.padLeft('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padLeft('abc', 3);
     * // => 'abc'
     */
    function padLeft(string, length, chars) {
      string = baseToString(string);
      return string && (createPad(string, length, chars) + string);
    }

    /**
     * Pads `string` on the right side if it is shorter then the given padding
     * length. The `chars` string may be truncated if the number of padding
     * characters exceeds the padding length.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padRight('abc', 6);
     * // => 'abc   '
     *
     * _.padRight('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padRight('abc', 3);
     * // => 'abc'
     */
    function padRight(string, length, chars) {
      string = baseToString(string);
      return string && (string + createPad(string, length, chars));
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a hexadecimal,
     * in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the ES5 implementation of `parseInt`.
     * See the [ES5 spec](https://es5.github.io/#E) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard && isIterateeCall(string, radix, guard)) {
        radix = 0;
      }
      return nativeParseInt(string, radix);
    }
    // Fallback for environments with pre-ES5 implementations.
    if (nativeParseInt(whitespace + '08') != 8) {
      parseInt = function(string, radix, guard) {
        // Firefox < 21 and Opera < 15 follow ES3 for `parseInt`.
        // Chrome fails to trim leading <BOM> whitespace characters.
        // See https://code.google.com/p/v8/issues/detail?id=3109 for more details.
        if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        string = trim(string);
        return nativeParseInt(string, radix || (reHexPrefix.test(string) ? 16 : 10));
      };
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=0] The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n) {
      var result = '';
      string = baseToString(string);
      n = +n;
      if (n < 1 || !string || !nativeIsFinite(n)) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = floor(n / 2);
        string += string;
      } while (n);

      return result;
    }

    /**
     * Converts `string` to snake case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Snake_case) for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--foo-bar');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Converts `string` to start case.
     * See [Wikipedia](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage)
     * for more details.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__foo_bar__');
     * // => 'Foo Bar'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to search.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`, else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = baseToString(string);
      position = position == null ? 0 : nativeMin(position < 0 ? 0 : (+position || 0), string.length);
      return string.lastIndexOf(target, position) == position;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is provided it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes sourceURLs for easier debugging.
     * See the [HTML5 Rocks article on sourcemaps](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for more details.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [options.variable] The data object variable name.
     * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // using the HTML "escape" delimiter to escape data property values
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to execute JavaScript and generate HTML
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // using the ES delimiter as an alternative to the default "interpolate" delimiter
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // using custom template delimiters
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using backslashes to treat delimiters as plain text
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // using the `imports` option to import `jQuery` as `jq`
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, otherOptions) {
      // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (otherOptions && isIterateeCall(string, options, otherOptions)) {
        options = otherOptions = null;
      }
      string = baseToString(string);
      options = baseAssign(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

      var imports = baseAssign(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      var sourceURL = '//# sourceURL=' +
        ('sourceURL' in options
          ? options.sourceURL
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products requires returning the `match`
        // string in order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar]
     */
    function trim(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
      }
      chars = (chars + '');
      return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimLeft('  abc  ');
     * // => 'abc  '
     *
     * _.trimLeft('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimLeft(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(trimmedLeftIndex(string));
      }
      return string.slice(charsLeftIndex(string, (chars + '')));
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimRight('  abc  ');
     * // => '  abc'
     *
     * _.trimRight('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimRight(string, chars, guard) {
      var value = string;
      string = baseToString(string);
      if (!string) {
        return string;
      }
      if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
        return string.slice(0, trimmedRightIndex(string) + 1);
      }
      return string.slice(0, charsRightIndex(string, (chars + '')) + 1);
    }

    /**
     * Truncates `string` if it is longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object|number} [options] The options object or maximum string length.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.trunc('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', 24);
     * // => 'hi-diddly-ho there, n...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * //=> 'hi-diddly-ho there...'
     *
     * _.trunc('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function trunc(string, options, guard) {
      if (guard && isIterateeCall(string, options, guard)) {
        options = null;
      }
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (options != null) {
        if (isObject(options)) {
          var separator = 'separator' in options ? options.separator : separator;
          length = 'length' in options ? +options.length || 0 : length;
          omission = 'omission' in options ? baseToString(options.omission) : omission;
        } else {
          length = +options || 0;
        }
      }
      string = baseToString(string);
      if (length >= string.length) {
        return string;
      }
      var end = length - omission.length;
      if (end < 1) {
        return omission;
      }
      var result = string.slice(0, end);
      if (separator == null) {
        return result + omission;
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              newEnd,
              substring = string.slice(0, end);

          if (!separator.global) {
            separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            newEnd = match.index;
          }
          result = result.slice(0, newEnd == null ? end : newEnd);
        }
      } else if (string.indexOf(separator, end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, `&#39;`, and `&#96;` in `string` to their
     * corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional HTML
     * entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = baseToString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      if (guard && isIterateeCall(string, pattern, guard)) {
        pattern = null;
      }
      string = baseToString(string);
      return string.match(pattern || reWords) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} func The function to attempt.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // avoid throwing errors for invalid selectors
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    function attempt() {
      var length = arguments.length,
          func = arguments[0];

      try {
        var args = Array(length ? length - 1 : 0);
        while (--length > 0) {
          args[length - 1] = arguments[length];
        }
        return func.apply(undefined, args);
      } catch(e) {
        return isError(e) ? e : new Error(e);
      }
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and arguments of the created function. If `func` is a property name the
     * created callback returns the property value for a given element. If `func`
     * is an object the created callback returns `true` for elements that contain
     * the equivalent object properties, otherwise it returns `false`.
     *
     * @static
     * @memberOf _
     * @alias iteratee
     * @category Utility
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
     *   if (!match) {
     *     return callback(func, thisArg);
     *   }
     *   return function(object) {
     *     return match[2] == 'gt'
     *       ? object[match[1]] > match[3]
     *       : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(users, 'age__gt36');
     * // => [{ 'user': 'fred', 'age': 40 }]
     */
    function callback(func, thisArg, guard) {
      if (guard && isIterateeCall(func, thisArg, guard)) {
        thisArg = null;
      }
      return isObjectLike(func)
        ? matches(func)
        : baseCallback(func, thisArg);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'user': 'fred' };
     * var getter = _.constant(object);
     *
     * getter() === object;
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.identity(object) === object;
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function which performs a deep comparison between a given object
     * and `source`, returning `true` if the given object has equivalent property
     * values, else `false`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties. For comparing a single
     * own or inherited property value see `_.matchesProperty`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, _.matches({ 'age': 40, 'active': false }));
     * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, true));
    }

    /**
     * Creates a function which compares the property value of `key` on a given
     * object to `value`.
     *
     * **Note:** This method supports comparing arrays, booleans, `Date` objects,
     * numbers, `Object` objects, regexes, and strings. Objects are compared by
     * their own, not inherited, enumerable properties.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @param {*} value The value to compare.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' },
     *   { 'user': 'pebbles' }
     * ];
     *
     * _.find(users, _.matchesProperty('user', 'fred'));
     * // => { 'user': 'fred', 'age': 40 }
     */
    function matchesProperty(key, value) {
      return baseMatchesProperty(key + '', baseClone(value, true));
    }

    /**
     * Adds all own enumerable function properties of a source object to the
     * destination object. If `object` is a function then methods are added to
     * its prototype as well.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Function|Object} [object=this] object The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.chain=true] Specify whether the functions added
     *  are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * // use `_.runInContext` to avoid potential conflicts (esp. in Node.js)
     * var _ = require('lodash').runInContext();
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      if (options == null) {
        var isObj = isObject(source),
            props = isObj && keys(source),
            methodNames = props && props.length && baseFunctions(source, props);

        if (!(methodNames ? methodNames.length : isObj)) {
          methodNames = false;
          options = source;
          source = object;
          object = this;
        }
      }
      if (!methodNames) {
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = true,
          index = -1,
          isFunc = isFunction(object),
          length = methodNames.length;

      if (options === false) {
        chain = false;
      } else if (isObject(options) && 'chain' in options) {
        chain = options.chain;
      }
      while (++index < length) {
        var methodName = methodNames[index],
            func = source[methodName];

        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = (function(func) {
            return function() {
              var chainAll = this.__chain__;
              if (chain || chainAll) {
                var result = object(this.__wrapped__);
                (result.__actions__ = arrayCopy(this.__actions__)).push({ 'func': func, 'args': arguments, 'thisArg': object });
                result.__chain__ = chainAll;
                return result;
              }
              var args = [this.value()];
              push.apply(args, arguments);
              return func.apply(object, args);
            };
          }(func));
        }
      }
      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      context._ = oldDash;
      return this;
    }

    /**
     * A no-operation function which returns `undefined` regardless of the
     * arguments it receives.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @example
     *
     * var object = { 'user': 'fred' };
     *
     * _.noop(object) === undefined;
     * // => true
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function which returns the property value of `key` on a given object.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var users = [
     *   { 'user': 'fred' },
     *   { 'user': 'barney' }
     * ];
     *
     * var getName = _.property('user');
     *
     * _.map(users, getName);
     * // => ['fred', barney']
     *
     * _.pluck(_.sortBy(users, getName), 'user');
     * // => ['barney', 'fred']
     */
    function property(key) {
      return baseProperty(key + '');
    }

    /**
     * The inverse of `_.property`; this method creates a function which returns
     * the property value of a given key on `object`.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {Object} object The object to inspect.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var object = { 'a': 3, 'b': 1, 'c': 2 };
     *
     * _.map(['a', 'c'], _.propertyOf(object));
     * // => [3, 2]
     *
     * _.sortBy(['a', 'b', 'c'], _.propertyOf(object));
     * // => ['b', 'c', 'a']
     */
    function propertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. If `end` is not specified it
     * defaults to `start` with `start` becoming `0`. If `start` is less than
     * `end` a zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the new array of numbers.
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    function range(start, end, step) {
      if (step && isIterateeCall(start, end, step)) {
        end = step = null;
      }
      start = +start || 0;
      step = step == null ? 1 : (+step || 0);

      if (end == null) {
        end = start;
        start = 0;
      } else {
        end = +end || 0;
      }
      // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.
      // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.
      var index = -1,
          length = nativeMax(ceil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (++index < length) {
        result[index] = start;
        start += step;
      }
      return result;
    }

    /**
     * Invokes the iteratee function `n` times, returning an array of the results
     * of each invocation. The `iteratee` is bound to `thisArg` and invoked with
     * one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [thisArg] The `this` binding of `iteratee`.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6, false));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) {
     *   mage.castSpell(n);
     * });
     * // => invokes `mage.castSpell(n)` three times with `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) {
     *   this.cast(n);
     * }, mage);
     * // => also invokes `mage.castSpell(n)` three times
     */
    function times(n, iteratee, thisArg) {
      n = +n;

      // Exit early to avoid a JSC JIT bug in Safari 8
      // where `Array(0)` is treated as `Array(1)`.
      if (n < 1 || !nativeIsFinite(n)) {
        return [];
      }
      var index = -1,
          result = Array(nativeMin(n, MAX_ARRAY_LENGTH));

      iteratee = bindCallback(iteratee, thisArg, 1);
      while (++index < n) {
        if (index < MAX_ARRAY_LENGTH) {
          result[index] = iteratee(index);
        } else {
          iteratee(index);
        }
      }
      return result;
    }

    /**
     * Generates a unique ID. If `prefix` is provided the ID is appended to it.
     *
     * @static
     * @memberOf _
     * @category Utility
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return baseToString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    // Add functions to the `Map` cache.
    MapCache.prototype['delete'] = mapDelete;
    MapCache.prototype.get = mapGet;
    MapCache.prototype.has = mapHas;
    MapCache.prototype.set = mapSet;

    // Add functions to the `Set` cache.
    SetCache.prototype.push = cachePush;

    // Assign cache to `_.memoize`.
    memoize.Cache = MapCache;

    // Add functions that return wrapped values when chaining.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.callback = callback;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.functions = functions;
    lodash.groupBy = groupBy;
    lodash.indexBy = indexBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.invert = invert;
    lodash.invoke = invoke;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.omit = omit;
    lodash.once = once;
    lodash.pairs = pairs;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pluck = pluck;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortByAll = sortByAll;
    lodash.spread = spread;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.times = times;
    lodash.toArray = toArray;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.union = union;
    lodash.uniq = uniq;
    lodash.unzip = unzip;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.where = where;
    lodash.without = without;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.zip = zip;
    lodash.zipObject = zipObject;

    // Add aliases.
    lodash.backflow = flowRight;
    lodash.collect = map;
    lodash.compose = flowRight;
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.extend = assign;
    lodash.iteratee = callback;
    lodash.methods = functions;
    lodash.object = zipObject;
    lodash.select = filter;
    lodash.tail = rest;
    lodash.unique = uniq;

    // Add functions to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add functions that return unwrapped values when chaining.
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.deburr = deburr;
    lodash.endsWith = endsWith;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.findWhere = findWhere;
    lodash.first = first;
    lodash.has = has;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isBoolean = isBoolean;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isMatch = isMatch;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isString = isString;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.max = max;
    lodash.min = min;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padLeft = padLeft;
    lodash.padRight = padRight;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.result = result;
    lodash.runInContext = runInContext;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.template = template;
    lodash.trim = trim;
    lodash.trimLeft = trimLeft;
    lodash.trimRight = trimRight;
    lodash.trunc = trunc;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.words = words;

    // Add aliases.
    lodash.all = every;
    lodash.any = some;
    lodash.contains = includes;
    lodash.detect = find;
    lodash.foldl = reduce;
    lodash.foldr = reduceRight;
    lodash.head = first;
    lodash.include = includes;
    lodash.inject = reduce;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!lodash.prototype[methodName]) {
          source[methodName] = func;
        }
      });
      return source;
    }()), false);

    /*------------------------------------------------------------------------*/

    // Add functions capable of returning wrapped and unwrapped values when chaining.
    lodash.sample = sample;

    lodash.prototype.sample = function(n) {
      if (!this.__chain__ && n == null) {
        return sample(this.value());
      }
      return this.thru(function(value) {
        return sample(value, n);
      });
    };

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var isFilter = index == LAZY_FILTER_FLAG || index == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee, thisArg) {
        var result = this.clone(),
            iteratees = result.__iteratees__ || (result.__iteratees__ = []);

        result.__filtered__ = result.__filtered__ || isFilter;
        iteratees.push({ 'iteratee': getCallback(iteratee, thisArg, 3), 'type': index });
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      var countName = '__' + methodName + 'Count__',
          whileName = methodName + 'While';

      LazyWrapper.prototype[methodName] = function(n) {
        n = n == null ? 1 : nativeMax(floor(n) || 0, 0);

        var result = this.clone();
        if (result.__filtered__) {
          var value = result[countName];
          result[countName] = index ? nativeMin(value, n) : (value + n);
        } else {
          var views = result.__views__ || (result.__views__ = []);
          views.push({ 'size': n, 'type': methodName + (result.__dir__ < 0 ? 'Right' : '') });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };

      LazyWrapper.prototype[methodName + 'RightWhile'] = function(predicate, thisArg) {
        return this.reverse()[whileName](predicate, thisArg).reverse();
      };
    });

    // Add `LazyWrapper` methods for `_.first` and `_.last`.
    arrayEach(['first', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.rest`.
    arrayEach(['initial', 'rest'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this[dropName](1);
      };
    });

    // Add `LazyWrapper` methods for `_.pluck` and `_.where`.
    arrayEach(['pluck', 'where'], function(methodName, index) {
      var operationName = index ? 'filter' : 'map',
          createCallback = index ? baseMatches : baseProperty;

      LazyWrapper.prototype[methodName] = function(value) {
        return this[operationName](createCallback(value));
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.dropWhile = function(predicate, thisArg) {
      var done,
          lastIndex,
          isRight = this.__dir__ < 0;

      predicate = getCallback(predicate, thisArg, 3);
      return this.filter(function(value, index, array) {
        done = done && (isRight ? index < lastIndex : index > lastIndex);
        lastIndex = index;
        return done || (done = !predicate(value, index, array));
      });
    };

    LazyWrapper.prototype.reject = function(predicate, thisArg) {
      predicate = getCallback(predicate, thisArg, 3);
      return this.filter(function(value, index, array) {
        return !predicate(value, index, array);
      });
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = start == null ? 0 : (+start || 0);
      var result = start < 0 ? this.takeRight(-start) : this.drop(start);

      if (typeof end != 'undefined') {
        end = (+end || 0);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.toArray = function() {
      return this.drop(0);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName],
          retUnwrapped = /^(?:first|last)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = arguments,
            chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isLazy = value instanceof LazyWrapper,
            onlyLazy = isLazy && !isHybrid;

        if (retUnwrapped && !chainAll) {
          return onlyLazy
            ? func.call(value)
            : lodashFunc.call(lodash, this.value());
        }
        var interceptor = function(value) {
          var otherArgs = [value];
          push.apply(otherArgs, args);
          return lodashFunc.apply(lodash, otherArgs);
        };
        if (isLazy || isArray(value)) {
          var wrapper = onlyLazy ? value : new LazyWrapper(this),
              result = func.apply(wrapper, args);

          if (!retUnwrapped && (isHybrid || result.__actions__)) {
            var actions = result.__actions__ || (result.__actions__ = []);
            actions.push({ 'func': thru, 'args': [interceptor], 'thisArg': lodash });
          }
          return new LodashWrapper(result, chainAll);
        }
        return this.thru(interceptor);
      };
    });

    // Add `Array.prototype` functions to `lodash.prototype`.
    arrayEach(['concat', 'join', 'pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var arrayFunc = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          fixObjects = !support.spliceObjects && /^(?:pop|shift|splice)$/.test(methodName),
          retUnwrapped = /^(?:join|pop|shift)$/.test(methodName);

      // Avoid array-like object bugs with `Array#shift` and `Array#splice` in
      // IE < 9, Firefox < 10, Narwhal, and RingoJS.
      var func = !fixObjects ? arrayFunc : function() {
        var result = arrayFunc.apply(this, arguments);
        if (this.length === 0) {
          delete this[0];
        }
        return result;
      };

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          return func.apply(this.value(), args);
        }
        return this[chainName](function(value) {
          return func.apply(value, args);
        });
      };
    });

    // Add functions to the lazy wrapper.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chaining functions to the `lodash` wrapper.
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toString = wrapperToString;
    lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add function aliases to the `lodash` wrapper.
    lodash.prototype.collect = lodash.prototype.map;
    lodash.prototype.head = lodash.prototype.first;
    lodash.prototype.select = lodash.prototype.filter;
    lodash.prototype.tail = lodash.prototype.rest;

    return lodash;
  }

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define('lodash',[],function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = _)._ = _;
    }
    // Export for Narwhal or Rhino -require.
    else {
      freeExports._ = _;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = _;
  }
}.call(this));

define('js/applicationWidgets/charting',["require", "exports", "d3", "mithril", "../calculateStatistics", "lodash"], function (require, exports, d3, m, calculateStatistics, _) {
    "use strict";
    var unansweredKey = "{N/A}";
    var maxRangeLabelLength = 26;
    function correctForUnanswered(question, value) {
        if (question.displayType === "checkbox" && !value)
            return "no";
        if (value === undefined || value === null || value === "")
            return unansweredKey;
        return value;
    }
    function nameForQuestion(question) {
        if (question.displayName)
            return escapeHtml(question.displayName);
        if (question.displayPrompt)
            return escapeHtml(question.displayPrompt);
        return escapeHtml(question.id);
    }
    function positionForQuestionAnswer(question, answer) {
        // console.log("positionForQuestionAnswer", question, answer);
        // TODO: Confirm checkbox values are also yes/no...
        if (question.displayType === "boolean" || question.displayType === "checkbox") {
            if (answer === false)
                return 0;
            if (answer === true)
                return 100;
            return -100;
        }
        // TODO: How to display sliders when unanswered? Add one here?
        // TODO: Check that answer is numerical
        if (question.displayType === "slider") {
            // console.log("slider answer", answer);
            if (answer === unansweredKey)
                return -10;
            return answer;
        }
        // Doesn't work for text...
        if (question.displayType === "text") {
            console.log("TODO: positionForQuestionAnswer does not work for text");
            return 0;
        }
        // Adjust for question types without options
        // TODO: Should probably review this further related to change for options to valueOptions and displayConfiguration
        var options = [];
        if (question.valueOptions)
            options = question.valueOptions;
        var answerCount = options.length;
        // Adjust for unanswered items
        // if (question.displayType !== "checkboxes") answerCount += 1;
        if (answer === unansweredKey) {
            return -100 * 1 / (options.length - 1);
        }
        var answerIndex = options.indexOf(answer);
        // console.log("answerIndex", answerIndex);
        var position = 100 * answerIndex / (options.length - 1);
        // console.log("calculated position: ", position);
        return position;
    }
    function makePlotItem(xAxisQuestion, yAxisQuestion, xValue, yValue, story) {
        // console.log("newPlotItem", xAxisQuestion, yAxisQuestion, xValue, yValue, story);
        // Plot onto a 100 x 100 value to work with sliders
        var x = positionForQuestionAnswer(xAxisQuestion, xValue);
        var y = positionForQuestionAnswer(yAxisQuestion, yValue);
        return { x: x, y: y, story: story };
    }
    function incrementMapSlot(map, key) {
        var oldCount = map[key];
        if (!oldCount)
            oldCount = 0;
        map[key] = oldCount + 1;
        // console.log("incrementMapSlot to map", key, map[key], map);
    }
    function pushToMapSlot(map, key, value) {
        var values = map[key];
        if (!values)
            values = [];
        values.push(value);
        map[key] = values;
        // console.log("pushToMapSlot", key, value, map[key]);
    }
    function preloadResultsForQuestionOptions(results, question) {
        /*jshint -W069 */
        var type = question.displayType;
        results[unansweredKey] = 0;
        if (type === "boolean" || type === "checkbox") {
            results["false"] = 0;
            results["true"] = 0;
        }
        else if (question.valueOptions) {
            for (var i = 0; i < question.valueOptions.length; i++) {
                results[question.valueOptions[i]] = 0;
            }
        }
    }
    function limitLabelLength(label, maximumCharacters) {
        if (label.length <= maximumCharacters)
            return label;
        return label.substring(0, maximumCharacters - 3) + "...";
    }
    // TODO: Put elipsis starting between words so no words are cut off
    function limitStoryTextLength(text) {
        return limitLabelLength(text, 500);
    }
    function displayTextForAnswer(answer) {
        // console.log("displayTextForAnswer", answer);
        if (!answer && answer !== 0)
            return "";
        var hasCheckboxes = _.isObject(answer);
        if (!hasCheckboxes)
            return answer;
        var result = "";
        for (var key in answer) {
            if (answer[key]) {
                if (result)
                    result += ", ";
                result += key;
            }
        }
        return result;
    }
    // ---- Support functions using d3
    // Support starting a drag when mouse is over a node
    function supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayItems) {
        storyDisplayItems.on('mousedown', function () {
            var brushElements = chartBody.select(".brush").node();
            // TODO: Casting Event to any because TypeScript somehow thinks it does not take an argument
            var newClickEvent = new Event('mousedown');
            newClickEvent.pageX = d3.event.pageX;
            newClickEvent.clientX = d3.event.clientX;
            newClickEvent.pageY = d3.event.pageY;
            newClickEvent.clientY = d3.event.clientY;
            brushElements.dispatchEvent(newClickEvent);
        });
    }
    function createBrush(chartBody, xScale, yScale, brushendCallback) {
        // If yScale is null, constrain brush to just work across the x range of the chart
        var brush = d3.svg.brush()
            .x(xScale)
            .on("brushend", brushendCallback);
        if (yScale)
            brush.y(yScale);
        var brushGroup = chartBody.append("g")
            .attr("class", "brush")
            .call(brush);
        if (!yScale) {
            brushGroup.selectAll("rect")
                .attr("y", 0)
                .attr("height", chartBody.attr("height"));
        }
        return { brush: brush, brushGroup: brushGroup };
    }
    function makeChartFramework(chartPane, chartType, isSmallFormat, margin) {
        var fullWidth = 700;
        var fullHeight = 500;
        if (isSmallFormat) {
            fullWidth = 200;
            fullHeight = 200;
        }
        var width = fullWidth - margin.left - margin.right;
        var height = fullHeight - margin.top - margin.bottom;
        var chart = d3.select(chartPane).append('svg')
            .attr('width', width + margin.right + margin.left)
            .attr('height', height + margin.top + margin.bottom)
            .attr('class', 'chart ' + chartType);
        var chartBackground = chart.append("rect")
            .attr('width', fullWidth)
            .attr('height', fullHeight)
            .attr('class', 'chartBackground')
            .attr('style', 'fill: none;');
        var chartBody = chart.append('g')
            .attr('width', width)
            .attr('height', height)
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
            .attr('class', 'chartBody');
        var chartBodyBackground = chartBody.append("rect")
            .attr('width', width)
            .attr('height', height)
            .attr('class', 'chartBodyBackground')
            .attr('style', 'fill: none;');
        return {
            fullWidth: fullWidth,
            fullHeight: fullHeight,
            margin: margin,
            width: width,
            height: height,
            chart: chart,
            chartType: chartType,
            chartBackground: chartBackground,
            chartBody: chartBody,
            chartBodyBackground: chartBodyBackground,
            xScale: undefined,
            yScale: undefined,
            xQuestion: undefined,
            yQuestion: undefined,
            brush: undefined,
            brushend: undefined,
            subgraphQuestion: undefined,
            subgraphChoice: undefined
        };
    }
    // addXAxis(chart, xScale, {labelLengthLimit: 64, isSmallFormat: false, drawLongAxisLines: false, rotateAxisLabels: false});
    function addXAxis(chart, xScale, configure) {
        if (configure === void 0) { configure = null; }
        if (!configure)
            configure = {};
        var xAxis = d3.svg.axis()
            .scale(xScale)
            .orient('bottom');
        if (configure.isSmallFormat)
            xAxis.tickValues(xScale.domain());
        if (configure.drawLongAxisLines)
            xAxis.tickSize(-(chart.height));
        if (!configure.rotateAxisLabels) {
            var labels = chart.chartBody.append('g')
                .attr('transform', 'translate(0,' + chart.height + ')')
                .attr('class', 'x-axis')
                .call(xAxis).selectAll("text");
            if (configure.labelLengthLimit) {
                labels.text(function (d, i) {
                    return limitLabelLength(d, configure.labelLengthLimit);
                });
            }
            labels.append("svg:title").text(function (d, i) {
                return d;
            });
        }
        else {
            if (configure.labelLengthLimit) {
                xAxis.tickFormat(function (label) {
                    return limitLabelLength(label, configure.labelLengthLimit);
                });
            }
            // TODO: These do not have hovers
            chart.chartBody.append('g')
                .attr('transform', 'translate(0,' + chart.height + ')')
                .attr('class', 'x-axis')
                .call(xAxis).selectAll("text")
                .style("text-anchor", "end")
                .attr("dx", "-0.8em")
                .attr("dy", "0.15em")
                .attr("transform", function (d) {
                return "rotate(-65)";
            });
        }
        return xAxis;
    }
    // This function is very similar to the one for addXAxis, except for transform, tickFormat, CSS classes, and not needing rotate
    // yAxis = addYAxis(chart, yScale, {labelLengthLimit: 64, isSmallFormat: false, drawLongAxisLines: false});
    function addYAxis(chart, yScale, configure) {
        if (configure === void 0) { configure = null; }
        if (!configure)
            configure = {};
        var yAxis = d3.svg.axis()
            .scale(yScale)
            .orient('left');
        if (configure.labelLengthLimit) {
            yAxis.tickFormat(function (label) {
                return limitLabelLength(label, configure.labelLengthLimit);
            });
        }
        else {
            // This seems needed to ensure small numbers for labels don't get ".0" appended to them
            yAxis.tickFormat(d3.format("d"));
        }
        if (configure.isSmallFormat)
            yAxis.tickValues(yScale.domain());
        if (configure.drawLongAxisLines)
            yAxis.tickSize(-(chart.width));
        var labels = chart.chartBody.append('g')
            .attr('class', 'y-axis')
            .call(yAxis).selectAll("text");
        if (configure.labelLengthLimit) {
            labels.text(function (d, i) {
                return limitLabelLength(d, configure.labelLengthLimit);
            });
        }
        labels.append("svg:title").text(function (d, i) {
            // console.log("addYAxis label", d, i);
            return d;
        });
        return yAxis;
    }
    function addXAxisLabel(chart, label, labelLengthLimit, textAnchor) {
        if (labelLengthLimit === void 0) { labelLengthLimit = 64; }
        if (textAnchor === void 0) { textAnchor = "middle"; }
        var shortenedLabel = limitLabelLength(label, labelLengthLimit);
        var xPosition;
        var yPosition = chart.fullHeight - 16;
        if (textAnchor === "middle") {
            xPosition = chart.margin.left + chart.width / 2;
        }
        else if (textAnchor === "start") {
            xPosition = chart.margin.left;
            yPosition -= 25;
        }
        else if (textAnchor === "end") {
            xPosition = chart.margin.left + chart.width;
            yPosition -= 25;
        }
        var shortenedLabelSVG = chart.chart.append("text")
            .attr("class", "x-axis-label")
            .attr("text-anchor", textAnchor)
            .attr("x", xPosition)
            .attr("y", yPosition)
            .text(shortenedLabel);
        if (label.length > labelLengthLimit) {
            shortenedLabelSVG.append("svg:title")
                .text(label);
        }
    }
    function addYAxisLabel(chart, label, labelLengthLimit, textAnchor) {
        if (labelLengthLimit === void 0) { labelLengthLimit = 64; }
        if (textAnchor === void 0) { textAnchor = "middle"; }
        var shortenedLabel = limitLabelLength(label, labelLengthLimit);
        var xPosition;
        var yPosition = 16;
        if (textAnchor === "middle") {
            xPosition = -(chart.margin.top + chart.height / 2);
        }
        else if (textAnchor === "start") {
            xPosition = -(chart.margin.top + chart.height);
            yPosition += 25;
        }
        else if (textAnchor === "end") {
            xPosition = -chart.margin.top;
            yPosition += 25;
        }
        var shortenedLabelSVG = chart.chart.append("text")
            .attr("class", "y-axis-label")
            .attr("text-anchor", textAnchor)
            .attr("y", yPosition)
            .attr("x", xPosition)
            .attr("transform", "rotate(-90)")
            .text(shortenedLabel);
        if (label.length > labelLengthLimit) {
            shortenedLabelSVG.append("svg:title")
                .text(label);
        }
    }
    /*
    function addStatsHoverForChart(chart, stats) {
        var widget = chart.chart || d3.select(chart).append('svg');
        var rect = widget.append("rect")
            .attr("style", "stroke: rgb(255,255,255); fill: red;")
            .attr("x", 0)
            .attr("y", 0)
            .attr("height", 20)
            .attr("width", 20);
        rect.append("svg:title").text("Statistics: " + JSON.stringify(stats));
    }
    */
    // escapeHtml is from: http://shebang.brandonmintern.com/foolproof-html-escaping-in-javascript/
    function escapeHtml(str) {
        var div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }
    ;
    function htmlForLabelAndValue(key, object) {
        var value = object[key];
        if (value === undefined) {
            console.log("value is undefined");
        }
        if (key !== "n" && key !== "n1" && key !== "n2" && key !== "k" && key !== "U") {
            value = value.toFixed(3);
        }
        return '<span class="statistics-name">' + key + '</span>: <span class="statistics-value">' + value + "</span>";
    }
    function addStatisticsPanelForChart(chartPane, statistics) {
        var html = "";
        //html += '<div class="narrafirma-statistics-panel-header">Statistics</div>';
        if (statistics.calculated.length === 0) {
            html += "Statistics: " + statistics.significance;
        }
        else {
        }
        if (statistics.allResults) {
            html += '<span class="narrafirma-mann-whitney-title">Mann-Whitney U test results for multiple histograms</span><br>\n';
        }
        for (var i = 0; i < statistics.calculated.length; i++) {
            html += htmlForLabelAndValue(statistics.calculated[i], statistics) + "<br>\n";
        }
        if (statistics.allResults) {
            html += "<br>\n";
            html += '<table class="narrafirma-mw-all-results">\n';
            for (var resultKey in statistics.allResults) {
                var result = statistics.allResults[resultKey];
                html += '<tr><td class="narrafirma-mw-nested-title">' + escapeHtml(resultKey) + '</td><td class="narrafirma-mw-nested-stats">';
                var first = true;
                for (var key in result) {
                    if (!first) {
                        html += "; ";
                    }
                    else {
                        first = false;
                    }
                    html += htmlForLabelAndValue(key, result);
                }
                html += "</td></tr>\n";
            }
            html += "</table>\n";
        }
        var statsPane = document.createElement("div");
        statsPane.className = "narrafirma-statistics-panel";
        statsPane.innerHTML = html;
        chartPane.appendChild(statsPane);
    }
    // ---- Charts
    function d3BarChart(graphBrowserInstance, question, storiesSelectedCallback) {
        // Collect data
        var allPlotItems = [];
        var xLabels = [];
        var key;
        var results = {};
        preloadResultsForQuestionOptions(results, question);
        // change 0 to [] for preloaded results
        for (key in results) {
            results[key] = [];
        }
        var stories = graphBrowserInstance.allStories;
        for (var storyIndex in stories) {
            var story = stories[storyIndex];
            var xValue = correctForUnanswered(question, story.fieldValue(question.id));
            var xHasCheckboxes = _.isObject(xValue);
            // fast path
            if (!xHasCheckboxes) {
                pushToMapSlot(results, xValue, { story: story, value: xValue });
            }
            else {
                for (var xIndex in xValue) {
                    if (xValue[xIndex])
                        pushToMapSlot(results, xIndex, { story: story, value: xIndex });
                }
            }
        }
        for (key in results) {
            xLabels.push(key);
            allPlotItems.push({ name: key, stories: results[key], value: results[key].length });
        }
        var labelLengthLimit = 20;
        var longestLabelText = "";
        for (var label in results) {
            if (label.length > longestLabelText.length) {
                longestLabelText = label;
            }
        }
        var longestLabelTextLength = longestLabelText.length;
        if (longestLabelTextLength > labelLengthLimit) {
            longestLabelTextLength = labelLengthLimit + 3;
        }
        /*
        xLabels.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });
        */
        // Build chart
        // TODO: Improve the way labels are drawn or ellipsed based on chart size and font size and number of bars
        var chartPane = newChartPane(graphBrowserInstance, "singleChartStyle");
        var chartTitle = "" + nameForQuestion(question);
        var margin = { top: 20, right: 15, bottom: 90 + longestLabelTextLength * 5, left: 60 };
        var chart = makeChartFramework(chartPane, "barChart", false, margin);
        var chartBody = chart.chartBody;
        var statistics = calculateStatistics.calculateStatisticsForBarGraph(question, stories, graphBrowserInstance.minimumStoryCountRequiredForTest);
        addStatisticsPanelForChart(chartPane, statistics);
        // draw the x axis
        var xScale = d3.scale.ordinal()
            .domain(xLabels)
            .rangeRoundBands([0, chart.width], 0.1);
        chart.xScale = xScale;
        chart.xQuestion = question;
        var xAxis = addXAxis(chart, xScale, { labelLengthLimit: labelLengthLimit, rotateAxisLabels: true });
        addXAxisLabel(chart, nameForQuestion(question));
        // draw the y axis
        var maxItemsPerBar = d3.max(allPlotItems, function (plotItem) { return plotItem.value; });
        var yScale = d3.scale.linear()
            .domain([0, maxItemsPerBar])
            .range([chart.height, 0]);
        chart.yScale = yScale;
        // Extra version of scale for calculating heights without subtracting as in height - yScale(value)
        var yHeightScale = d3.scale.linear()
            .domain([0, maxItemsPerBar])
            .range([0, chart.height]);
        var yAxis = addYAxis(chart, yScale);
        addYAxisLabel(chart, "Count");
        // Append brush before data to ensure titles are drown
        chart.brush = createBrush(chartBody, xScale, null, brushend);
        var bars = chartBody.selectAll(".bar")
            .data(allPlotItems)
            .enter().append("g")
            .attr("class", "bar")
            .attr('transform', function (plotItem) { return 'translate(' + xScale(plotItem.name) + ',' + yScale(0) + ')'; });
        var barBackground = bars.append("rect")
            .attr("x", function (plotItem) { return 0; })
            .attr("y", function (plotItem) { return yHeightScale(-plotItem.value); })
            .attr("height", function (plotItem) { return yHeightScale(plotItem.value); })
            .attr("width", xScale.rangeBand());
        // Overlay stories on each bar...
        var storyDisplayItems = bars.selectAll(".story")
            .data(function (plotItem) { return plotItem.stories; })
            .enter().append("rect")
            .attr('class', function (d, i) { return "story " + ((i % 2 === 0) ? "even" : "odd"); })
            .attr("x", function (plotItem) { return 0; })
            .attr("y", function (plotItem, i) { return yHeightScale(-i - 1); })
            .attr("height", function (plotItem) { return yHeightScale(1); })
            .attr("width", xScale.rangeBand());
        // Add tooltips
        if (!graphBrowserInstance.excludeStoryTooltips) {
            storyDisplayItems.append("svg:title")
                .text(function (storyItem) {
                var story = storyItem.story;
                var tooltipText = "Title: " + story.storyName() +
                    // "\nID: " + story.storyID() + 
                    "\n" + nameForQuestion(question) + ": " + displayTextForAnswer(story.fieldValue(question.id)) +
                    "\nText: " + limitStoryTextLength(story.storyText());
                return tooltipText;
            });
        }
        supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayItems);
        function isPlotItemSelected(extent, plotItem) {
            var midPoint = xScale(plotItem.value) + xScale.rangeBand() / 2;
            return extent[0] <= midPoint && midPoint <= extent[1];
        }
        function brushend() {
            updateSelectedStories(chart, storyDisplayItems, graphBrowserInstance, storiesSelectedCallback, isPlotItemSelected);
        }
        chart.brushend = brushend;
        return chart;
    }
    exports.d3BarChart = d3BarChart;
    // Histogram reference for d3: http://bl.ocks.org/mbostock/3048450
    // choiceQuestion and choice may be undefined if this is just a simple histogram for all values
    function d3HistogramChart(graphBrowserInstance, scaleQuestion, choiceQuestion, choice, storiesSelectedCallback) {
        // console.log("graphBrowserInstance, scaleQuestion", graphBrowserInstance, scaleQuestion);
        // TODO: Statistics
        // Collect data
        // Do not include unanswered in  histogram
        // TODO: Put a total for unanswered somewhere
        var unanswered = [];
        var values = [];
        var matchingStories = [];
        var stories = graphBrowserInstance.allStories;
        for (var storyIndex in stories) {
            var story = stories[storyIndex];
            var xValue = correctForUnanswered(scaleQuestion, story.fieldValue(scaleQuestion.id));
            if (choiceQuestion) {
                // Only count results where the choice matches
                var choiceValue = correctForUnanswered(choiceQuestion, story.fieldValue(choiceQuestion.id));
                var skip = false;
                if (choiceQuestion.displayType === "checkboxes") {
                    if (!choiceValue[choice])
                        skip = true;
                }
                else {
                    if (choiceValue !== choice)
                        skip = true;
                }
                if (skip)
                    continue;
            }
            var newPlotItem = { story: story, value: xValue };
            if (xValue === unansweredKey) {
                unanswered.push(newPlotItem);
            }
            else {
                values.push(newPlotItem);
                matchingStories.push(story);
            }
        }
        // console.log("d3HistogramChart values", values.map(function(item) { return item.value; }), choiceQuestion);
        var resultIndex = 1;
        // Build chart
        var chartTitle = "" + nameForQuestion(scaleQuestion);
        // TODO: Maybe should translate choice?
        if (choiceQuestion)
            chartTitle = "" + choice;
        var isSmallFormat = !!choiceQuestion;
        var style = "singleChartStyle";
        if (isSmallFormat) {
            style = "multipleChartStyle";
        }
        var chartPane = newChartPane(graphBrowserInstance, style);
        var margin = { top: 20, right: 15, bottom: 60, left: 60 };
        if (isSmallFormat) {
            margin.left = 35;
        }
        else if (scaleQuestion.displayType === "slider") {
            margin.bottom += 30;
        }
        var chart = makeChartFramework(chartPane, "histogram", isSmallFormat, margin);
        var chartBody = chart.chartBody;
        var statistics = calculateStatistics.calculateStatisticsForHistogram(scaleQuestion, matchingStories, graphBrowserInstance.minimumStoryCountRequiredForTest);
        addStatisticsPanelForChart(chartPane, statistics);
        var mean = statistics.mean;
        var standardDeviation = statistics.sd;
        // Draw the x axis
        var xScale = d3.scale.linear()
            .domain([0, 100])
            .range([0, chart.width]);
        chart.xScale = xScale;
        chart.xQuestion = scaleQuestion;
        var xAxis = addXAxis(chart, xScale, { isSmallFormat: isSmallFormat });
        if (choiceQuestion) {
            addXAxisLabel(chart, choice, 18);
        }
        else {
            addXAxisLabel(chart, nameForQuestion(scaleQuestion));
            if (scaleQuestion.displayType === "slider") {
                addXAxisLabel(chart, scaleQuestion.displayConfiguration[0], maxRangeLabelLength, "start");
                addXAxisLabel(chart, scaleQuestion.displayConfiguration[1], maxRangeLabelLength, "end");
            }
        }
        // draw the y axis
        // Generate a histogram using twenty uniformly-spaced bins.
        // TODO: Casting to any to get around D3 typing limitation where it expects number not an object
        var data = d3.layout.histogram().bins(xScale.ticks(20)).value(function (d) { return d.value; })(values);
        // Set the bin for each plotItem
        data.forEach(function (bin) {
            bin.forEach(function (plotItem) {
                plotItem.xBinStart = bin.x;
            });
        });
        // TODO: May want to consider unanswered here if decide to plot it to the side
        var maxValue = d3.max(data, function (d) { return d.y; });
        var yScale = d3.scale.linear()
            .domain([0, maxValue])
            .range([chart.height, 0]);
        chart.yScale = yScale;
        chart.subgraphQuestion = choiceQuestion;
        chart.subgraphChoice = choice;
        // Extra version of scale for calculating heights without subtracting as in height - yScale(value)
        var yHeightScale = d3.scale.linear()
            .domain([0, maxValue])
            .range([0, chart.height]);
        var yAxis = addYAxis(chart, yScale, { isSmallFormat: isSmallFormat });
        if (!isSmallFormat) {
            addYAxisLabel(chart, "Frequency");
        }
        if (isSmallFormat) {
            chartBody.selectAll('.axis').style({ 'stroke-width': '1px', 'fill': 'gray' });
        }
        // Append brush before data to ensure titles are drown
        chart.brush = createBrush(chartBody, xScale, null, brushend);
        var bars = chartBody.selectAll(".bar")
            .data(data)
            .enter().append("g")
            .attr("class", "bar")
            .attr("transform", function (d) { return "translate(" + xScale(d.x) + "," + yScale(0) + ")"; });
        // Overlay stories on each bar...
        var storyDisplayItems = bars.selectAll(".story")
            .data(function (plotItem) { return plotItem; })
            .enter().append("rect")
            .attr('class', function (d, i) { return "story " + ((i % 2 === 0) ? "even" : "odd"); })
            .attr("x", function (plotItem) { return 0; })
            .attr("y", function (plotItem, i) { return yHeightScale(-i - 1); })
            .attr("height", function (plotItem) { return yHeightScale(1); })
            .attr("width", xScale(data[0].dx) - 1);
        // Add tooltips
        if (!graphBrowserInstance.excludeStoryTooltips) {
            storyDisplayItems.append("svg:title")
                .text(function (plotItem) {
                var story = plotItem.story;
                var tooltipText = "Title: " + story.storyName() +
                    "\n" + nameForQuestion(scaleQuestion) + ": " + plotItem.value +
                    "\nText: " + limitStoryTextLength(story.storyText());
                return tooltipText;
            });
        }
        supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayItems);
        if (!isNaN(mean)) {
            // Draw mean
            // console.log("mean", mean, valuesAsNumbers);
            chartBody.append("line")
                .attr('class', "histogram-mean")
                .attr("x1", xScale(mean))
                .attr("y1", yHeightScale(0))
                .attr("x2", xScale(mean))
                .attr("y2", yHeightScale(maxValue));
            if (!isNaN(standardDeviation)) {
                // Draw standard deviation
                // console.log("standard deviation", standardDeviation, valuesAsNumbers);
                var sdLow = mean - standardDeviation;
                var sdHigh = mean + standardDeviation;
                chartBody.append("line")
                    .attr('class', "histogram-standard-deviation-low")
                    .attr("x1", xScale(sdLow))
                    .attr("y1", yHeightScale(0))
                    .attr("x2", xScale(sdLow))
                    .attr("y2", yHeightScale(maxValue));
                chartBody.append("line")
                    .attr('class', "histogram-standard-deviation-high")
                    .attr("x1", xScale(sdHigh))
                    .attr("y1", yHeightScale(0))
                    .attr("x2", xScale(sdHigh))
                    .attr("y2", yHeightScale(maxValue));
            }
        }
        function isPlotItemSelected(extent, plotItem) {
            // We don't want to compute a midPoint based on plotItem.value which can be anywhere in the bin; we want to use the stored bin.x.
            var midPoint = plotItem.xBinStart + data[0].dx / 2;
            var selected = extent[0] <= midPoint && midPoint <= extent[1];
            return selected;
        }
        function brushend(doNotUpdateStoryList) {
            // Clear selections in other graphs
            if (_.isArray(graphBrowserInstance.currentGraph) && !doNotUpdateStoryList) {
                graphBrowserInstance.currentGraph.forEach(function (otherGraph) {
                    if (otherGraph !== chart) {
                        otherGraph.brush.brush.clear();
                        otherGraph.brush.brush(otherGraph.brush.brushGroup);
                        otherGraph.brushend("doNotUpdateStoryList");
                    }
                });
            }
            var callback = storiesSelectedCallback;
            if (doNotUpdateStoryList)
                callback = null;
            updateSelectedStories(chart, storyDisplayItems, graphBrowserInstance, callback, isPlotItemSelected);
        }
        chart.brushend = brushend;
        // TODO: Put up title
        return chart;
    }
    exports.d3HistogramChart = d3HistogramChart;
    // TODO: Need to update this to pass instance for self into histograms so they can clear the selections in other histograms
    // TODO: Also need to track the most recent histogram with an actual selection so can save and restore that from patterns browser
    function multipleHistograms(graphBrowserInstance, choiceQuestion, scaleQuestion, storiesSelectedCallback) {
        var options = [];
        var index;
        if (choiceQuestion.displayType !== "checkbox" && choiceQuestion.displayType !== "checkboxes") {
            options.push(unansweredKey);
        }
        if (choiceQuestion.displayType === "boolean" || choiceQuestion.displayType === "checkbox") {
            options.push("false");
            options.push("true");
        }
        else if (choiceQuestion.valueOptions) {
            for (index in choiceQuestion.valueOptions) {
                options.push(choiceQuestion.valueOptions[index]);
            }
        }
        // TODO: Could push extra options based on actual data choices (in case question changed at some point)
        /*
        options.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });
        */
        // TODO: This styling may be wrong
        var chartPane = newChartPane(graphBrowserInstance, "noStyle");
        var title = "" + nameForQuestion(scaleQuestion) + " vs. " + nameForQuestion(choiceQuestion) + " ...";
        var content = m("span", { style: "text-align: center;" }, [m("b", title), m("br")]);
        // TODO: Trying out rendering into node
        m.render(chartPane, content);
        // var content = domConstruct.toDom('<span style="text-align: center;"><b>' + title + '</b></span><br>');
        // chartPane.domNode.appendChild(content);
        var charts = [];
        for (index in options) {
            var option = options[index];
            // TODO: Maybe need to pass which chart to the storiesSelectedCallback
            var subchart = d3HistogramChart(graphBrowserInstance, scaleQuestion, choiceQuestion, option, storiesSelectedCallback);
            charts.push(subchart);
        }
        // End the float
        var clearFloat = document.createElement("br");
        clearFloat.style.clear = "left";
        graphBrowserInstance.graphResultsPane.appendChild(clearFloat);
        // Add these statistics at the bottom after all other graphs
        var statistics = calculateStatistics.calculateStatisticsForMultipleHistogram(scaleQuestion, choiceQuestion, graphBrowserInstance.allStories, graphBrowserInstance.minimumStoryCountRequiredForTest);
        addStatisticsPanelForChart(graphBrowserInstance.graphResultsPane, statistics);
        return charts;
    }
    exports.multipleHistograms = multipleHistograms;
    // Reference for initial scatter chart: http://bl.ocks.org/bunkat/2595950
    // Reference for brushing: http://bl.ocks.org/mbostock/4560481
    // Reference for brush and tooltip: http://wrobstory.github.io/2013/11/D3-brush-and-tooltip.html
    function d3ScatterPlot(graphBrowserInstance, xAxisQuestion, yAxisQuestion, storiesSelectedCallback) {
        // Collect data
        var allPlotItems = [];
        var stories = graphBrowserInstance.allStories;
        for (var index in stories) {
            var story = stories[index];
            var xValue = correctForUnanswered(xAxisQuestion, story.fieldValue(xAxisQuestion.id));
            var yValue = correctForUnanswered(yAxisQuestion, story.fieldValue(yAxisQuestion.id));
            // TODO: What do do about unanswered?
            if (xValue === unansweredKey || yValue === unansweredKey)
                continue;
            var newPlotItem = makePlotItem(xAxisQuestion, yAxisQuestion, xValue, yValue, story);
            allPlotItems.push(newPlotItem);
        }
        // Build chart
        var chartPane = newChartPane(graphBrowserInstance, "singleChartStyle");
        var chartTitle = "" + nameForQuestion(xAxisQuestion) + " vs. " + nameForQuestion(yAxisQuestion);
        // x 700 - 15 - 90 =  595 // y 500 - 20 - 90 = 390 // 205 difference to make square
        var margin = { top: 20, right: 15 + 205, bottom: 90, left: 90 };
        var chart = makeChartFramework(chartPane, "scatterPlot", false, margin);
        var chartBody = chart.chartBody;
        var statistics = calculateStatistics.calculateStatisticsForScatterPlot(xAxisQuestion, yAxisQuestion, stories, graphBrowserInstance.minimumStoryCountRequiredForTest);
        addStatisticsPanelForChart(chartPane, statistics);
        // draw the x axis
        var xScale = d3.scale.linear()
            .domain([0, 100])
            .range([0, chart.width]);
        chart.xScale = xScale;
        chart.xQuestion = xAxisQuestion;
        var xAxis = addXAxis(chart, xScale);
        addXAxisLabel(chart, nameForQuestion(xAxisQuestion));
        addXAxisLabel(chart, xAxisQuestion.displayConfiguration[0], maxRangeLabelLength, "start");
        addXAxisLabel(chart, xAxisQuestion.displayConfiguration[1], maxRangeLabelLength, "end");
        // draw the y axis
        var yScale = d3.scale.linear()
            .domain([0, 100])
            .range([chart.height, 0]);
        chart.yScale = yScale;
        chart.yQuestion = yAxisQuestion;
        var yAxis = addYAxis(chart, yScale);
        addYAxisLabel(chart, nameForQuestion(yAxisQuestion));
        addYAxisLabel(chart, yAxisQuestion.displayConfiguration[0], maxRangeLabelLength, "start");
        addYAxisLabel(chart, yAxisQuestion.displayConfiguration[1], maxRangeLabelLength, "end");
        // Append brush before data to ensure titles are drown
        chart.brush = createBrush(chartBody, xScale, yScale, brushend);
        var storyDisplayItems = chartBody.selectAll(".story")
            .data(allPlotItems)
            .enter().append("circle")
            .attr("class", "story")
            .attr("r", 8)
            .attr("cx", function (plotItem) { return xScale(plotItem.x); })
            .attr("cy", function (plotItem) { return yScale(plotItem.y); });
        // Add tooltips
        if (!graphBrowserInstance.excludeStoryTooltips) {
            storyDisplayItems
                .append("svg:title")
                .text(function (plotItem) {
                var tooltipText = "Title: " + plotItem.story.storyName() +
                    // "\nID: " + plotItem.story.storyID() + 
                    "\nX (" + nameForQuestion(xAxisQuestion) + "): " + plotItem.x +
                    "\nY (" + nameForQuestion(yAxisQuestion) + "): " + plotItem.y +
                    "\nText: " + limitStoryTextLength(plotItem.story.storyText());
                return tooltipText;
            });
        }
        supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayItems);
        function isPlotItemSelected(extent, plotItem) {
            return extent[0][0] <= plotItem.x && plotItem.x <= extent[1][0] && extent[0][1] <= plotItem.y && plotItem.y <= extent[1][1];
        }
        function brushend() {
            updateSelectedStories(chart, storyDisplayItems, graphBrowserInstance, storiesSelectedCallback, isPlotItemSelected);
        }
        chart.brushend = brushend;
        return chart;
    }
    exports.d3ScatterPlot = d3ScatterPlot;
    function d3ContingencyTable(graphBrowserInstance, xAxisQuestion, yAxisQuestion, storiesSelectedCallback) {
        // Collect data
        var columnLabels = {};
        var rowLabels = {};
        preloadResultsForQuestionOptions(columnLabels, xAxisQuestion);
        preloadResultsForQuestionOptions(rowLabels, yAxisQuestion);
        //columnLabels["{Total}"] = 0;
        //rowLabels["{Total}"] = 0;
        var xHasCheckboxes = xAxisQuestion.displayType === "checkboxes";
        var yHasCheckboxes = yAxisQuestion.displayType === "checkboxes";
        // collect data
        var results = {};
        var plotItemStories = {};
        var grandTotal = 0;
        var stories = graphBrowserInstance.allStories;
        for (var index in stories) {
            var story = stories[index];
            var xValue = correctForUnanswered(xAxisQuestion, story.fieldValue(xAxisQuestion.id));
            var yValue = correctForUnanswered(yAxisQuestion, story.fieldValue(yAxisQuestion.id));
            // fast path
            if (!xHasCheckboxes && !yHasCheckboxes) {
                incrementMapSlot(results, JSON.stringify({ x: xValue, y: yValue }));
                incrementMapSlot(results, JSON.stringify({ x: xValue }));
                incrementMapSlot(results, JSON.stringify({ y: yValue }));
                pushToMapSlot(plotItemStories, JSON.stringify({ x: xValue, y: yValue }), story);
                grandTotal++;
            }
            else {
                // one or both may be checkboxes, so do a loop for each and create plot items for every combination         
                var key;
                var xValues = [];
                var yValues = [];
                if (xHasCheckboxes) {
                    // checkboxes
                    for (key in xValue || {}) {
                        if (xValue[key]) {
                            xValues.push(key);
                        }
                    }
                }
                else {
                    xValues.push(xValue);
                }
                if (yHasCheckboxes) {
                    // checkboxes
                    for (key in yValue || {}) {
                        if (yValue[key]) {
                            yValues.push(key);
                        }
                    }
                }
                else {
                    yValues.push(yValue);
                }
                for (var xIndex in xValues) {
                    for (var yIndex in yValues) {
                        // TODO: Need to include stories...
                        incrementMapSlot(results, JSON.stringify({ x: xValues[xIndex], y: yValues[yIndex] }));
                        incrementMapSlot(results, JSON.stringify({ x: xValues[xIndex] }));
                        incrementMapSlot(results, JSON.stringify({ y: yValues[yIndex] }));
                        pushToMapSlot(plotItemStories, JSON.stringify({ x: xValues[xIndex], y: yValues[yIndex] }), story);
                        grandTotal++;
                    }
                }
            }
        }
        var labelLengthLimit = 20;
        var longestColumnText = "";
        for (var columnName in columnLabels) {
            if (columnName.length > longestColumnText.length) {
                longestColumnText = columnName;
            }
        }
        var longestColumnTextLength = longestColumnText.length;
        if (longestColumnTextLength > labelLengthLimit) {
            longestColumnTextLength = labelLengthLimit + 3;
        }
        var columnLabelsArray = [];
        for (var columnName in columnLabels) {
            columnLabelsArray.push(columnName);
        }
        var columnCount = columnLabelsArray.length;
        /*
        columnLabelsArray.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });
        */
        var longestRowText = "";
        for (var rowName in rowLabels) {
            if (rowName.length > longestRowText.length) {
                longestRowText = rowName;
            }
        }
        var longestRowTextLength = longestRowText.length;
        if (longestRowTextLength > labelLengthLimit) {
            longestRowTextLength = labelLengthLimit + 3;
        }
        var rowLabelsArray = [];
        for (var rowName in rowLabels) {
            rowLabelsArray.push(rowName);
        }
        var rowCount = rowLabelsArray.length;
        /*
        rowLabelsArray.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase()) return -1;
            if (a.toLowerCase() > b.toLowerCase()) return 1;
            return 0;
        });
        */
        var observedPlotItems = [];
        var expectedPlotItems = [];
        for (var ci in columnLabelsArray) {
            var c = columnLabelsArray[ci];
            for (var ri in rowLabelsArray) {
                var r = rowLabelsArray[ri];
                var xySelector = JSON.stringify({ x: c, y: r });
                var observedValue = results[xySelector] || 0;
                var storiesForNewPlotItem = plotItemStories[xySelector] || [];
                var observedPlotItem = { x: c, y: r, value: observedValue, stories: storiesForNewPlotItem };
                observedPlotItems.push(observedPlotItem);
                if (!xHasCheckboxes && !yHasCheckboxes) {
                    // Can only calculate expected and do chi-square if choices are exclusive
                    var columnSelector = JSON.stringify({ x: c });
                    var columnTotal = results[columnSelector] || 0;
                    var rowSelector = JSON.stringify({ y: r });
                    var rowTotal = results[rowSelector] || 0;
                    var expectedValue = (columnTotal * rowTotal) / stories.length;
                    var expectedPlotItem = { x: c, y: r, value: expectedValue };
                    expectedPlotItems.push(expectedPlotItem);
                }
            }
        }
        // Build chart
        // TODO: Improve the way labels are drawn or ellipsed based on chart size and font size and number of rows and columns
        var chartPane = newChartPane(graphBrowserInstance, "singleChartStyle");
        var chartTitle = "" + nameForQuestion(xAxisQuestion) + " vs. " + nameForQuestion(yAxisQuestion);
        var margin = { top: 20, right: 15, bottom: 90 + longestColumnTextLength * 3, left: 90 + longestRowTextLength * 5 };
        var chart = makeChartFramework(chartPane, "contingencyChart", false, margin);
        var chartBody = chart.chartBody;
        var statistics = calculateStatistics.calculateStatisticsForTable(xAxisQuestion, yAxisQuestion, stories, graphBrowserInstance.minimumStoryCountRequiredForTest);
        addStatisticsPanelForChart(chartPane, statistics);
        // X axis and label
        var xScale = d3.scale.ordinal()
            .domain(columnLabelsArray)
            .rangeRoundBands([0, chart.width], 0.1);
        chart.xScale = xScale;
        chart.xQuestion = xAxisQuestion;
        var xAxis = addXAxis(chart, xScale, { labelLengthLimit: labelLengthLimit, drawLongAxisLines: true, rotateAxisLabels: true });
        addXAxisLabel(chart, nameForQuestion(xAxisQuestion));
        // Y axis and label
        var yScale = d3.scale.ordinal()
            .domain(rowLabelsArray)
            .rangeRoundBands([chart.height, 0], 0.1);
        chart.yScale = yScale;
        chart.yQuestion = yAxisQuestion;
        var yAxis = addYAxis(chart, yScale, { labelLengthLimit: labelLengthLimit, drawLongAxisLines: true });
        addYAxisLabel(chart, nameForQuestion(yAxisQuestion));
        // Append brush before data to ensure titles are drown
        chart.brush = createBrush(chartBody, xScale, yScale, brushend);
        // Compute a scaling factor to map plotItem values onto a widgth and height
        var maxPlotItemValue = d3.max(observedPlotItems, function (plotItem) { return plotItem.value; });
        if (maxPlotItemValue === 0) {
            var xValueMultiplier = 0;
            var yValueMultiplier = 0;
        }
        else {
            var xValueMultiplier = xScale.rangeBand() / maxPlotItemValue / 2.0;
            var yValueMultiplier = yScale.rangeBand() / maxPlotItemValue / 2.0;
        }
        var storyDisplayClusters = chartBody.selectAll(".storyCluster")
            .data(observedPlotItems)
            .enter().append("ellipse")
            .attr("class", "storyCluster observed")
            .attr("rx", function (plotItem) { return xValueMultiplier * plotItem.value; })
            .attr("ry", function (plotItem) { return yValueMultiplier * plotItem.value; })
            .attr("cx", function (plotItem) { return xScale(plotItem.x) + xScale.rangeBand() / 2.0; })
            .attr("cy", function (plotItem) { return yScale(plotItem.y) + yScale.rangeBand() / 2.0; });
        if (expectedPlotItems.length) {
            var expectedDisplayClusters = chartBody.selectAll(".expected")
                .data(expectedPlotItems)
                .enter().append("ellipse")
                .attr("class", "expected")
                .attr("rx", function (plotItem) { return xValueMultiplier * plotItem.value; })
                .attr("ry", function (plotItem) { return yValueMultiplier * plotItem.value; })
                .attr("cx", function (plotItem) { return xScale(plotItem.x) + xScale.rangeBand() / 2.0; })
                .attr("cy", function (plotItem) { return yScale(plotItem.y) + yScale.rangeBand() / 2.0; });
        }
        // Add tooltips
        if (!graphBrowserInstance.excludeStoryTooltips) {
            storyDisplayClusters.append("svg:title")
                .text(function (plotItem) {
                var tooltipText = "X (" + nameForQuestion(xAxisQuestion) + "): " + plotItem.x +
                    "\nY (" + nameForQuestion(yAxisQuestion) + "): " + plotItem.y;
                if (!plotItem.stories || plotItem.stories.length === 0) {
                    tooltipText += "\n------ No stories ------";
                }
                else {
                    tooltipText += "\n------ Stories (" + plotItem.stories.length + ") ------";
                    for (var i = 0; i < plotItem.stories.length; i++) {
                        var story = plotItem.stories[i];
                        tooltipText += "\n" + story.storyName();
                    }
                }
                return tooltipText;
            });
        }
        supportStartingDragOverStoryDisplayItemOrCluster(chartBody, storyDisplayClusters);
        function isPlotItemSelected(extent, plotItem) {
            var midPointX = xScale(plotItem.x) + xScale.rangeBand() / 2;
            var midPointY = yScale(plotItem.y) + yScale.rangeBand() / 2;
            var selected = extent[0][0] <= midPointX && midPointX <= extent[1][0] && extent[0][1] <= midPointY && midPointY <= extent[1][1];
            return selected;
        }
        function brushend() {
            updateSelectedStories(chart, storyDisplayClusters, graphBrowserInstance, storiesSelectedCallback, isPlotItemSelected);
        }
        chart.brushend = brushend;
        return chart;
    }
    exports.d3ContingencyTable = d3ContingencyTable;
    // ---- Support updating stories in browser
    // The complementary decodeBraces function is in add_patternExplorer.js
    function encodeBraces(optionText) {
        return optionText.replace("{", "&#123;").replace("}", "&#125;");
    }
    function setCurrentSelection(chart, graphBrowserInstance, extent) {
        // console.log("setCurrentSelection", extent, chart.width, chart.height, chart.chartType);
        /* Chart types and scaling
        
        Bar
        X Ordinal
        X in screen coordinates
        
        Table
        X Ordinal
        Y Ordinal
        X, Y needed to be scaled
    
        Histogram
        X Linear
        X was already scaled to 100
        
        Scatter
        X Linear
        Y Linear
        X, Y were already scaled to 100
        
        */
        var x1;
        var x2;
        var y1;
        var y2;
        var selection;
        var width = chart.width;
        var height = chart.height;
        if (chart.chartType === "histogram" || chart.chartType === "scatterPlot") {
            // console.log("already scaled", chart.chartType);
            width = 100;
            height = 100;
        }
        if (_.isArray(extent[0])) {
            x1 = Math.round(100 * extent[0][0] / width);
            x2 = Math.round(100 * extent[1][0] / width);
            y1 = Math.round(100 * extent[0][1] / height);
            y2 = Math.round(100 * extent[1][1] / height);
            selection = {
                xAxis: encodeBraces(nameForQuestion(chart.xQuestion)),
                x1: x1,
                x2: x2,
                yAxis: encodeBraces(nameForQuestion(chart.yQuestion)),
                y1: y1,
                y2: y2
            };
        }
        else {
            x1 = Math.round(100 * extent[0] / width);
            x2 = Math.round(100 * extent[1] / width);
            selection = {
                xAxis: encodeBraces(nameForQuestion(chart.xQuestion)),
                x1: x1,
                x2: x2
            };
        }
        // console.log("selection", selection);
        graphBrowserInstance.currentSelectionExtentPercentages = selection;
        if (_.isArray(graphBrowserInstance.currentGraph)) {
            selection.subgraphQuestion = encodeBraces(nameForQuestion(chart.subgraphQuestion));
            selection.subgraphChoice = encodeBraces(chart.subgraphChoice);
        }
    }
    function updateSelectedStories(chart, storyDisplayItemsOrClusters, graphBrowserInstance, storiesSelectedCallback, selectionTestFunction) {
        var extent = chart.brush.brush.extent();
        // console.log("updateSelectedStories extent", extent);
        setCurrentSelection(chart, graphBrowserInstance, extent);
        var selectedStories = [];
        storyDisplayItemsOrClusters.classed("selected", function (plotItem) {
            var selected = selectionTestFunction(extent, plotItem);
            var story;
            if (selected) {
                if (plotItem.stories) {
                    for (var i = 0; i < plotItem.stories.length; i++) {
                        story = plotItem.stories[i];
                        if (selectedStories.indexOf(story) === -1)
                            selectedStories.push(story);
                    }
                }
                else {
                    story = plotItem.story;
                    if (!story)
                        throw new Error("Expected story in plotItem");
                    if (selectedStories.indexOf(story) === -1)
                        selectedStories.push(story);
                }
            }
            return selected;
        });
        if (storiesSelectedCallback) {
            // console.log("updateSelectedStories doing callback", selectedStories);
            storiesSelectedCallback(selectedStories);
            // TODO: Maybe could call sm.startComputation/m.endComputation around this instead?
            // Since this event is generated by d3, need to redraw afterwards 
            m.redraw();
        }
    }
    function restoreSelection(chart, selection) {
        var extent;
        if (chart.chartType === "histogram") {
            extent = [selection.x1, selection.x2];
        }
        else if (chart.chartType === "scatterPlot") {
            extent = [[selection.x1, selection.y1], [selection.x2, selection.y2]];
        }
        else if (chart.chartType === "barChart") {
            extent = [selection.x1 * chart.width / 100, selection.x2 * chart.width / 100];
        }
        else if (chart.chartType === "contingencyChart") {
            extent = [[selection.x1 * chart.width / 100, selection.y1 * chart.height / 100], [selection.x2 * chart.width / 100, selection.y2 * chart.height / 100]];
        }
        else {
            return false;
        }
        chart.brush.brush.extent(extent);
        chart.brush.brush(chart.brush.brushGroup);
        chart.brushend();
        return true;
    }
    exports.restoreSelection = restoreSelection;
    function newChartPane(graphBrowserInstance, styleClass) {
        var chartPane = document.createElement("div");
        chartPane.className = styleClass;
        graphBrowserInstance.chartPanes.push(chartPane);
        graphBrowserInstance.graphResultsPane.appendChild(chartPane);
        return chartPane;
    }
    function createGraphResultsPane(theClass) {
        var pane = document.createElement("div");
        pane.className = theClass;
        return pane;
    }
    exports.createGraphResultsPane = createGraphResultsPane;
});

define('js/panelBuilder/valuePathResolver',["require", "exports", "../Globals"], function (require, exports, Globals) {
    "use strict";
    /*
    ValuePathResolver helps with getting and setting values that are nested inside multiple objects.
    It also helps with getting and setting valeus stores in a triple store.
    
    ValuePathResolver will start from a supplied baseModel and sequentially move along a series of fields
    defined in a valuePath string and separated by slashes.
    It resolves the object at each position in the path and uses that to resolve the next part of the valuePath.
    
    If the baseModel is a string instead of a JavaScript objects,
    it uses that as the "A" field of a triple to use with a triple store lookup.
    In that case, the "B" field of the tripel is the field in the value path.
    If a value is beign set, the "C" field in the triple is the new value being set, and A and B are the same as for the lookup.
    
    If part of a path is a function, it uses that function to get the field's value -- or set the value, if it is the final field.
    
    If the valuePath starts with "/", the resolution process will use an optional supplied context object instead of the baseModel.
    This is useful when building a panel where most of the panel fields use the same model,
    but one or two fields or options may relay on values in the project or configuration or such.
    
    An example valuePath starting from the baseModel with three segments is "a/b/c".
    That would resolve to "baseModel.a.b.c" or set as "baseModel.a.b.c = newValue".
    
    An example valuePath starting from the context with two segments is: "/project/userIdentifier".
    That would resolve to "context.project.userIdentifier".
    */
    var ValuePathResolver = (function () {
        function ValuePathResolver(baseModel, valuePath, isAccessFunctionRequired) {
            if (isAccessFunctionRequired === void 0) { isAccessFunctionRequired = false; }
            this.baseModel = baseModel;
            this.valuePath = valuePath;
            this.isAccessFunctionRequired = isAccessFunctionRequired;
        }
        ValuePathResolver.prototype.failIfAccessFunctionRequired = function () {
            if (this.isAccessFunctionRequired) {
                console.log("access function required", this);
                // alert("access function required");
                throw new Error("access function required " + this.valuePath);
            }
        };
        ValuePathResolver.prototype.resolveModelAndField = function () {
            var currentModel = this.baseModel;
            var currentKey;
            // console.log("++++++++++++++ resolveModelAndField start", this.valuePath, this.baseModel, Globals);
            // Parse the dependency path
            var pathParts = this.valuePath.split("/");
            var isGlobalReference = false;
            var useTripleStore = false;
            // If the path starts with "/", use the context as the model
            if (pathParts[0] === "") {
                isGlobalReference = true;
                pathParts.shift();
                currentModel = Globals;
                if (!currentModel) {
                    console.log("no object for context", currentKey, this.valuePath, Globals);
                    return undefined;
                }
            }
            if (pathParts.length < 1)
                throw new Error("Incorrect dependency path specified: " + this.valuePath);
            while (pathParts.length > 1) {
                currentKey = pathParts.shift();
                // console.log("resolveModelAndField", currentModel, currentKey);
                // TODO: Hard to distinguish with this between an incorrect path that might reference a field set somewhere to a string
                if (typeof currentModel === "string") {
                    useTripleStore = true;
                }
                var nextModel;
                var currentModelDirectFieldValue = currentModel[currentKey];
                var useAccessorFunction = !useTripleStore && typeof currentModelDirectFieldValue === "function";
                if (useTripleStore) {
                    this.failIfAccessFunctionRequired();
                    nextModel = Globals.project().tripleStore.queryLatestC(currentModel, currentKey);
                }
                else if (useAccessorFunction) {
                    nextModel = currentModel[currentKey]();
                }
                else if (currentModelDirectFieldValue === undefined && currentModel.fieldValue && typeof currentModel.fieldValue === "function") {
                    nextModel = currentModel.fieldValue(currentKey);
                }
                else {
                    this.failIfAccessFunctionRequired();
                    nextModel = currentModel[currentKey];
                }
                if (!nextModel) {
                    console.log("model is null while iterating", currentKey, pathParts.length, this.valuePath, currentModel);
                    return undefined;
                }
                currentModel = nextModel;
                if (typeof currentModel === "string") {
                    useTripleStore = true;
                }
            }
            if (typeof currentModel === "string") {
                useTripleStore = true;
            }
            var field = pathParts[0];
            var result = {
                model: currentModel,
                field: field,
                isGlobalReference: isGlobalReference,
                useTripleStore: useTripleStore
            };
            // console.log("resolveModelAndField result", result);
            return result;
        };
        ValuePathResolver.prototype.resolve = function (value) {
            if (value === void 0) { value = undefined; }
            // console.log("resolve", this.valuePath, value, this);
            var modelAndField = this.resolveModelAndField();
            if (!modelAndField) {
                console.log("ERROR: modelAndField is undefined or null", this);
                return null;
            }
            var modelFieldDirectValue = modelAndField.model[modelAndField.field];
            var useAccessorFunction = !modelAndField.useTripleStore && typeof modelFieldDirectValue === "function";
            if (value !== undefined) {
                if (modelAndField === undefined) {
                    console.log("Model missing; can't set value", this.valuePath, this.baseModel, Globals);
                    return undefined;
                }
                if (modelAndField.useTripleStore) {
                    this.failIfAccessFunctionRequired();
                    Globals.project().tripleStore.addTriple(modelAndField.model, modelAndField.field, value);
                }
                else if (useAccessorFunction) {
                    modelAndField.model[modelAndField.field](value);
                }
                else if (modelFieldDirectValue === undefined && modelAndField.model.fieldValue && typeof modelAndField.model.fieldValue === "function") {
                    modelAndField.model.fieldValue(modelAndField.field, value);
                }
                else {
                    this.failIfAccessFunctionRequired();
                    modelAndField.model[modelAndField.field] = value;
                }
                // console.log("resolve-set", this.valuePath, value, modelAndField, this);
                // Design issue: Should a set return this or the value? Using value to me like m.prop, but prevents chaining
                return value;
            }
            else {
                if (modelAndField === undefined)
                    return undefined;
                if (modelAndField.useTripleStore) {
                    this.failIfAccessFunctionRequired();
                    value = Globals.project().tripleStore.queryLatestC(modelAndField.model, modelAndField.field);
                }
                else if (useAccessorFunction) {
                    value = modelAndField.model[modelAndField.field]();
                }
                else if (modelFieldDirectValue === undefined && modelAndField.model.fieldValue && typeof modelAndField.model.fieldValue === "function") {
                    return modelAndField.model.fieldValue(modelAndField.field);
                }
                else {
                    this.failIfAccessFunctionRequired();
                    value = modelAndField.model[modelAndField.field];
                }
                // console.log("resolve-get", this.valuePath, value, modelAndField, this);
                return value;
            }
        };
        return ValuePathResolver;
    })();
    function newValuePathForFieldSpecification(model, fieldSpecification) {
        // console.log("newValuePathForFieldSpecification", fieldSpecification);
        var valuePath = fieldSpecification.valuePath;
        if (!valuePath)
            valuePath = fieldSpecification.id;
        return newValuePath(model, valuePath);
    }
    exports.newValuePathForFieldSpecification = newValuePathForFieldSpecification;
    function newValuePath(model, valuePath) {
        // console.log("newValuePath", valuePath);
        var valuePathResolver = new ValuePathResolver(model, valuePath);
        return valuePathResolver.resolve.bind(valuePathResolver);
    }
    exports.newValuePath = newValuePath;
});

// From CryptoJS: http://crypto-js.googlecode.com/svn/tags/3.1.2/src/sha256.js
define('js/pointrel20150417/sha256',["require", "exports"], function (require, exports) {
    /* tslint:disable no-bitwise */
    /**
     * CryptoJS namespace.
     */
    var C = {
        SHA256: undefined
    };
    /**
     * Base object for prototypal inheritance.
     */
    var Base = (function () {
        function F() { }
        return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function (overrides) {
                if (overrides === void 0) { overrides = undefined; }
                // Spawn
                F.prototype = this;
                var subtype = new F();
                // Augment
                if (overrides) {
                    subtype.mixIn(overrides);
                }
                // Create default initializer
                if (!subtype.hasOwnProperty('init')) {
                    subtype.init = function () {
                        subtype.$super.init.apply(this, arguments);
                    };
                }
                // Initializer's prototype is the subtype object
                subtype.init.prototype = subtype;
                // Reference supertype
                subtype.$super = this;
                return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function () {
                var instance = this.extend();
                instance.init.apply(instance, arguments);
                return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function () {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function (properties) {
                for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                        this[propertyName] = properties[propertyName];
                    }
                }
                // IE won't copy toString using the loop above
                if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function () {
                return this.init.prototype.extend(this);
            }
        };
    }());
    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */
    var WordArray = Base.extend({
        /**
         * Initializes a newly created word array.
         *
         * @param {Array} words (Optional) An array of 32-bit words.
         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.create();
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
         */
        init: function (words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined) {
                this.sigBytes = sigBytes;
            }
            else {
                this.sigBytes = words.length * 4;
            }
        },
        /**
         * Converts this word array to a string.
         *
         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
         *
         * @return {string} The stringified word array.
         *
         * @example
         *
         *     var string = wordArray + '';
         *     var string = wordArray.toString();
         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
         */
        toString: function (encoder) {
            return (encoder || Hex).stringify(this);
        },
        /**
         * Concatenates a word array to this word array.
         *
         * @param {WordArray} wordArray The word array to append.
         *
         * @return {WordArray} This word array.
         *
         * @example
         *
         *     wordArray1.concat(wordArray2);
         */
        concat: function (wordArray) {
            // Shortcuts
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            // Clamp excess bits
            this.clamp();
            // Concat
            if (thisSigBytes % 4) {
                // Copy one byte at a time
                for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                }
            }
            else if (thatWords.length > 0xffff) {
                // Copy one word at a time
                for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                }
            }
            else {
                // Copy all words at once
                thisWords.push.apply(thisWords, thatWords);
            }
            this.sigBytes += thatSigBytes;
            // Chainable
            return this;
        },
        /**
         * Removes insignificant bits.
         *
         * @example
         *
         *     wordArray.clamp();
         */
        clamp: function () {
            // Shortcuts
            var words = this.words;
            var sigBytes = this.sigBytes;
            // Clamp
            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
            words.length = Math.ceil(sigBytes / 4);
        },
        /**
         * Creates a copy of this word array.
         *
         * @return {WordArray} The clone.
         *
         * @example
         *
         *     var clone = wordArray.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
        },
        /**
         * Creates a word array filled with random bytes.
         *
         * @param {number} nBytes The number of random bytes to generate.
         *
         * @return {WordArray} The random word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.lib.WordArray.random(16);
         */
        random: function (nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
                words.push((Math.random() * 0x100000000) | 0);
            }
            return new WordArray.init(words, nBytes);
        }
    });
    /**
     * Hex encoding strategy.
     */
    var Hex = {
        /**
         * Converts a word array to a hex string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The hex string.
         *
         * @static
         *
         * @example
         *
         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            // Convert
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                hexChars.push((bite >>> 4).toString(16));
                hexChars.push((bite & 0x0f).toString(16));
            }
            return hexChars.join('');
        },
        /**
         * Converts a hex string to a word array.
         *
         * @param {string} hexStr The hex string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
         */
        parse: function (hexStr) {
            // Shortcut
            var hexStrLength = hexStr.length;
            // Convert
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
            }
            return new WordArray.init(words, hexStrLength / 2);
        }
    };
    /**
     * Latin1 encoding strategy.
     */
    var Latin1 = {
        /**
         * Converts a word array to a Latin1 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The Latin1 string.
         *
         * @static
         *
         * @example
         *
         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
         */
        stringify: function (wordArray) {
            // Shortcuts
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            // Convert
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join('');
        },
        /**
         * Converts a Latin1 string to a word array.
         *
         * @param {string} latin1Str The Latin1 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
         */
        parse: function (latin1Str) {
            // Shortcut
            var latin1StrLength = latin1Str.length;
            // Convert
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
            }
            return new WordArray.init(words, latin1StrLength);
        }
    };
    /**
     * UTF-8 encoding strategy.
     */
    var Utf8 = {
        /**
         * Converts a word array to a UTF-8 string.
         *
         * @param {WordArray} wordArray The word array.
         *
         * @return {string} The UTF-8 string.
         *
         * @static
         *
         * @example
         *
         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
         */
        stringify: function (wordArray) {
            try {
                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            }
            catch (e) {
                throw new Error('Malformed UTF-8 data');
            }
        },
        /**
         * Converts a UTF-8 string to a word array.
         *
         * @param {string} utf8Str The UTF-8 string.
         *
         * @return {WordArray} The word array.
         *
         * @static
         *
         * @example
         *
         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
         */
        parse: function (utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
        }
    };
    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */
    var BufferedBlockAlgorithm = Base.extend({
        /**
         * Resets this block algorithm's data buffer to its initial state.
         *
         * @example
         *
         *     bufferedBlockAlgorithm.reset();
         */
        reset: function () {
            // Initial values
            this._data = new WordArray.init();
            this._nDataBytes = 0;
        },
        /**
         * Adds new data to this block algorithm's buffer.
         *
         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
         *
         * @example
         *
         *     bufferedBlockAlgorithm._append('data');
         *     bufferedBlockAlgorithm._append(wordArray);
         */
        _append: function (data) {
            // Convert string to WordArray, else assume WordArray already
            if (typeof data == 'string') {
                data = Utf8.parse(data);
            }
            // Append
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
        },
        /**
         * Processes available data blocks.
         *
         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
         *
         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
         *
         * @return {WordArray} The processed data.
         *
         * @example
         *
         *     var processedData = bufferedBlockAlgorithm._process();
         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
         */
        _process: function (doFlush) {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            // Count blocks ready
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
                // Round up to include partial blocks
                nBlocksReady = Math.ceil(nBlocksReady);
            }
            else {
                // Round down to include only full blocks,
                // less the number of blocks that must remain in the buffer
                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            // Count words ready
            var nWordsReady = nBlocksReady * blockSize;
            // Count bytes ready
            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
            // Process blocks
            if (nWordsReady) {
                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                }
                // Remove processed words
                var processedWords = dataWords.splice(0, nWordsReady);
                data.sigBytes -= nBytesReady;
            }
            // Return processed words
            return new WordArray.init(processedWords, nBytesReady);
        },
        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = bufferedBlockAlgorithm.clone();
         */
        clone: function () {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
        },
        _minBufferSize: 0
    });
    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */
    var Hasher = BufferedBlockAlgorithm.extend({
        /**
         * Configuration options.
         */
        cfg: Base.extend(),
        /**
         * Initializes a newly created hasher.
         *
         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
         *
         * @example
         *
         *     var hasher = CryptoJS.algo.SHA256.create();
         */
        init: function (cfg) {
            // Apply config defaults
            this.cfg = this.cfg.extend(cfg);
            // Set initial values
            this.reset();
        },
        /**
         * Resets this hasher to its initial state.
         *
         * @example
         *
         *     hasher.reset();
         */
        reset: function () {
            // Reset data buffer
            BufferedBlockAlgorithm.reset.call(this);
            // Perform concrete-hasher logic
            this._doReset();
        },
        /**
         * Updates this hasher with a message.
         *
         * @param {WordArray|string} messageUpdate The message to append.
         *
         * @return {Hasher} This hasher.
         *
         * @example
         *
         *     hasher.update('message');
         *     hasher.update(wordArray);
         */
        update: function (messageUpdate) {
            // Append
            this._append(messageUpdate);
            // Update the hash
            this._process();
            // Chainable
            return this;
        },
        /**
         * Finalizes the hash computation.
         * Note that the finalize operation is effectively a destructive, read-once operation.
         *
         * @param {WordArray|string} messageUpdate (Optional) A final message update.
         *
         * @return {WordArray} The hash.
         *
         * @example
         *
         *     var hash = hasher.finalize();
         *     var hash = hasher.finalize('message');
         *     var hash = hasher.finalize(wordArray);
         */
        finalize: function (messageUpdate) {
            // Final message update
            if (messageUpdate) {
                this._append(messageUpdate);
            }
            // Perform concrete-hasher logic
            var hash = this._doFinalize();
            return hash;
        },
        blockSize: 512 / 32,
        /**
         * Creates a shortcut function to a hasher's object interface.
         *
         * @param {Hasher} hasher The hasher to create a helper for.
         *
         * @return {Function} The shortcut function.
         *
         * @static
         *
         * @example
         *
         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
         */
        _createHelper: function (hasher) {
            return function (message, cfg) {
                return new hasher.init(cfg).finalize(message);
            };
        },
    });
    // Initialization and round constants tables
    var H = [];
    var K = [];
    // Compute constants
    (function () {
        function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) {
                if (!(n % factor)) {
                    return false;
                }
            }
            return true;
        }
        function getFractionalBits(n) {
            return ((n - (n | 0)) * 0x100000000) | 0;
        }
        var n = 2;
        var nPrime = 0;
        while (nPrime < 64) {
            if (isPrime(n)) {
                if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                }
                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
                nPrime++;
            }
            n++;
        }
    }());
    // Reusable object
    var W = [];
    /**
     * SHA-256 hash algorithm.
     */
    var SHA256 = Hasher.extend({
        _doReset: function () {
            this._hash = new WordArray.init(H.slice(0));
        },
        _doProcessBlock: function (M, offset) {
            // Shortcut
            var H = this._hash.words;
            // Working variables
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];
            // Computation
            for (var i = 0; i < 64; i++) {
                if (i < 16) {
                    W[i] = M[offset + i] | 0;
                }
                else {
                    var gamma0x = W[i - 15];
                    var gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^
                        ((gamma0x << 14) | (gamma0x >>> 18)) ^
                        (gamma0x >>> 3);
                    var gamma1x = W[i - 2];
                    var gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                        ((gamma1x << 13) | (gamma1x >>> 19)) ^
                        (gamma1x >>> 10);
                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                }
                var ch = (e & f) ^ (~e & g);
                var maj = (a & b) ^ (a & c) ^ (b & c);
                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));
                var t1 = h + sigma1 + ch + K[i] + W[i];
                var t2 = sigma0 + maj;
                h = g;
                g = f;
                f = e;
                e = (d + t1) | 0;
                d = c;
                c = b;
                b = a;
                a = (t1 + t2) | 0;
            }
            // Intermediate hash value
            H[0] = (H[0] + a) | 0;
            H[1] = (H[1] + b) | 0;
            H[2] = (H[2] + c) | 0;
            H[3] = (H[3] + d) | 0;
            H[4] = (H[4] + e) | 0;
            H[5] = (H[5] + f) | 0;
            H[6] = (H[6] + g) | 0;
            H[7] = (H[7] + h) | 0;
        },
        _doFinalize: function () {
            // Shortcuts
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            // Add padding
            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            // Hash final blocks
            this._process();
            // Return final computed hash
            return this._hash;
        },
        clone: function () {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
        }
    });
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */
    C.SHA256 = Hasher._createHelper(SHA256);
    return C;
});

define('js/pointrel20150417/stringToUtf8',["require", "exports"], function (require, exports) {
    "use strict";
    // From http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function stringToUtf8(input) {
        return unescape(encodeURIComponent(input));
    }
    ;
    return stringToUtf8;
});

define('js/pointrel20150417/topic',["require", "exports"], function (require, exports) {
    "use strict";
    var subscriptions = {};
    var subscriptionsCount = 0;
    function subscribe(topic, callback) {
        var topicKey = JSON.stringify(topic);
        if (!subscriptions[topicKey])
            subscriptions[topicKey] = {};
        var uniqueIndex = subscriptionsCount++;
        subscriptions[topicKey][uniqueIndex] = callback;
        // Return a handle with a remove function to remove this this subscription
        return {
            remove: function () {
                delete subscriptions[topicKey][uniqueIndex];
            }
        };
    }
    exports.subscribe = subscribe;
    function publish(topic) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        var topicKey = JSON.stringify(topic);
        if (!subscriptions[topicKey])
            return;
        var callbacksForTopic = subscriptions[topicKey];
        for (var callbackKey in callbacksForTopic) {
            var callback = callbacksForTopic[callbackKey];
            callback.apply(null, data);
        }
    }
    exports.publish = publish;
});

// Pointrel20150417 for NodeJS and WordPress
// The focus is on client getting all messages of interest as they are received by the server and indexing them locally
// Each message needs to have enough easily available metadata for the server and client to do that filtering
define('js/pointrel20150417/PointrelClient',["require", "exports", "./sha256", "./stringToUtf8", "./topic"], function (require, exports, sha256, stringToUtf8, topic) {
    "use strict";
    var defaultCheckFrequency_ms = 15000;
    var shortTimeout_ms = 10000;
    var longTimeout_ms = 30000;
    var debugMessaging = false;
    // TODO: Think more deeply about what server status can be, like states it transitions through
    // (perhaps startup, polling, loading, storing, waiting-to-poll, timed-out, recovering, etc.)
    // TODO: Handle the queue of outgoing messages better, and don't allow for possibility one could
    // get dropped if timeout or server failure or such
    // TODO: Flag if you don't want to receive incoming messages that you sent if they are in the order sent
    // TODO: (Maybe) Flag if you don't want to receive any of the messages that you sent...
    // The userCredentials have the form {userIdentifier: "some name", userPassword: "some password"}
    // If a string is passed in, it is assumed just the userIdentifier is being supplied
    var PointrelClient = (function () {
        function PointrelClient(apiURL, journalIdentifier, userCredentials, messageReceivedCallback, serverStatusCallback) {
            if (messageReceivedCallback === void 0) { messageReceivedCallback = null; }
            if (serverStatusCallback === void 0) { serverStatusCallback = null; }
            this.apiURL = null;
            this.journalIdentifier = null;
            this.userIdentifier = null;
            this.started = false;
            this.frequencyOfChecks_ms = defaultCheckFrequency_ms;
            this.timer = null;
            // By default, includeMessageContents of true will retrieve the message contents when polling to reduce back-and-forth latency to server
            // Clients might want to turn this off if they cache messages locally
            // or if they application selectively downloads big messages like images or other media perhaps depending on the topic they are in
            this.includeMessageContents = true;
            // This field is used to ensure only one request at a time is sent to the server
            this.outstandingServerRequestSentAtTimestamp = null;
            // TODO: This flag may no longer be needed on the client libary side; app should implement something like it somehow?
            this.serverResponseWarningIssued = false;
            this.lastReceivedTimestampConsidered = null;
            this.incomingMessageRecords = [];
            this.messagesSortedByReceivedTimeArray = [];
            this.sha256AndLengthToMessageMap = {};
            this.areOutgoingMessagesSuspended = false;
            this.outgoingMessageQueue = [];
            this.messageReceivedCallback = null;
            this.serverStatusCallback = null;
            this.messageSentCount = 0;
            this.messageReceivedCount = 0;
            this.topicIdentifier = undefined;
            this.idleCallback = null;
            if (!apiURL)
                throw new Error("No apiURL supplied");
            if (!journalIdentifier)
                throw new Error("No journalIdentifier supplied");
            if (!userCredentials)
                throw new Error("No userCredentials supplied");
            if (typeof userCredentials === "string" || userCredentials instanceof String) {
                userCredentials = {
                    userIdentifier: userCredentials
                };
            }
            // Use the WordPress AJAX api instead as an override if it is defined
            this.apiURL = window["ajaxurl"] || apiURL;
            this.journalIdentifier = journalIdentifier;
            this.userIdentifier = userCredentials.userIdentifier;
            // private variable to protect against access by other code; see: http://javascript.crockford.com/private.html
            var _userCredentials = userCredentials;
            // privileged method that can access private variable
            this["_prepareApiRequestForSending"] = function (apiRequest) {
                apiRequest.userCredentials = _userCredentials;
            };
            this.messageReceivedCallback = messageReceivedCallback;
            this.serverStatusCallback = serverStatusCallback;
        }
        PointrelClient.prototype.prepareApiRequestForSending = function (apiRequest) {
            // Call privileged method that can access private variable
            return this["_prepareApiRequestForSending"](apiRequest);
        };
        // This should be called to start the polling process to keep a client up-to-date with what is in a Journal
        // You should not start polling though if you just want to get the latest message in a topic
        //  like for an application that selectively loads just a bit of published data
        PointrelClient.prototype.startup = function () {
            console.log(new Date().toISOString(), "starting up PointrelClient", this);
            if (this.apiURL === "loopback") {
                console.log("No polling done on loopback");
            }
            else {
                this.started = true;
                this.startTimer();
                this.pollServerForNewMessages();
            }
        };
        // Call this to shut down polling, like when you destroy a related GUI component
        PointrelClient.prototype.shutdown = function () {
            console.log(new Date().toISOString(), "shutting down PointrelClient", this);
            this.stopTimer();
            this.started = false;
        };
        /*
        createAndSendAddTriplesMessage(topicIdentifier, triples) {
            var change = {
                action: "addTriples",
                triples: triples
            };
            
            return this.createAndSendChangeMessage(topicIdentifier, "TripleStore", change);
        }
        */
        PointrelClient.prototype.apiRequestSend = function (apiRequest, timeout_ms, successCallback, errorCallback) {
            var httpRequest = new XMLHttpRequest();
            httpRequest.onreadystatechange = function () {
                if (httpRequest.readyState === 4) {
                    if (httpRequest.status >= 200 && httpRequest.status < 300) {
                        if (successCallback) {
                            var response = JSON.parse(httpRequest.responseText);
                            successCallback(response);
                        }
                    }
                    else {
                        // TODO: Might these sometimes be JSON?
                        if (errorCallback)
                            errorCallback({ status: httpRequest.status, message: httpRequest.responseText });
                    }
                }
            };
            httpRequest.ontimeout = function () {
                errorCallback({ status: 0, message: "Timeout" });
            };
            var isWordPressAJAX = !!window["ajaxurl"];
            var apiURL = this.apiURL;
            var contentType = 'application/json; charset=utf-8';
            var data = JSON.stringify(apiRequest);
            if (isWordPressAJAX) {
                apiURL = apiURL + "?action=pointrel20150417";
            }
            httpRequest.open('POST', apiURL, true);
            httpRequest.setRequestHeader('Content-Type', contentType);
            httpRequest.setRequestHeader("Accept", "application/json");
            httpRequest.timeout = timeout_ms;
            httpRequest.send(data);
        };
        PointrelClient.prototype.createChangeMessage = function (topicIdentifier, messageType, change, other) {
            var timestamp = this.getCurrentUniqueTimestamp();
            var message = {
                // TODO: Simplify redundancy in timestamps
                _topicIdentifier: topicIdentifier,
                _topicTimestamp: timestamp,
                // messageIdentifier: generateRandomUuid("Message"), // Is this needed, as we have a unique ID from SHA256?
                creator: this.userIdentifier,
                creationTimestamp: timestamp,
                // TODO: createdAfter: something involving incoming records...
                messageType: messageType,
                change: change
            };
            if (other) {
                for (var key in other) {
                    message[key] = other[key];
                }
            }
            return message;
        };
        PointrelClient.prototype.createAndSendChangeMessage = function (topicIdentifier, messageType, change, other, callback) {
            var message = this.createChangeMessage(topicIdentifier, messageType, change, other);
            this.sendMessage(message, callback);
            return message;
        };
        // Suggested to use createAndSendChangeMessage instead, unless you are doing a special import
        PointrelClient.prototype.sendMessage = function (message, callback) {
            if (debugMessaging)
                console.log("sendMessage", this.areOutgoingMessagesSuspended, message);
            // Calculate the sha256AndLength without the pointrel fields
            delete message.__pointrel_sha256AndLength;
            var oldTrace = message.__pointrel_trace;
            delete message.__pointrel_trace;
            message.__pointrel_sha256AndLength = PointrelClient.makeSHA256AndLength(PointrelClient.calculateCanonicalSHA256AndLengthForObject(message));
            // TODO: Maybe should put in local sender information here?
            if (!oldTrace)
                oldTrace = [];
            message.__pointrel_trace = oldTrace;
            // TODO: What should really go in this trace entry if anything???
            var traceEntry = {
                // TODO: Should sentBy be used???
                sentByClient: this.userIdentifier,
                // TODO: Should the journalIdentifier really be split from the URL?
                sentToJournalIdentifier: this.journalIdentifier,
                sentToURL: this.apiURL,
                sentTimestamp: PointrelClient.getCurrentUniqueTimestamp()
            };
            message.__pointrel_trace.push(traceEntry);
            var previouslySent = this.sha256AndLengthToMessageMap[message.__pointrel_sha256AndLength];
            if (previouslySent) {
                console.log("A message with the same sha256AndLength was previously received (supplied/existing)", message, previouslySent);
                throw new Error("Trying to send a message with the same sha256AndLength of a message previously received");
            }
            // TODO: Extra copyObjectWithSortedKeys is not needed, but makes log messages look nicer so leaving for now
            message = PointrelClient.copyObjectWithSortedKeys(message);
            // TODO: This field ideally should go in a wrapper object and will be deleted later
            if (callback)
                message.__pointrel_callback = callback;
            this.outgoingMessageQueue.push(message);
            this.sendOutgoingMessage();
        };
        PointrelClient.prototype.suspendOutgoingMessages = function (suspend) {
            console.log("suspendOutgoingMessages", suspend);
            if (this.areOutgoingMessagesSuspended === suspend)
                return;
            this.areOutgoingMessagesSuspended = suspend;
            if (!this.areOutgoingMessagesSuspended) {
                this.sendOutgoingMessage();
            }
        };
        PointrelClient.prototype.fetchLatestMessageForTopic = function (topicIdentifier, callback) {
            var self = this;
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    detail: "latest",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    currentTimestamp: this.getCurrentUniqueTimestamp(),
                    latestRecord: {
                        messageContents: self.latestMessageForTopic(topicIdentifier),
                        // TODO: Fill these in correctly
                        sha256AndLength: null,
                        receivedTimestamp: null,
                        topicTimestamp: null
                    }
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_queryForLatestMessage",
                    journalIdentifier: this.journalIdentifier,
                    topicIdentifier: topicIdentifier
                };
                if (debugMessaging)
                    console.log("sending queryForLatestMessage request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting latest message " + new Date().toISOString());
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got latest message for topic response", response);
                    if (!response.success) {
                        console.log("ERROR: report queryForLatestMessage failure", response);
                        self.serverStatus("failure", "Report queryForLatestMessage failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self.okStatus();
                        callback(null, response);
                    }
                }, function (error) {
                    self.serverStatus("failure", "Problem fetching latest message for topic from server: " + error.message);
                    console.log("Got server error when fetching latest message for topic from server", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.createJournal = function (journalIdentifier, callback) {
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    version: "PointrelServer-loopback",
                    currentUniqueTimestamp: this.getCurrentUniqueTimestamp(),
                    journalIdentifier: journalIdentifier
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_createJournal",
                    journalIdentifier: journalIdentifier
                };
                if (debugMessaging)
                    console.log("sending createJournal request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting createJournal " + new Date().toISOString());
                var self = this;
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got createJournal response", response);
                    if (!response.success) {
                        console.log("ERROR: report createJournal failure", response);
                        self.serverStatus("failure", "Report createJournal failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self.okStatus();
                        callback(null, response);
                    }
                }, function (error) {
                    self.serverStatus("failure", "Problem with createJournal from server: " + error.description);
                    console.log("Got server error for createJournal", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.reportJournalStatus = function (callback) {
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    version: "PointrelServer-loopback",
                    currentUniqueTimestamp: this.getCurrentUniqueTimestamp(),
                    journalIdentifier: this.journalIdentifier,
                    // TODO: need to create earliest and latest record for loopback using messagesSortedByReceivedTimeArray
                    journalEarliestRecord: null,
                    journalLatestRecord: null,
                    journalRecordCount: this.messagesSortedByReceivedTimeArray.length,
                    readOnly: false,
                    permissions: {
                        read: true,
                        write: true,
                        admin: true
                    }
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_reportJournalStatus",
                    journalIdentifier: this.journalIdentifier
                };
                if (debugMessaging)
                    console.log("sending reportJournalStatus request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting journal status " + new Date().toISOString());
                var self = this;
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got journal status response", response);
                    if (!response.success) {
                        console.log("ERROR: report journal status failure", response);
                        self.serverStatus("failure", "Report journal status failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self.okStatus();
                        callback(null, response);
                    }
                }, function (error) {
                    self.serverStatus("failure", "Problem requesting status for journal from server: " + error.message);
                    console.log("Got server error for report journal status", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.getCurrentUserInformation = function (callback) {
            if (this.apiURL === "loopback") {
                callback(null, {
                    success: true,
                    statusCode: 200,
                    description: "Success",
                    timestamp: this.getCurrentUniqueTimestamp(),
                    status: 'OK',
                    userIdentifier: this.userIdentifier
                });
            }
            else {
                // Send to a real server immediately
                var apiRequest = {
                    action: "pointrel20150417_currentUserInformation"
                };
                if (debugMessaging)
                    console.log("sending currentUserInformation request", apiRequest);
                // Do not send credentials: this.prepareApiRequestForSending(apiRequest);
                // Do not set outstandingServerRequestSentAtTimestamp as this is an immediate request that does not block polling
                this.serverStatus("waiting", "requesting current user information " + new Date().toISOString());
                var self = this;
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got currentUserInformation response", response);
                    if (!response.success) {
                        console.log("ERROR: currentUserInformation request failure", response);
                        self.serverStatus("failure", "Current user information request failure: " + response.statusCode + " :: " + response.description);
                        callback(response || "Failed");
                    }
                    else {
                        self.okStatus();
                        callback(null, response);
                    }
                }, function (error) {
                    self.serverStatus("failure", "Problem requesting current user information from server: " + error.message);
                    console.log("Got server error for current user information", error.message);
                    callback(error);
                });
            }
        };
        PointrelClient.prototype.latestMessageForTopic = function (topicIdentifier) {
            // TODO: Inefficient to search all messages; keep sorted message list per topic or just track latest for each topic?
            var messages = this.messagesSortedByReceivedTimeArray;
            for (var i = messages.length - 1; i >= 0; i--) {
                var message = messages[i];
                if (message._topicIdentifier === topicIdentifier) {
                    return message;
                }
            }
            return null;
        };
        PointrelClient.prototype.filterMessages = function (filterFunction) {
            return this.messagesSortedByReceivedTimeArray.filter(filterFunction);
        };
        PointrelClient.prototype.getCurrentUniqueTimestamp = function () {
            return PointrelClient.getCurrentUniqueTimestamp();
        };
        /* TODO: Maybe make these other static utility functions available at instance levels?
        PointrelClient.prototype.copyObjectWithSortedKeys = copyObjectWithSortedKeys;
        PointrelClient.prototype.randomUUID = generateRandomUuid;
        PointrelClient.prototype.calculateCanonicalSHA256AndLengthForObject = calculateCanonicalSHA256AndLengthForObject;
        PointrelClient.prototype.calculateSHA256 = calculateSHA256;
        */
        // TODO: Next few from server code -- should have common routines to avoid duplicate code
        // TODO: Note that this approach depends on object keys maintaining their order, which is not guaranteed by the JS standards but most browsers support it
        // isObject and copyObjectWithSortedKeys are from Mirko Kiefer (with added semicolons):
        // https://raw.githubusercontent.com/mirkokiefer/canonical-json/master/index2.js
        PointrelClient.isObject = function (a) {
            return Object.prototype.toString.call(a) === '[object Object]';
        };
        PointrelClient.copyObjectWithSortedKeys = function (object) {
            if (PointrelClient.isObject(object)) {
                var newObj = {};
                var keysSorted = Object.keys(object).sort();
                var key;
                for (var i = 0, len = keysSorted.length; i < len; i++) {
                    key = keysSorted[i];
                    newObj[key] = PointrelClient.copyObjectWithSortedKeys(object[key]);
                }
                return newObj;
            }
            else if (Array.isArray(object)) {
                return object.map(PointrelClient.copyObjectWithSortedKeys);
            }
            else {
                return object;
            }
        };
        PointrelClient.makeSHA256AndLength = function (sha256AndLengthObject) {
            if (!sha256AndLengthObject.sha256 || !sha256AndLengthObject.length) {
                console.log("Problem making sha256AndLength identifier", sha256AndLengthObject);
                throw new Error("Problem making sha256AndLength identifier from: " + JSON.stringify(sha256AndLengthObject));
            }
            return sha256AndLengthObject.sha256 + "_" + sha256AndLengthObject.length;
        };
        PointrelClient.calculateCanonicalSHA256AndLengthForObject = function (someObject, doNotSortFlag) {
            if (doNotSortFlag === void 0) { doNotSortFlag = false; }
            if (!doNotSortFlag)
                someObject = PointrelClient.copyObjectWithSortedKeys(someObject);
            var minimalJSON = JSON.stringify(someObject);
            // var buffer = new Buffer(minimalJSON, "utf8");
            // console.log("minimalJSON", minimalJSON);
            //var max = 0;
            //for (var i = 0; i < minimalJSON.length; i++) {
            //    var c = minimalJSON.charAt(i);
            //    if (minimalJSON.charCodeAt(i) > 127) console.log("i # c", i, minimalJSON.charCodeAt(i), c);
            //    if (minimalJSON.charCodeAt(i) > max) max = minimalJSON.charCodeAt(i);
            //}
            //console.log("max", max);
            var utf8String = stringToUtf8(minimalJSON);
            //console.log("utf8String", utf8String);
            // console.log("match?", minimalJSON === utf8String, "minimal length", minimalJSON.length, "utf8 length", utf8String.length);
            //for (var i = 0; i < minimalJSON.length; i++) {
            //    console.log("char at i", i, minimalJSON[i]);
            //}
            /*
            var shaObj = new JS_SHA("SHA-256", "TEXT");
            shaObj.update(minimalJSON);
            // console.log("Without string conversion", shaObj.getHash("HEX"));
            */
            var sha256 = PointrelClient.calculateSHA256(minimalJSON);
            var length = utf8String.length;
            var sha256AndLength = "" + sha256 + "_" + length;
            return { sha256: "" + sha256, length: length };
        };
        PointrelClient.calculateSHA256 = function (text) {
            // console.log("calculateSHA256", utf8Bytes);
            return "" + sha256.SHA256(text);
        };
        // Ensure unique timestamps are always incremented from the next by adding values at end...
        // In theory, if the server were to be stopped and be restarted in the same millisecond, these values could overlap for a millisecond in the new session
        PointrelClient.getCurrentUniqueTimestamp = function () {
            // TODO: Add random characters at end of number part of timestamp before Z
            var currentTimestamp = new Date().toISOString();
            var randomNumber = Math.floor(Math.random() * 1000);
            var randomPadding = (PointrelClient.timestampRandomPadding + randomNumber).slice(-(PointrelClient.timestampRandomPadding.length));
            if (PointrelClient.lastTimestamp !== currentTimestamp) {
                PointrelClient.lastTimestamp = currentTimestamp;
                PointrelClient.lastTimestampIncrement = 0;
                return currentTimestamp.replace("Z", PointrelClient.timestampIncrementPadding + randomPadding + "Z");
            }
            // Need to increment timestamp;
            PointrelClient.lastTimestampIncrement++;
            if (PointrelClient.lastTimestampIncrement === 1000) {
                // About to overrun timestamps -- this should probably never be possible in practice
                // on a single thread doing any actual work other than a tight loop for a couple decades (circa 2015).
                // Possible short-term fix is to pad "999999" then add more digits afterwards;
                // long-term fix is to add more zeros to padding string or have better approach
                // Note also that if this condition is reached, ISO timestamp comparisons could be incorrect
                // as the final "Z" interferes with collation
                // Another temporary option would be to introduce a delay in this situation to get
                // to the next millisecond before the timestamp's final text value is determined
                console.log("getCurrentUniqueTimestamp: failure with timestamp padding from fast CPU -- add more timestamp padding");
            }
            var extraDigits = (PointrelClient.timestampIncrementPadding + PointrelClient.lastTimestampIncrement).slice(-(PointrelClient.timestampIncrementPadding.length));
            currentTimestamp = currentTimestamp.replace("Z", extraDigits + randomPadding + "Z");
            return currentTimestamp;
        };
        // End -- from server
        // ------------- Internal methods below not meant to be called by users
        PointrelClient.prototype.sendOutgoingMessage = function () {
            var callback;
            if (debugMessaging)
                console.log("sendOutgoingMessage");
            if (this.outgoingMessageQueue.length === 0)
                return;
            if (debugMessaging)
                console.log("sendOutgoingMessage proceeding");
            var self = this;
            if (this.apiURL === "loopback" || this.areOutgoingMessagesSuspended) {
                // Pretend to send all the outgoing messages we have
                while (this.outgoingMessageQueue.length) {
                    var loopbackMessage = this.outgoingMessageQueue.shift();
                    callback = loopbackMessage.__pointrel_callback;
                    if (callback !== undefined)
                        delete loopbackMessage.__pointrel_callback;
                    this.messageSentCount++;
                    // Simulating eventual response from server, generally for testing
                    this.messageReceived(PointrelClient.copyObjectWithSortedKeys(loopbackMessage));
                    if (callback)
                        callback(null, { success: true });
                }
            }
            else {
                // Send to a real server
                // Wait for later if a request is outstanding already, like polling for new messages
                if (this.outstandingServerRequestSentAtTimestamp)
                    return;
                // If this fails, and there is no callback, this will leave message on outgoing queue (unless it was rejected for some reason)
                // If there is a callback, the message will be discarded as presumably the caller will handle resending it
                var message = this.outgoingMessageQueue[0];
                callback = message.__pointrel_callback;
                if (callback !== undefined)
                    delete message.__pointrel_callback;
                var apiRequest = {
                    action: "pointrel20150417_storeMessage",
                    journalIdentifier: this.journalIdentifier,
                    message: message
                };
                if (debugMessaging)
                    console.log("sending store message request", apiRequest);
                this.prepareApiRequestForSending(apiRequest);
                this.outstandingServerRequestSentAtTimestamp = new Date();
                this.serverStatus("waiting", "storing " + this.outstandingServerRequestSentAtTimestamp);
                this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                    if (debugMessaging)
                        console.log("Got store response", response);
                    self.outstandingServerRequestSentAtTimestamp = null;
                    if (!response.success) {
                        console.log("ERROR: Message store failure", response, self.outgoingMessageQueue[0], JSON.stringify(self.outgoingMessageQueue[0]));
                        if (callback) {
                            self.serverStatus("failure", "Message store failure: " + response.statusCode + " :: " + response.description);
                            // Discard the message from the queue as presumably the caller will resend it
                            self.outgoingMessageQueue.shift();
                            callback(response || "Failed");
                            return;
                        }
                        // Need to otherwise decide whether to discard the message based on the nature of the problem
                        // Should leave it in the queue if it is not malformed and it is just a possibly temporary problem with server
                        // If the message we sent was rejected because it was malformed or a duplicate, we should discard it
                        // Do not continue with requests until next poll...
                        // TODO: Should we not discard messages for an internal server error (500)?
                        if (response.statusCode !== "403") {
                            // Discard all problematical messages except for ones that are not authenticated and might succeed if resent after (re)authetication
                            self.outgoingMessageQueue.shift();
                            self.serverStatus("failure-loss", "Data loss from message store failure: " + response.statusCode + " :: " + response.description);
                        }
                        return;
                    }
                    else {
                        self.okStatus();
                        self.messageSentCount++;
                        self.outgoingMessageQueue.shift();
                    }
                    // Keep sending outgoing messages if there are any more, or do other task as needed
                    // Do this as a timeout so the event loop can finish its cycle first
                    // Only do this if polling has been started; otherwis just assume user is sending individual messages
                    if (callback)
                        callback(null, response);
                    if (self.started) {
                        setTimeout(function () {
                            // Could instead just send outgoing messages and let the timer restart the others, this will cause some extra polls
                            self.sendFetchOrPollIfNeeded();
                        }, 0);
                    }
                }, function (error) {
                    // TODO: Need to check for rejected status and then remove the message from the outgoing queue
                    self.serverStatus("failure", "Problem storing message to server: " + error.message +
                        "<br>You may need to reload the page to synchronize it with the current state of the server if a message was rejected for some reason.");
                    console.log("Got store error", error.message);
                    self.outstandingServerRequestSentAtTimestamp = null;
                    if (callback) {
                        // Discard the message from the queue as presumably the caller will resend it
                        self.outgoingMessageQueue.shift();
                        callback(error);
                    }
                });
            }
        };
        PointrelClient.prototype.messageReceived = function (message) {
            // if (debugMessaging) console.log("messageReceived", JSON.stringify(message, null, 2));
            if (!message) {
                console.log("ERROR: Problem with server response. No message!");
                return;
            }
            this.messageReceivedCount++;
            // Ignore the message if we already have it
            if (this.sha256AndLengthToMessageMap[message.__pointrel_sha256AndLength]) {
                // console.log("Message already received", message.__pointrel_sha256AndLength);
                return;
            }
            if (!message.__pointrel_trace)
                message.__pointrel_trace = [];
            // TODO: Still unsure about how to implement trace???
            var traceEntry = {
                // TODO: Should receivedBy be used???
                receivedByClient: this.userIdentifier,
                // TODO: Should the journalIdentifier really be split from the URL?
                receivedFromJournalIdentifier: this.journalIdentifier,
                receivedFromURL: this.apiURL,
                receivedTimestamp: this.getCurrentUniqueTimestamp()
            };
            message.__pointrel_trace.push(traceEntry);
            // TODO: Make sure the list stays sorted -- copy code from server
            this.messagesSortedByReceivedTimeArray.push(message);
            this.sha256AndLengthToMessageMap[message.__pointrel_sha256AndLength] = message;
            // TODO: Maybe do excepting handling for callback, as otherwise could break incoming message handling?
            if (this.messageReceivedCallback)
                this.messageReceivedCallback(message);
            topic.publish("messageReceived", message);
            if (message.messageType) {
                // console.log("publishing message", message);
                topic.publish(message.messageType, message);
            }
        };
        // Start boiler plate for timer management
        PointrelClient.prototype.startTimer = function () {
            // Stop the timer in case it was running already
            // TODO: Is stopTimer/clearTimeout safe to call if the timer has already completed?
            this.stopTimer();
            this.timer = window.setTimeout(this.timerSentSignal.bind(this), this.frequencyOfChecks_ms);
        };
        PointrelClient.prototype.stopTimer = function () {
            if (this.timer) {
                window.clearTimeout(this.timer);
                this.timer = null;
            }
        };
        // In addition to doing polling if there are no other messages to send or recieve,
        // the timer will give everything a kick to get going again shortly after something errors out
        PointrelClient.prototype.timerSentSignal = function () {
            // if (debugMessaging) console.log(new Date().toISOString(), "should do check now for new messages", this);
            this.timer = null;
            // catch any exceptions to ensure timer is started again
            try {
                this.sendFetchOrPollIfNeeded();
            }
            catch (e) {
                console.log("Exception when trying to server for changes", e);
            }
            this.startTimer();
        };
        PointrelClient.prototype.sendFetchOrPollIfNeeded = function () {
            // TODO: Prioritizing outgoing messages -- might want to revisit this for some applications?
            if (!this.areOutgoingMessagesSuspended && this.outgoingMessageQueue.length) {
                this.sendOutgoingMessage();
            }
            else if (this.incomingMessageRecords.length) {
                this.fetchIncomingMessage();
            }
            else {
                this.pollServerForNewMessages();
            }
        };
        // End boilerplate for timer management
        PointrelClient.prototype.pollServerForNewMessages = function () {
            // Do not poll if the document is not visible
            if (document.hidden === true) {
                // console.log("pollServerForNewMessages: not polling because not visible");
                return;
            }
            if (this.outstandingServerRequestSentAtTimestamp) {
                // TODO: Warn if connection seems to have failed
                console.log("Still waiting on previous server request");
                var waiting_ms = new Date().getTime() - this.outstandingServerRequestSentAtTimestamp.getTime();
                console.log("Have been waiting on server for waiting_ms", waiting_ms);
                if (waiting_ms > 10000) {
                    // Should never get here if timeout is 2000ms and timers get the process restarted
                    if (!this.serverResponseWarningIssued) {
                        console.log("Server not responding");
                        this.serverStatus("falure", "The server is not responding...");
                        this.serverResponseWarningIssued = true;
                    }
                }
                return;
            }
            if (debugMessaging)
                console.log("Polling server for changes...");
            var apiRequest = {
                action: "pointrel20150417_queryForNextMessage",
                journalIdentifier: this.journalIdentifier,
                fromTimestampExclusive: this.lastReceivedTimestampConsidered,
                // The server may return less than this number of message if including message contents and they exceed about 1MB in total
                limitCount: 100,
                includeMessageContents: this.includeMessageContents,
                topicIdentifier: undefined
            };
            if (this.topicIdentifier !== undefined) {
                apiRequest.topicIdentifier = this.topicIdentifier;
            }
            if (debugMessaging)
                console.log("sending polling request", apiRequest);
            this.prepareApiRequestForSending(apiRequest);
            // TODO: What do do if it fails? Leave message on outgoing queue?
            this.outstandingServerRequestSentAtTimestamp = new Date();
            this.serverStatus("waiting", "polling " + this.outstandingServerRequestSentAtTimestamp);
            var self = this;
            // Use longer timeout to account for reading multiple records on server
            this.apiRequestSend(apiRequest, longTimeout_ms, function (response) {
                if (debugMessaging)
                    console.log("Got query response", response);
                if (!response.success) {
                    console.log("Response was a failure", response);
                    self.serverStatus("failure", "Polling response failure: " + response.statusCode + " :: " + response.description);
                }
                else {
                    self.okStatus();
                    for (var i = 0; i < response.receivedRecords.length; i++) {
                        var receivedRecord = response.receivedRecords[i];
                        // if (debugMessaging) console.log("New message", receivedRecord);
                        if (receivedRecord.messageContents !== undefined) {
                            /// console.log("got contents directly", receivedRecord);
                            if (receivedRecord.messageContents !== null) {
                                self.messageReceived(receivedRecord.messageContents);
                            }
                            else {
                                // Would be issue with the messages becoming out of order if did not just reject messages
                                //   with null contents when requesting contents with polling result, like if did a retry instead
                                console.log("Message contents not available for message", receivedRecord);
                            }
                        }
                        else {
                            self.incomingMessageRecords.push(receivedRecord);
                        }
                    }
                    self.lastReceivedTimestampConsidered = response.lastReceivedTimestampConsidered;
                }
                self.outstandingServerRequestSentAtTimestamp = null;
                if (response.receivedRecords && response.receivedRecords.length) {
                    // Schedule another request immediately if getting contents
                    setTimeout(function () {
                        self.sendFetchOrPollIfNeeded();
                    }, 0);
                }
                else {
                    if (self.idleCallback) {
                        var callback = self.idleCallback;
                        self.idleCallback = null;
                        console.log("Doing one-time idle callback");
                        callback();
                    }
                }
            }, function (error) {
                console.log("Got query error", error.message);
                self.serverStatus("failure", "Something went wrong talking to the server when querying for new messages: " + error.message);
                // TODO: How to recover?
                self.outstandingServerRequestSentAtTimestamp = null;
            });
        };
        PointrelClient.prototype.fetchIncomingMessage = function () {
            if (this.incomingMessageRecords.length === 0) {
                this.serverStatus("waiting", "waiting");
                return;
            }
            if (this.outstandingServerRequestSentAtTimestamp)
                return;
            if (debugMessaging)
                console.log("Trying to fetch incoming message");
            var incomingMessageRecord = this.incomingMessageRecords[0];
            if (incomingMessageRecord.messageContents) {
                this.incomingMessageRecords.shift();
                this.messageReceived(incomingMessageRecord.messageContents);
                this.sendFetchOrPollIfNeeded();
                return;
            }
            if (debugMessaging)
                console.log("Retrieving new message...");
            var apiRequest = {
                action: "pointrel20150417_loadMessage",
                journalIdentifier: this.journalIdentifier,
                sha256AndLength: incomingMessageRecord.sha256AndLength,
                topicIdentifier: undefined
            };
            if (this.topicIdentifier !== undefined) {
                // The topicIdentifier is needed in case we only have permission to read within a specific topic
                apiRequest.topicIdentifier = this.topicIdentifier;
            }
            if (debugMessaging)
                console.log("sending load request", apiRequest);
            this.prepareApiRequestForSending(apiRequest);
            this.outstandingServerRequestSentAtTimestamp = new Date();
            this.serverStatus("waiting", "loading " + this.outstandingServerRequestSentAtTimestamp);
            var self = this;
            this.apiRequestSend(apiRequest, shortTimeout_ms, function (response) {
                self.okStatus();
                if (debugMessaging)
                    console.log("Got load response", response);
                self.outstandingServerRequestSentAtTimestamp = null;
                self.incomingMessageRecords.shift();
                if (!response.success) {
                    console.log("Problem retrieving message; response:", response, "for message record:", incomingMessageRecord);
                    // TODO; Is this really a "serverStatus" to display?
                    self.serverStatus("failure", "Message retrieval failure: " + response.statusCode + " :: " + response.description);
                }
                else {
                    self.messageReceived(response.message);
                }
                // Keep loading incoming messages if there are any more, or do other task as needed
                // Do this as a timeout so the event loop can finish its cycle first
                setTimeout(function () {
                    self.sendFetchOrPollIfNeeded();
                }, 0);
            }, function (error) {
                console.log("Got load error", error.message);
                self.serverStatus("failure", "Something went wrong talking to the server when loading a message: " + error.message);
                self.outstandingServerRequestSentAtTimestamp = null;
            });
        };
        // Status should be ok, waiting, or failure
        PointrelClient.prototype.serverStatus = function (status, message) {
            // console.log("PointrelClient serverStatus", status, message);
            if (this.serverStatusCallback)
                this.serverStatusCallback(status, message);
        };
        PointrelClient.prototype.okStatus = function () {
            this.serverStatus("ok", "OK (sent: " + this.messageSentCount + ", received:" + this.messageReceivedCount + ")");
        };
        // Variables related to generating unique timestamps
        // Note: timestamp padding needs to get longer as computers get faster
        PointrelClient.lastTimestamp = null;
        PointrelClient.lastTimestampIncrement = 0;
        PointrelClient.timestampIncrementPadding = "000";
        PointrelClient.timestampRandomPadding = "000";
        return PointrelClient;
    })();
    return PointrelClient;
});

define('js/pointrel20150417/TripleStore',["require", "exports", "./topic", "./generateRandomUuid"], function (require, exports, topic, generateRandomUuid) {
    "use strict";
    function makeTopicKey(object) {
        // TODO: Should really canonicalize the a,b,c values
        return object;
    }
    function defensiveCopy(value) {
        if (value === undefined)
            return value;
        if (value === null)
            return value;
        if (typeof value === "number")
            return value;
        if (typeof value === "string")
            return value;
        if (typeof value === "boolean")
            return value;
        // Value might be mutable, so return a copy of it
        return JSON.parse(JSON.stringify(value));
    }
    var TripleStore = (function () {
        function TripleStore(pointrelClient, topicIdentifier) {
            this.pointrelClient = null;
            this.topicIdentifier = null;
            this.tripleMessages = [];
            this.tripleMessagesBySHA256AndLength = {};
            this.indexABC = {};
            this.subscriptions = [];
            this.pointrelClient = pointrelClient;
            this.topicIdentifier = topicIdentifier;
            this.subscriptions.push(topic.subscribe("messageReceived", this.messageReceivedFromPointrelClient.bind(this)));
        }
        TripleStore.prototype.remove = function () {
            // console.log("TripleStore remove called");
            this.subscriptions.forEach(function (subscription) {
                subscription.remove();
            });
            this.subscriptions = [];
        };
        TripleStore.prototype.makeAddTripleMessage = function (a, b, c) {
            if (a === undefined || b === undefined || c === undefined) {
                throw new Error("Triple should not have undefined fields");
            }
            var triple = {
                a: a,
                b: b,
                c: c
            };
            var change = {
                action: "addTriple",
                triple: triple
            };
            var timestamp = this.pointrelClient.getCurrentUniqueTimestamp();
            var message = {
                _topicIdentifier: this.topicIdentifier,
                _topicTimestamp: timestamp,
                change: change,
                messageType: "tripleStore",
                userIdentifier: this.pointrelClient.userIdentifier
            };
            return message;
        };
        TripleStore.prototype.addTriple = function (a, b, c, callback) {
            // console.log("TripleStore addTriple", a, b, c);
            if (callback === void 0) { callback = undefined; }
            var message = this.makeAddTripleMessage(a, b, c);
            this.pointrelClient.sendMessage(message, callback);
            // Process locally to have current value
            this.processTripleStoreMessage(message);
        };
        TripleStore.prototype.processTripleStoreMessage = function (message) {
            // TODO: Keep the list sorted by time
            this.tripleMessages.push(message);
            this.addMessageToIndexes(message);
        };
        TripleStore.prototype.addMessageToIndexes = function (message) {
            this.tripleMessagesBySHA256AndLength[message.__pointrel_sha256AndLength] = message;
            if (message.change.action === "addTriple") {
                var triple = message.change.triple;
                var aKey = JSON.stringify(triple.a);
                var aIndex = this.indexABC[aKey];
                if (!aIndex) {
                    aIndex = {};
                    this.indexABC[aKey] = aIndex;
                }
                var bKey = JSON.stringify(triple.b);
                var bIndex = aIndex[bKey];
                if (!bIndex) {
                    bIndex = {};
                    aIndex[bKey] = bIndex;
                }
                var versions = bIndex.versions;
                if (!versions) {
                    versions = [];
                    bIndex.versions = versions;
                }
                versions.push(message);
                if (!bIndex.latestCTimestamp || bIndex.latestCTimestamp <= message._topicTimestamp) {
                    bIndex.latestCTimestamp = message._topicTimestamp;
                    bIndex.latestC = triple.c;
                }
            }
        };
        TripleStore.prototype.getIndexEntries = function (a, b) {
            if (b === void 0) { b = undefined; }
            if (a === undefined)
                throw ("a should not be undefined");
            var aKey = JSON.stringify(a);
            var aIndex = this.indexABC[aKey];
            if (!aIndex)
                return null;
            if (b === undefined)
                return aIndex;
            var bKey = JSON.stringify(b);
            var bIndex = aIndex[bKey];
            if (!bIndex)
                return null;
            return bIndex;
        };
        TripleStore.prototype.messageReceivedFromPointrelClient = function (message) {
            // console.log("TripleStore.messageReceivedFromPointrelClient", message);
            if (message.messageType !== "tripleStore")
                return;
            if (message._topicIdentifier !== this.topicIdentifier)
                return;
            if (message.change.action === "addTriple") {
                // Ignore the message if it was previously received (probably because this client sent it)
                // TODO: track sent and bump and report conflicts
                if (this.tripleMessagesBySHA256AndLength[message.__pointrel_sha256AndLength]) {
                    // MAYBE: Could check JSON of stored and received to confirm they are identical
                    // console.log("compare previous/new", previouslyReceivedMessage, message);
                    // console.log("TripleStore message previously received, so ignoring", message);
                    return;
                }
                this.processTripleStoreMessage(message);
                var triple = message.change.triple;
                // console.log("TripleStore: About to publish changes...");
                topic.publish(makeTopicKey({ type: "TripleStore.addTriple" }), triple, message);
                // TODO: Improve this dispatching so don't have to do JSON string conversion
                // Some other common events. Other variations would need to be listened for using the more general event above
                // TODO: Maybe want to distinguish when a later C value is put in that superceeds an old C value
                // console.log("publish", makeTopicKey({type: "TripleStore.addForAB", a: triple.a, b: triple.b}));
                topic.publish(makeTopicKey({ type: "TripleStore.addForA", a: triple.a }), triple, message);
                topic.publish(makeTopicKey({ type: "TripleStore.addForAB", a: triple.a, b: triple.b }), triple, message);
                topic.publish(makeTopicKey({ type: "TripleStore.addForBC", b: triple.b, c: triple.c }), triple, message);
            }
            else {
                console.log("messageReceivedFromPointrelClient: Unsupported action", message);
            }
        };
        TripleStore.prototype.subscribe = function (a, b, c, callback) {
            // console.log("TripleStore.subscribe", a, b, c, callback);
            // TODO: Should these subscriptions be stored in this object or be caller responsibility?
            if (a === undefined && b === undefined && c === undefined) {
                return topic.subscribe(makeTopicKey({ type: "TripleStore.addTriple" }), callback);
            }
            if (a !== undefined) {
                if (b !== undefined) {
                    // console.log("subscribe", makeTopicKey({type: "TripleStore.addForAB", a: a, b: b}));
                    return topic.subscribe(makeTopicKey({ type: "TripleStore.addForAB", a: a, b: b }), callback);
                }
                return topic.subscribe(makeTopicKey({ type: "TripleStore.addForA", a: a }), callback);
            }
            if (b !== undefined) {
                if (c !== undefined) {
                    return topic.subscribe(makeTopicKey({ type: "TripleStore.addForBC", b: b, c: c }), callback);
                }
            }
            // TODO: Need to subscribe to addTriple and do filter
            console.log("Unsupported subscription", a, b, c);
            throw new Error("TripleStore.subscribe: Unfinished -- subscription type not yet supported");
        };
        /*
        // TODO: Optimize with indexes
        // TODO: Ignoring actual timestamps, so only "latest" by receipt is considered, but that is not correct
        // TODO: need to use actual timestamp in sorted comparison to deal with collissions
        queryLatest(a, b, c) {
            // console.log("queryLatest", a, b, c);
            for (var i = this.tripleMessages.length - 1; i >= 0; i--) {
                var tripleMessage = this.tripleMessages[i];
                // console.log("queryLatest loop", i, tripleMessage);
                if ((a === undefined || tripleMessage.change.triple.a === a) &&
                    (b === undefined || tripleMessage.change.triple.b === b) &&
                    (c === undefined || tripleMessage.change.triple.c === c)) {
                    // console.log("match", tripleMessage.change.triple);
                    return tripleMessage.change.triple;
                }
            }
            
            // TODO: Maybe should return empty triple instead?
            return null;
        }
        */
        TripleStore.prototype.queryLatestC = function (a, b) {
            // console.log("queryLatestC", a, b);
            if (a === undefined) {
                throw new Error("a should not be undefined; b: " + b);
            }
            if (b === undefined) {
                throw new Error("b should not be undefined; a: " + a);
            }
            var bIndex = this.getIndexEntries(a, b);
            if (!bIndex)
                return undefined;
            // console.log("queryLatestC result", a, b, bIndex.latestC);
            return defensiveCopy(bIndex.latestC);
        };
        // The b keys returned here are stringified objects (could be strings, or other) and should be parsed by called code if needed
        TripleStore.prototype.queryAllLatestBCForA = function (a) {
            if (a === undefined) {
                throw new Error("a should not be undefined");
            }
            var result = {};
            var aIndex = this.getIndexEntries(a);
            if (!aIndex)
                return result;
            for (var bKey in aIndex) {
                var bIndex = aIndex[bKey];
                if (bIndex && bIndex.latestC !== undefined) {
                    result[bKey] = defensiveCopy(bIndex.latestC);
                }
            }
            return result;
        };
        // Utility methods
        // Make a function that either returns the latest value with no arguments or sets it with one argument
        TripleStore.prototype.makeStorageFunction = function (a, b) {
            var _this = this;
            return function (c) {
                if (c === void 0) { c = undefined; }
                if (c === undefined) {
                    return _this.queryLatestC(a, b);
                }
                else {
                    _this.addTriple(a, b, c);
                }
            };
        };
        // Make a function that either returns the latest value for a model field with one argument (fieldName) or sets it with two arguments (fieldName, value)
        TripleStore.prototype.makeModelFunction = function (a) {
            var _this = this;
            if (a === undefined) {
                throw new Error("expected a to be defined");
            }
            return function (b, c) {
                if (c === void 0) { c = undefined; }
                if (c === undefined) {
                    return _this.queryLatestC(a, b);
                }
                else {
                    _this.addTriple(a, b, c);
                }
            };
        };
        TripleStore.prototype.makeObject = function (a, isKeyJSON) {
            if (isKeyJSON === void 0) { isKeyJSON = true; }
            if (a === undefined) {
                throw new Error("expected a to be defined");
            }
            var result = {};
            var latestBC = this.queryAllLatestBCForA(a);
            for (var bKey in latestBC) {
                var b = bKey;
                if (isKeyJSON) {
                    b = JSON.parse(bKey);
                }
                var c = latestBC[bKey];
                if (typeof b === "string") {
                    if (c !== undefined) {
                        result[b] = defensiveCopy(c);
                    }
                }
                else {
                    console.log("Expected b to be a string", a, b);
                }
            }
            return result;
        };
        // Sets
        // TODO: Id does not have to be restricted to a string, but doing it for now to catch errors
        TripleStore.prototype.newIdForSet = function (setClassName) {
            // var setIdentifier = {"type": "set", "id":  generateRandomUuid(setClassName)};
            var setIdentifier = generateRandomUuid(setClassName);
            return setIdentifier;
        };
        TripleStore.prototype.newIdForSetItem = function (itemClassName) {
            // return new Date().toISOString();
            return generateRandomUuid(itemClassName);
        };
        TripleStore.prototype.makeNewSetItem = function (setIdentifier, itemClassName, template, idProperty) {
            if (template === void 0) { template = undefined; }
            if (idProperty === void 0) { idProperty = "id"; }
            if (setIdentifier === undefined) {
                throw new Error("expected setIdentifier to be defined");
            }
            var newId;
            if (template) {
                newId = template[idProperty];
                if (!newId) {
                    newId = this.newIdForSetItem(itemClassName);
                    template[idProperty] = newId;
                }
            }
            else {
                newId = this.newIdForSetItem(itemClassName);
            }
            if (template) {
                for (var key in template) {
                    this.addTriple(newId, key, template[key]);
                }
            }
            // TODO: Should there be another layer of indirection with a UUID for the "item" different from idPropery?
            // this.tripleStore.addTriple(newId????, this.idProperty, newId);
            this.addTriple(setIdentifier, { setItem: newId }, newId);
            return newId;
        };
        TripleStore.prototype.makeCopyOfSetItemWithNewId = function (setIdentifier, existingItemId, itemClassName) {
            if (setIdentifier === undefined) {
                throw new Error("expected setIdentifier to be defined");
            }
            if (existingItemId === undefined) {
                throw new Error("expected existingItemId to be defined");
            }
            var newId = this.newIdForSetItem(itemClassName);
            this.addTriple(setIdentifier, { setItem: newId }, newId);
            var latestBC = this.queryAllLatestBCForA(existingItemId);
            for (var bKey in latestBC) {
                // For every field, copy it...
                var b = JSON.parse(bKey);
                var c = latestBC[bKey];
                if (c !== undefined) {
                    this.addTriple(newId, b, c);
                }
                else {
                    console.log("Unexpected undefined value when copying list item", setIdentifier, existingItemId);
                }
            }
            return newId;
        };
        TripleStore.prototype.deleteSetItem = function (setIdentifier, itemIdentifier) {
            if (setIdentifier === undefined) {
                throw new Error("expected setIdentifier to be defined");
            }
            if (itemIdentifier === undefined) {
                throw new Error("expected itemIdentifier to be defined");
            }
            // TODO: Should the C be undefined instead of null?
            this.addTriple(setIdentifier, { setItem: itemIdentifier }, null);
        };
        TripleStore.prototype.getListForSetIdentifier = function (setIdentifier) {
            var result = [];
            if (!setIdentifier)
                return result;
            var aIndex = this.getIndexEntries(setIdentifier);
            if (!aIndex)
                return result;
            for (var bKey in aIndex) {
                var b = JSON.parse(bKey);
                // Set items should have a "setItem" field in b key as a "standard"; possible collision with other usages though
                if (b.setItem) {
                    var bIndex = aIndex[bKey];
                    if (bIndex) {
                        var c = bIndex.latestC;
                        if (c !== undefined && c !== null) {
                            result.push(defensiveCopy(c));
                        }
                    }
                }
            }
            return result;
        };
        return TripleStore;
    })();
    return TripleStore;
});

define('js/Project',["require", "exports", "./pointrel20150417/PointrelClient", "./surveyCollection", "./pointrel20150417/TripleStore"], function (require, exports, PointrelClient, surveyCollection, TripleStore) {
    "use strict";
    var serverURL = "/api/pointrel20150417";
    // TODO: Rethink this as a more general way to watch models within the project (so, with arbitrary object IDs, not just the project ID)
    var Project = (function () {
        function Project(journalIdentifier, projectIdentifier, userIdentifier, updateServerStatus, redrawCallback) {
            this.readOnly = false;
            // The activeQuestionnaires field tracks what should be available to survey users and to construct related messages
            this.activeQuestionnaires = {};
            this.journalIdentifier = journalIdentifier;
            this.projectIdentifier = projectIdentifier;
            this.userIdentifier = userIdentifier;
            this.redrawCallback = redrawCallback;
            this.pointrelClient = new PointrelClient(serverURL, this.journalIdentifier, this.userIdentifier, this.receivedMessage.bind(this), updateServerStatus);
            // For now, listen on all topics in the journal
            // TODO: Think about how to move topicIdentifier into pointrelClient initialization
            // var topicIdentifier = "project001";
            // pointrelClient.topicIdentifier = topicIdentifier;
            this.tripleStore = new TripleStore(this.pointrelClient, "narrafirmaProject");
            // console.log("tripleStore", this.tripleStore);
            // Redraw on any new tripleStore message (however, the ones we send will not get callbacks)
            this.tripleStore.subscribe(undefined, undefined, undefined, this.redrawCallback.bind(this));
        }
        Project.prototype.startup = function (callback) {
            var _this = this;
            this.pointrelClient.reportJournalStatus(function (error, response) {
                console.log("reportJournalStatus response", error, response);
                if (error) {
                    console.log("Failed to startup project", error);
                    callback(error);
                }
                else {
                    _this.pointrelClient.startup();
                    callback(null, response);
                }
            });
        };
        // TODO: Redundant code with what is in GridWithItemPanel
        Project.prototype.getListForField = function (fieldName) {
            var setIdentifier = this.getFieldValue(fieldName);
            return this.tripleStore.getListForSetIdentifier(setIdentifier);
        };
        Project.prototype.getFieldValue = function (fieldName) {
            return this.tripleStore.queryLatestC(this.projectIdentifier, fieldName);
        };
        Project.prototype.setFieldValue = function (fieldName, newValue, oldValue) {
            if (oldValue === void 0) { oldValue = undefined; }
            // TODO: Need to add support in tripleStore for oldValue; note callback is the fourth parameter
            this.tripleStore.addTriple(this.projectIdentifier, fieldName, newValue);
        };
        Project.prototype.fieldValue = function (fieldName, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (newValue === undefined) {
                return this.getFieldValue(fieldName);
            }
            else {
                return this.setFieldValue(fieldName, newValue);
            }
        };
        // TODO: What do do about this function? Especially if want to track chat messages or log messages or undoable changes for project?
        Project.prototype.receivedMessage = function (message) {
            // console.log("Project receivedMessage", message);
            if (message.change && message.change.action === "addTriple") {
                // Ignore addTriple messages as we handle only the ones we did not send via a subscription
                // console.log("Ignoring tripleStore message", message);
                return;
            }
            if (message.messageType === "questionnairesMessage") {
                // console.log("Project receivedMessage questionnairesMessage", message);
                surveyCollection.updateActiveQuestionnaires(message.change, false, null);
            }
            // Since this event came from the network, queue a Mithril redraw
            // The tripleStore may not be updated yet, so this redraw needs to get queued for later by the application
            if (this.redrawCallback) {
                // console.log("project calling redrawCallback");
                this.redrawCallback();
            }
        };
        // Project-specific data lookup
        Project.prototype.findCatalysisReport = function (shortName) {
            var catalysisReports = this.tripleStore.queryLatestC(this.projectIdentifier, "project_catalysisReports");
            if (!catalysisReports)
                return null;
            var catalysisReportIdentifiers = this.tripleStore.getListForSetIdentifier(catalysisReports);
            for (var i = 0; i < catalysisReportIdentifiers.length; i++) {
                var reportShortName = this.tripleStore.queryLatestC(catalysisReportIdentifiers[i], "catalysisReport_shortName");
                if (reportShortName === shortName) {
                    return catalysisReportIdentifiers[i];
                }
            }
            return null;
        };
        Project.prototype.findQuestionnaireTemplate = function (shortName) {
            var questionnaires = this.getListForField("project_storyForms");
            for (var i = 0; i < questionnaires.length; i++) {
                if (this.tripleStore.queryLatestC(questionnaires[i], "questionForm_shortName") === shortName) {
                    return questionnaires[i];
                }
            }
            return null;
        };
        /*
        allStoryFormShortNames(): string[] {
            var result = [];
            var questionnaires: Array<string> = this.getListForField("project_storyForms");
            for (var i = 0; i < questionnaires.length; i++) {
                result.push(this.tripleStore.queryLatestC(questionnaires[i], "questionForm_shortName"));
            }
            return result;
        }
        */
        Project.prototype.findStoryCollection = function (shortName) {
            var storyCollections = this.getListForField("project_storyCollections");
            for (var i = 0; i < storyCollections.length; i++) {
                if (this.tripleStore.queryLatestC(storyCollections[i], "storyCollection_shortName") === shortName) {
                    return storyCollections[i];
                }
            }
            return null;
        };
        Project.prototype.collectAllQuestionsForQuestionList = function (questionListName) {
            var _this = this;
            var questionIdentifiers = this.getListForField(questionListName);
            var questions = [];
            questionIdentifiers.forEach(function (questionIdentifier) {
                var question = _this.tripleStore.makeObject(questionIdentifier, true);
                questions.push(question);
            });
            return questions;
        };
        Project.prototype.collectAllElicitingQuestions = function () {
            var questions = this.collectAllQuestionsForQuestionList("project_elicitingQuestionsList");
            return questions;
        };
        Project.prototype.collectAllStoryQuestions = function () {
            var questions = this.collectAllQuestionsForQuestionList("project_storyQuestionsList");
            return questions;
        };
        Project.prototype.collectAllParticipantQuestions = function () {
            var questions = this.collectAllQuestionsForQuestionList("project_participantQuestionsList");
            return questions;
        };
        Project.prototype.collectAllAnnotationQuestions = function () {
            var questions = this.collectAllQuestionsForQuestionList("project_annotationQuestionsList");
            return questions;
        };
        Project.prototype.questionsForCategory = function (questionCategory) {
            switch (questionCategory) {
                case "elicitingQuestion":
                    return this.collectAllElicitingQuestions();
                case "storyQuestion":
                    return this.collectAllStoryQuestions();
                case "participantQuestion":
                    return this.collectAllParticipantQuestions();
                case "annotationQuestion":
                    return this.collectAllAnnotationQuestions();
                default:
                    throw new Error("Unexpected question category: " + questionCategory);
            }
        };
        Project.prototype.addQuestionForCategory = function (question, questionCategory) {
            var questionListName;
            var questionClass;
            switch (questionCategory) {
                case "elicitingQuestion":
                    questionListName = "project_elicitingQuestionsList";
                    questionClass = "ElicitingQuestion";
                    break;
                case "storyQuestion":
                    questionListName = "project_storyQuestionsList";
                    questionClass = "StoryQuestion";
                    break;
                case "participantQuestion":
                    questionListName = "project_participantQuestionsList";
                    questionClass = "ParticipantQuestion";
                    break;
                case "annotationQuestion":
                    questionListName = "project_annotationQuestionsList";
                    questionClass = "AnnotationQuestion";
                    break;
                default:
                    throw new Error("Unexpected question category: " + questionCategory);
            }
            var setIdentifier = this.getFieldValue(questionListName);
            if (!setIdentifier) {
                // Need to create list
                setIdentifier = this.tripleStore.newIdForSet(questionClass + "Set");
                // console.log("Making set for ", questionListName, setIdentifier); 
                this.setFieldValue(questionListName, setIdentifier);
            }
            this.tripleStore.makeNewSetItem(setIdentifier, questionClass, question);
        };
        Project.prototype.storiesForCatalysisReport = function (catalysisReportIdentifier) {
            var _this = this;
            var result = [];
            var storyCollectionsIdentifier = this.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_storyCollections");
            var storyCollectionItems = this.tripleStore.getListForSetIdentifier(storyCollectionsIdentifier);
            if (storyCollectionItems.length === 0)
                return [];
            storyCollectionItems.forEach(function (storyCollectionPointer) {
                if (storyCollectionPointer) {
                    var storyCollectionIdentifier = _this.tripleStore.queryLatestC(storyCollectionPointer, "storyCollection");
                    result = result.concat(surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier));
                }
                else {
                    console.log("ERROR: null or undefined storyCollectionPointer", catalysisReportIdentifier);
                }
            });
            return result;
        };
        Project.prototype.minimumStoryCountRequiredForTest = function (catalysisReportIdentifier) {
            if (!catalysisReportIdentifier) {
                throw new Error("catalysisReportIdentifier was not supplied");
            }
            var minimumStoryCountRequiredForTest = this.tripleStore.queryLatestC(catalysisReportIdentifier, "minimumSubsetSize");
            if (minimumStoryCountRequiredForTest) {
                return parseInt(minimumStoryCountRequiredForTest, 10);
            }
            else {
                return Project.defaultMinimumStoryCountRequiredForTest;
            }
        };
        Project.defaultMinimumStoryCountRequiredForTest = 20;
        return Project;
    })();
    return Project;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
define('js/panelBuilder/GridWithItemPanel',["require", "exports", "mithril", "./translate", "../pointrel20150417/generateRandomUuid", "./valuePathResolver", "../Globals", "lodash"], function (require, exports, m, translate, generateRandomUuid, valuePathResolver, Globals, _) {
    "use strict";
    // This defines a gui component which has a grid, some buttons, and a detail panel do display the currently selected item or enter a new item
    // TODO: Probably need to prevent user surveys from having a question with a short name of "_id".
    var gridsMade = 0;
    var displayTypesToDisplayAsColumns = {
        text: true,
        textarea: true,
        select: true,
        radiobuttons: true
    };
    function computeColumnsForItemPanelSpecification(itemPanelSpecification, gridConfiguration) {
        // var self = this;
        var columns = [];
        var panelFields = itemPanelSpecification.panelFields;
        if (!panelFields || !gridConfiguration)
            return columns;
        var maxColumnCount = 5;
        var columnCount = 0;
        var fieldsToInclude = [];
        var columnsToDisplay = gridConfiguration.columnsToDisplay;
        // Put the columns in the order supplied if using columnsToDisplay, otherwise put them in order of panel specification
        if (columnsToDisplay && columnsToDisplay.constructor === Array) {
            columnsToDisplay.forEach(function (fieldName) {
                panelFields.forEach(function (fieldSpecification) {
                    if (fieldSpecification.id === fieldName)
                        fieldsToInclude.push(fieldSpecification);
                });
            });
        }
        else {
            panelFields.forEach(function (fieldSpecification) {
                var includeField = false;
                if (columnsToDisplay) {
                    // TODO: improve this check if need to exclude other fields?
                    if (fieldSpecification.displayType !== "label" && fieldSpecification.displayType !== "header") {
                        fieldsToInclude.push(fieldSpecification);
                    }
                }
                else {
                    if (columnCount < maxColumnCount) {
                        if (displayTypesToDisplayAsColumns[fieldSpecification.displayType])
                            fieldsToInclude.push(fieldSpecification);
                        columnCount++;
                    }
                }
            });
        }
        fieldsToInclude.forEach(function (fieldSpecification) {
            // console.log("includeField", fieldSpecification);
            var newColumn = {
                field: fieldSpecification.id,
                label: translate(fieldSpecification.id + "::shortName", fieldSpecification.displayName)
            };
            columns.push(newColumn);
            // console.log("newColumn", newColumn);
        });
        return columns;
    }
    function isElementInViewport(parent, element) {
        var elementRect = element.getBoundingClientRect();
        var parentRect = parent.getBoundingClientRect();
        return (elementRect.top >= parentRect.top &&
            elementRect.left >= parentRect.left &&
            elementRect.bottom <= parentRect.bottom &&
            elementRect.right <= parentRect.right);
    }
    // TODO: This code is not currently used and probably can be removed
    function formatObjectsIfNeeded(item) {
        if (_.isString(item))
            return item;
        if (item === undefined)
            return "";
        if (item === null)
            return "";
        return JSON.stringify(item);
    }
    var ItemPanel = (function () {
        function ItemPanel() {
        }
        ItemPanel.controller = function (args) {
            // console.log("Making ItemPanel: ", args);
            return new ItemPanel();
        };
        ItemPanel.view = function (controller, args) {
            // console.log("ItemPanel view called");
            return controller.calculateView(args);
        };
        ItemPanel.prototype.calculateView = function (args) {
            // console.log("%%%%%%%%%%%%%%%%%%% ItemPanel view called");
            // return m("div", "work in progress");
            // TODO: Should provide copy of item?
            var panelBuilder = args.panelBuilder;
            // Possible recursion if the panels contain a table
            var theClass = "narrafirma-griditempanel-viewing";
            if (args.mode === "edit") {
                theClass = "narrafirma-griditempanel-editing";
            }
            var oldReadOnly = panelBuilder.readOnly;
            if (args.mode === "view") {
                panelBuilder.readOnly = true;
            }
            try {
                var div = m("div", { "class": theClass }, panelBuilder.buildPanel(args.grid.itemPanelSpecification, args.item));
                return div;
            }
            finally {
                panelBuilder.readOnly = oldReadOnly;
            }
        };
        return ItemPanel;
    })();
    var defaultGridConfiguration = {
        idProperty: undefined,
        viewButton: true,
        addButton: true,
        removeButton: true,
        editButton: true,
        columnsToDisplay: false,
        inlineButtons: false,
        navigationButtons: false,
        // Flag for whether removing an item then selects the next item after it
        // This flag makes it easy to quickly delete a lot of items, which is maybe not good in some cases
        shouldNextItemBeSelectedAfterItemRemoved: false,
        customButton: null,
        validateAdd: null,
        validateEdit: null,
        duplicateButton: false,
        // TODO: Need to make work:
        moveUpDownButtons: false
    };
    // Thin arrows
    // var sortCharacterUp = "\u2191";
    // var sortCharacterDown = "\u2193";
    // var sortCharacterBoth = "\u2195";
    // Thick arrows
    var sortCharacterUp = "\u25B2";
    var sortCharacterDown = "\u25BC";
    // Blank space equal to 1em
    var sortCharacterBoth = "\u2003";
    // GridWithItemPanel needs to be a component so it can maintain a local sorted list
    var GridWithItemPanel = (function () {
        function GridWithItemPanel(args) {
            this.gridID = "grid_" + (++gridsMade);
            this.gridConfiguration = null;
            this.columns = [];
            this.fieldSpecification = null;
            this.itemPanelSpecification = null;
            this.idProperty = "_id";
            this.model = null;
            this.panelBuilder = null;
            // viewing, editing, adding
            this.displayMode = null;
            // TODO: Multiple select
            this.selectedItem = null;
            this.isNavigationalScrollingNeeded = null;
            this.doubleClickAction = null;
            this.sortBy = null;
            this.sortDirection = "ascending";
            this.readOnly = false;
            // console.log("************************************** GridWithItemPanel constructor called");
            this.panelBuilder = args.panelBuilder;
            this.fieldSpecification = args.fieldSpecification;
            this.model = args.model;
            this.readOnly = args.readOnly;
            // console.log("Grid readOnly =", this.readOnly, this.fieldSpecification.id);
            this.updateDisplayConfigurationAndData(this.fieldSpecification.displayConfiguration);
        }
        GridWithItemPanel.prototype.onunload = function () {
            // console.log("+++++++++++++++++++++++++++++++++++++ unloading GridWithItemPanel");
        };
        GridWithItemPanel.prototype.updateDisplayConfigurationAndData = function (theDisplayConfiguration) {
            // console.log("theDisplayConfiguration", theDisplayConfiguration);
            var itemPanelID;
            var itemPanelSpecification = null;
            if (_.isString(theDisplayConfiguration)) {
                itemPanelID = theDisplayConfiguration;
                this.gridConfiguration = defaultGridConfiguration;
            }
            else {
                itemPanelID = theDisplayConfiguration.itemPanelID;
                if (theDisplayConfiguration.gridConfiguration) {
                    this.gridConfiguration = theDisplayConfiguration.gridConfiguration;
                }
                else {
                    this.gridConfiguration = defaultGridConfiguration;
                }
                itemPanelSpecification = theDisplayConfiguration.itemPanelSpecification;
            }
            if (!itemPanelSpecification && itemPanelID) {
                itemPanelSpecification = this.panelBuilder.getPanelDefinitionForPanelID(itemPanelID);
            }
            this.itemPanelSpecification = itemPanelSpecification;
            if (!this.itemPanelSpecification) {
                console.log("Trouble: no itemPanelSpecification for options: ", this.fieldSpecification);
            }
            if (!this.model) {
                console.log("Error: no model is defined for grid", this.fieldSpecification);
                throw new Error("Error: no model is defined for grid");
            }
            if (this.gridConfiguration.idProperty)
                this.idProperty = this.gridConfiguration.idProperty;
            this.columns = computeColumnsForItemPanelSpecification(this.itemPanelSpecification, this.gridConfiguration);
            if (this.columns.length) {
                this.sortBy = this.columns[0].field;
            }
            // viewing, editing
            this.displayMode = null;
            // TODO: Multiple select
            this.setSelectedItem(null);
            this.isNavigationalScrollingNeeded = null;
            this.valueProperty = valuePathResolver.newValuePathForFieldSpecification(this.model, this.fieldSpecification);
            var itemClassName = itemPanelSpecification.modelClass;
            if (!itemClassName) {
                console.log("ERROR: No modelClass in panel specification", itemPanelSpecification);
                throw new Error("ERROR: No modelClass in panel specification for grid");
            }
            var setClassName = itemPanelSpecification.modelClass + "Set";
            if (this.useTriples()) {
                // console.log("Grid using triples", this.model);
                this.dataStore = new TripleSetDataStore(this.valueProperty, this.idProperty, this.gridConfiguration.transformDisplayedValues, setClassName, itemClassName, Globals.project().tripleStore);
            }
            else {
                // console.log("Grid using objects", this.model);
                this.dataStore = new DataStore(this.valueProperty, this.idProperty, this.gridConfiguration.transformDisplayedValues, setClassName, itemClassName);
            }
            this.updateData();
        };
        GridWithItemPanel.prototype.updateData = function () {
            // console.log("GridWithItemPanel updateData");
            this.dataStore.getDataArrayFromModel();
            this.sortData();
            if (this.selectedItem) {
                if (this.dataStore.data.indexOf(this.selectedItem) === -1) {
                    this.setSelectedItem(null);
                }
            }
        };
        GridWithItemPanel.prototype.sortData = function () {
            // TODO: This may need work for set???
            this.dataStore.sortData(this.sortBy, this.sortDirection);
        };
        GridWithItemPanel.controller = function (args) {
            // console.log("Making ItemPanel: ", args);
            return new GridWithItemPanel(args);
        };
        GridWithItemPanel.view = function (controller, args) {
            // console.log("Grid view called");
            return controller.calculateView();
        };
        GridWithItemPanel.prototype.addNavigationButtons = function (buttons) {
            // TODO: Improve navigation enabling
            var navigationDisabled = this.isEditing() || this.dataStore.isEmpty() || undefined;
            buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "start"), disabled: navigationDisabled }, translate("#button_navigateStart|[<<")));
            buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "previous"), disabled: navigationDisabled }, translate("#button_navigatePrevious|<")));
            buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "next"), disabled: navigationDisabled }, translate("#button_navigateNext|>")));
            buttons.push(m("button", { onclick: this.navigateClicked.bind(this, "end"), disabled: navigationDisabled }, translate("#button_navigateEnd|>>]")));
        };
        GridWithItemPanel.prototype.calculateView = function () {
            // console.log("GridWithItemPanel calculateView", this.dataStore);
            var _this = this;
            // Deal with the fact that new items might be added at any time by other users
            // TODO: This is very inefficient. Alternatives include: listening for changes that add or remove items; or determing nature of change prompting redraw
            this.updateData();
            var panelBuilder = this.panelBuilder;
            var columnHeaders = this.columns.map(function (column) {
                var sortCharacter = sortCharacterBoth;
                if (column.field === _this.sortBy) {
                    if (_this.sortDirection === "ascending") {
                        sortCharacter = sortCharacterDown;
                    }
                    else if (_this.sortDirection === "descending") {
                        sortCharacter = sortCharacterUp;
                    }
                }
                return m("th[data-sort-by=" + column.field + "]", { "text-overflow": "ellipsis" }, column.label + sortCharacter);
            });
            if (this.gridConfiguration.inlineButtons) {
                columnHeaders.push(m("th", ""));
            }
            var table = m("table.scrolling", this.tableConfigurationWithSortingOnHeaderClick(), [
                m("tr", { "class": "grid-header-row" }, columnHeaders),
                this.dataStore.map(function (item, index) {
                    return _this.rowForItem(item, index);
                })
            ]);
            var addButtonDisabled = this.readOnly || this.isEditing() || undefined;
            var buttons = [];
            if (this.gridConfiguration.addButton) {
                var addButton = m("button", { onclick: this.addItem.bind(this), disabled: addButtonDisabled }, translate("#button_Add|Add"));
                buttons.push(addButton);
            }
            if (!this.gridConfiguration.inlineButtons) {
                buttons = buttons.concat(this.createButtons());
            }
            if (this.gridConfiguration.navigationButtons) {
                this.addNavigationButtons(buttons);
            }
            var buttonPanel = m("div.narrafirma-button-panel", buttons);
            var parts = [m("div.narrafirm-grid", [table]), buttonPanel];
            if (this.isViewing()) {
                parts.push(this.bottomEditorForItem(panelBuilder, this.selectedItem, "view"));
            }
            if (this.isEditing()) {
                parts.push(this.bottomEditorForItem(panelBuilder, this.selectedItem, "edit"));
            }
            // TODO: set class etc.
            return m("div", { "class": "questionExternal narrafirma-question-type-grid" }, parts);
        };
        GridWithItemPanel.prototype.tableConfigurationWithSortingOnHeaderClick = function () {
            var _this = this;
            return {
                onclick: function (e) {
                    var sortBy = e.target.getAttribute("data-sort-by");
                    if (sortBy) {
                        // Sorting derived from: http://lhorie.github.io/mithril-blog/vanilla-table-sorting.htm
                        // Don't sort if have move up/down buttons
                        if (_this.gridConfiguration.moveUpDownButtons)
                            return;
                        // console.log("Sorting by", sortBy);
                        if (_this.sortBy === sortBy) {
                            if (_this.sortDirection === "ascending") {
                                _this.sortDirection = "descending";
                                _this.dataStore.reverseData();
                            }
                            else {
                                _this.sortDirection = "ascending";
                                _this.dataStore.reverseData();
                            }
                        }
                        else {
                            _this.sortBy = sortBy;
                            _this.sortDirection = "ascending";
                            _this.sortData();
                        }
                    }
                    else {
                        _this.selectItemInList(e);
                    }
                },
                ondblclick: function (e) {
                    var prop = e.target.getAttribute("data-sort-by");
                    if (!prop) {
                        if (_this.selectedItem && _this.doubleClickAction) {
                            _this.doubleClickAction(_this.selectedItem);
                        }
                    }
                },
                config: this.ensureTableRowIsVisibleConfig.bind(this)
            };
        };
        GridWithItemPanel.prototype.selectItemInList = function (e) {
            if (this.isEditing())
                return;
            var itemID = e.target.getAttribute("data-item-index");
            // console.log("item clicked", itemID);
            var item = this.dataStore.itemForId(itemID);
            if (item !== undefined) {
                this.setSelectedItem(item);
                if (this.gridConfiguration.viewButton) {
                    this.displayMode = "viewing";
                }
            }
        };
        GridWithItemPanel.prototype.setSelectedItem = function (item) {
            this.selectedItem = item;
            if (this.gridConfiguration.selectCallback) {
                this.gridConfiguration.selectCallback(this.selectedItem);
            }
        };
        GridWithItemPanel.prototype.isEditing = function () {
            return (this.displayMode === "editing" || this.displayMode === "adding") && this.selectedItem;
        };
        GridWithItemPanel.prototype.isViewing = function () {
            return (this.displayMode === "viewing") && this.selectedItem;
        };
        GridWithItemPanel.prototype.getSelectedItem = function () {
            return this.selectedItem;
        };
        GridWithItemPanel.prototype.validateItem = function (item) {
            var validationMethodIdentifier = this.gridConfiguration.validateEdit;
            if (this.displayMode === "adding")
                validationMethodIdentifier = this.gridConfiguration.validateAdd || validationMethodIdentifier;
            if (validationMethodIdentifier) {
                var fakeFieldSpecification = {
                    displayConfiguration: validationMethodIdentifier,
                    value: item
                };
                var errors = this.panelBuilder.calculateFunctionResult(null, fakeFieldSpecification);
                if (!errors)
                    return [];
                return errors;
            }
            return [];
        };
        // inlineEditorForItem is not currently used...
        GridWithItemPanel.prototype.inlineEditorForItem = function (panelBuilder, item, mode) {
            return m("tr", [
                m("td", { colSpan: this.columns.length }, [
                    m.component(ItemPanel, { key: this.fieldSpecification.id + "_" + "inlineEditor" + "_" + mode, panelBuilder: panelBuilder, item: item, grid: this, mode: mode })
                ]),
                m("td", { "vertical-align": "top" }, [m("button", { onclick: this.doneClicked.bind(this, item) }, "close")])
            ]);
        };
        GridWithItemPanel.prototype.bottomEditorForItem = function (panelBuilder, item, mode) {
            return m("div", [
                m("td", { colSpan: this.columns.length }, [
                    m.component(ItemPanel, { key: this.fieldSpecification.id + "_" + "bottomEditor" + "_" + mode, panelBuilder: panelBuilder, item: item, grid: this, mode: mode })
                ]),
                m("td", { "vertical-align": "top" }, [m("button", { onclick: this.doneClicked.bind(this, item) }, "close")])
            ]);
        };
        // Event handlers
        GridWithItemPanel.prototype.addItem = function () {
            var newItem = this.dataStore.makeNewItem();
            this.setSelectedItem(newItem);
            this.displayMode = "adding";
        };
        GridWithItemPanel.prototype.deleteItem = function (item) {
            if (!item)
                item = this.selectedItem;
            // console.log("deleteItem", item);
            // TODO: Translate
            // TODO: Replace this with undo
            if (!confirm("Are you sure you want to delete this item?"))
                return;
            var index = this.dataStore.deleteItem(item);
            if (item === this.selectedItem) {
                this.setSelectedItem(null);
                if (this.gridConfiguration.shouldNextItemBeSelectedAfterItemRemoved) {
                    if (index === this.dataStore.length()) {
                        index = index - 1;
                    }
                    if (!this.dataStore.isEmpty()) {
                        this.setSelectedItem(this.dataStore.itemForIndex(index));
                    }
                    else {
                        this.setSelectedItem(null);
                    }
                    this.isNavigationalScrollingNeeded = "delete";
                }
            }
        };
        GridWithItemPanel.prototype.editItem = function (item) {
            if (!item)
                item = this.selectedItem;
            // console.log("editItem", item);
            // TODO: This needs to create an action that affects original list  
            this.setSelectedItem(item);
            this.displayMode = "editing";
        };
        GridWithItemPanel.prototype.viewItem = function (item, index) {
            if (!item)
                item = this.selectedItem;
            // console.log("viewItem", item);
            this.setSelectedItem(item);
            this.displayMode = "viewing";
        };
        GridWithItemPanel.prototype.duplicateItem = function (item) {
            if (!item)
                item = this.selectedItem;
            // console.log("duplicate button pressed", item);
            // TODO: May not need this
            if (this.isEditing) {
                alert("The edit must be finished before duplicating an item");
                return;
            }
            if (!item) {
                alert("Please select an item to duplicate first");
                return;
            }
            var newItem = this.dataStore.makeCopyOfItemWithNewId(item);
            this.setSelectedItem(newItem);
            this.displayMode = "adding";
        };
        GridWithItemPanel.prototype.moveItemUp = function (item) {
            if (!item)
                item = this.selectedItem;
            // console.log("up button pressed", item);
            this.dataStore.moveItemUp(item);
        };
        GridWithItemPanel.prototype.moveItemDown = function (item) {
            if (!item)
                item = this.selectedItem;
            // console.log("down button pressed", item);
            this.dataStore.moveItemDown(item);
        };
        GridWithItemPanel.prototype.doneClicked = function (item) {
            // TODO: Should ensure the data is saved
            if (this.isEditing) {
                var errors = this.validateItem(item);
                if (errors.length) {
                    // TODO: Translate
                    alert("There are validation errors:\n" + errors);
                    return;
                }
            }
            // Leave item selected: this.setSelection(null);
            this.displayMode = null;
        };
        GridWithItemPanel.prototype.navigateClicked = function (direction) {
            if (this.dataStore.isEmpty())
                return;
            var newPosition;
            switch (direction) {
                case "start":
                    newPosition = 0;
                    break;
                case "previous":
                    newPosition = this.dataStore.indexOf(this.selectedItem);
                    if (newPosition === -1)
                        newPosition = 0;
                    if (newPosition > 0)
                        newPosition--;
                    break;
                case "next":
                    newPosition = this.dataStore.indexOf(this.selectedItem);
                    if (newPosition < this.dataStore.length() - 1)
                        newPosition++;
                    break;
                case "end":
                    newPosition = this.dataStore.length() - 1;
                    break;
                default:
                    throw new Error("Unexpected direction: " + direction);
            }
            this.setSelectedItem(this.dataStore.itemForIndex(newPosition));
            this.isNavigationalScrollingNeeded = direction;
        };
        GridWithItemPanel.prototype.createButtons = function (item) {
            var _this = this;
            if (item === void 0) { item = undefined; }
            var buttons = [];
            var unavailable = this.isEditing() || (!item && !this.selectedItem) || undefined;
            var disabled = this.readOnly || unavailable;
            // console.log("createButtons disabled", disabled, item, this.selectedItem, (!item && !this.selectedItem) );
            if (this.gridConfiguration.removeButton) {
                var removeButton = m("button", { onclick: this.deleteItem.bind(this, item), disabled: disabled, "class": "fader" }, translate("#button_Remove|Remove"));
                buttons.push(removeButton);
            }
            if (this.gridConfiguration.editButton) {
                var editButton = m("button", { onclick: this.editItem.bind(this, item), disabled: disabled, "class": "fader" }, translate("#button_Edit|Edit"));
                buttons.push(editButton);
            }
            if (this.gridConfiguration.viewButton) {
                var viewButton = m("button", { onclick: this.viewItem.bind(this, item), disabled: unavailable, "class": "fader" }, translate("#button_View|View"));
                buttons.push(viewButton);
            }
            if (this.gridConfiguration.duplicateButton) {
                var duplicateButton = m("button", { onclick: this.duplicateItem.bind(this, item), disabled: disabled }, translate("#button_Duplicate|Duplicate"));
                buttons.push(duplicateButton);
            }
            if (this.gridConfiguration.moveUpDownButtons) {
                var upButton = m("button", { onclick: this.moveItemUp.bind(this, item), disabled: disabled }, translate("#button_Up|Up"));
                buttons.push(upButton);
                var downButton = m("button", { onclick: this.moveItemDown.bind(this, item), disabled: disabled }, translate("#button_Down|Down"));
                buttons.push(downButton);
            }
            if (this.gridConfiguration.customButton) {
                var options = this.gridConfiguration.customButton;
                var customButtonClickedPartial;
                if (_.isString(options.callback)) {
                    var fakeFieldSpecification = { id: this.fieldSpecification.id, displayConfiguration: options.callback, grid: this, item: item };
                    customButtonClickedPartial = this.panelBuilder.buttonClicked.bind(this.panelBuilder, this.model, fakeFieldSpecification);
                }
                else {
                    customButtonClickedPartial = function (event) { options.callback(_this, item); };
                }
                var doubleClickFunction;
                if (!this.gridConfiguration.viewButton) {
                    this.doubleClickAction = customButtonClickedPartial;
                }
                var customButton = m("button", { onclick: customButtonClickedPartial, disabled: disabled }, translate(options.customButtonLabel));
                buttons.push(customButton);
            }
            // console.log("made buttons", buttons, item);
            return buttons;
        };
        GridWithItemPanel.prototype.rowForItem = function (item, index) {
            /* TODO: Use inline editor, if some config option is set:
            return inlineEditorForItem(panelBuilder, item, mode);
            */
            var _this = this;
            var selected = (item === this.selectedItem);
            var selectionClass = "";
            if (selected) {
                if (index % 2 === 0) {
                    selectionClass = "narrafirma-grid-row-selected-even";
                }
                else {
                    selectionClass = "narrafirma-grid-row-selected-odd";
                }
            }
            else {
                if (index % 2 === 0) {
                    selectionClass = "narrafirma-grid-row-unselected-even";
                }
                else {
                    selectionClass = "narrafirma-grid-row-unselected-odd";
                }
            }
            var fields = this.columns.map(function (column) {
                return m("td", { "text-overflow": "ellipsis", "data-item-index": _this.dataStore.idForItem(item), id: _this.makeHtmlIdForItem(item) }, _this.dataStore.valueForField(item, column.field));
            });
            if (this.gridConfiguration.inlineButtons) {
                var buttons = this.createButtons(item);
                fields = fields.concat(m("td", { nowrap: true }, buttons));
            }
            return m("tr", { key: this.dataStore.idForItem(item), "class": selectionClass }, fields);
        };
        GridWithItemPanel.prototype.ensureTableRowIsVisibleConfig = function (tableElement, isInitialized, context) {
            // Ensure the selected item is visible in the table
            // TODO: Could improve this so when navigating down the item is still near the bottom
            if (this.selectedItem && this.isNavigationalScrollingNeeded) {
                var rowElement = document.getElementById(this.makeHtmlIdForItem(this.selectedItem));
                if (rowElement && !isElementInViewport(tableElement, rowElement)) {
                    if (this.isNavigationalScrollingNeeded === "next" || this.isNavigationalScrollingNeeded === "end") {
                        tableElement.scrollTop = rowElement.offsetTop - tableElement.clientHeight + rowElement.offsetHeight;
                    }
                    else {
                        tableElement.scrollTop = rowElement.offsetTop;
                    }
                }
                this.isNavigationalScrollingNeeded = null;
            }
        };
        GridWithItemPanel.prototype.makeHtmlIdForItem = function (item) {
            return this.gridID + this.dataStore.idForItem(item);
        };
        GridWithItemPanel.prototype.useTriples = function () {
            if (typeof this.model === "string")
                return true;
            var storage = this.valueProperty();
            return typeof storage === "string";
        };
        return GridWithItemPanel;
    })();
    // ObjectArray datastore as base
    var DataStore = (function () {
        function DataStore(valueProperty, idProperty, valueTransform, setClassName, itemClassName) {
            this.valueProperty = valueProperty;
            this.idProperty = idProperty;
            this.valueTransform = valueTransform;
            this.setClassName = setClassName;
            this.itemClassName = itemClassName;
        }
        DataStore.prototype.newIdForItem = function () {
            // return new Date().toISOString();
            return generateRandomUuid(this.itemClassName);
        };
        DataStore.prototype.length = function () {
            return this.data.length;
        };
        DataStore.prototype.isEmpty = function () {
            return this.data.length === 0;
        };
        DataStore.prototype.getDataArrayFromModel = function () {
            var data = this.valueProperty();
            if (!data) {
                data = [];
                // console.log("Grid datastore getDataArrayFromModel defaulting data to empty array");
                this.valueProperty(data);
            }
            // Make a copy of the data because we will be sorting it
            // TODO: Copying data creates a problem because up/down movement wil not be reflected in original
            this.data = data.slice();
        };
        DataStore.prototype.makeCopyOfItemWithNewId = function (item) {
            // TODO: This needs to create an action that affects original list
            // Make a copy of the selected item
            var newItem = JSON.parse(JSON.stringify(item));
            // Set new id for copy
            // TODO: Will not work right if item is an object with some class
            newItem[this.idProperty] = this.newIdForItem();
            this.data.push(newItem);
            // TODO: This item will not be sorted
            return newItem;
        };
        DataStore.prototype.makeNewItem = function () {
            // TODO: This needs to create an action that affects original list
            var newItem = {};
            // TODO: Will not work right if item is an object with some class
            newItem[this.idProperty] = this.newIdForItem();
            this.data.push(newItem);
            // TODO: This item will not be sorted
            return newItem;
        };
        DataStore.prototype.deleteItem = function (item) {
            // TODO: This needs to create an action that affects original list
            var index = this.data.indexOf(item);
            this.data.splice(index, 1);
            return index;
        };
        DataStore.prototype.moveItemUp = function (item) {
            // TODO: How to move this change back to project data???
            var index = this.data.indexOf(item);
            if (index <= 0)
                return;
            this.data[index] = this.data[index - 1];
            this.data[index - 1] = item;
        };
        DataStore.prototype.moveItemDown = function (item) {
            // TODO: How to move this change back to project data???
            var index = this.data.indexOf(item);
            if (index === -1 || index === this.data.length - 1)
                return;
            this.data[index] = this.data[index + 1];
            this.data[index + 1] = item;
        };
        DataStore.prototype.idForItem = function (item) {
            var value = item[this.idProperty];
            if (typeof value === "function") {
                value = value.bind(item)();
            }
            return value;
        };
        DataStore.prototype.itemForId = function (itemID) {
            for (var i = 0; i < this.data.length; i++) {
                var item = this.data[i];
                if (this.idForItem(item) === itemID) {
                    return item;
                }
            }
            return undefined;
        };
        DataStore.prototype.valueForField = function (item, fieldName) {
            var value = item[fieldName];
            // Resolve accessing functions
            if (typeof value === "function")
                value = value.bind(item)();
            if (this.valueTransform)
                value = this.valueTransform(value, fieldName);
            return value;
        };
        DataStore.prototype.itemForIndex = function (index) {
            return this.data[index];
        };
        DataStore.prototype.map = function (callback) {
            return this.data.map(callback);
        };
        DataStore.prototype.indexOf = function (item) {
            return this.data.indexOf(item);
        };
        DataStore.prototype.sortData = function (fieldIdentifier, sortDirection) {
            var _this = this;
            // TODO: This may need work for set???
            this.data.sort(function (a, b) {
                var aValue = _this.valueForField(a, fieldIdentifier);
                if (aValue === null || aValue === undefined)
                    aValue = "";
                if (typeof aValue === "string")
                    aValue = aValue.toLowerCase();
                var bValue = _this.valueForField(b, fieldIdentifier);
                if (bValue === null || bValue === undefined)
                    bValue = "";
                if (typeof bValue === "string")
                    bValue = bValue.toLowerCase();
                return aValue > bValue ? 1 : aValue < bValue ? -1 : 0;
            });
            if (sortDirection === "descending") {
                // console.log("reversing");
                this.data.reverse();
            }
            // console.log("sorted list", this.data);
        };
        DataStore.prototype.reverseData = function () {
            this.data.reverse();
        };
        return DataStore;
    })();
    var TripleSetDataStore = (function (_super) {
        __extends(TripleSetDataStore, _super);
        function TripleSetDataStore(valueProperty, idProperty, valueTransform, setClassName, itemClassName, tripleStore) {
            _super.call(this, valueProperty, idProperty, valueTransform, setClassName, itemClassName);
            this.tripleStore = tripleStore;
        }
        TripleSetDataStore.prototype.getDataArrayFromModel = function () {
            this.setIdentifier = this.valueProperty();
            // Design issue: Should we make a set if none exists at this time as opposed to lazily at first insertion of data?
            if (this.setIdentifier) {
                this.data = this.tripleStore.getListForSetIdentifier(this.setIdentifier);
            }
            else {
                this.data = [];
            }
        };
        // We don't make the set at startup; lazily make it if needed now
        TripleSetDataStore.prototype.ensureSetExists = function () {
            // TODO: Remove temporary addition with comparison on string type (for upgrading old data)
            if (!this.setIdentifier || typeof this.setIdentifier !== "string") {
                this.setIdentifier = this.tripleStore.newIdForSet(this.setClassName);
                // console.log("Grid triplestore getDataArrayFromModel defaulting data to empty set with id", this.setIdentifier);
                this.valueProperty(this.setIdentifier);
            }
        };
        TripleSetDataStore.prototype.makeCopyOfItemWithNewId = function (item) {
            // TODO: This needs to create an action that affects original list
            // Make a copy of the selected item
            this.ensureSetExists();
            var newId = this.tripleStore.makeCopyOfSetItemWithNewId(this.setIdentifier, this.itemClassName, item);
            this.data.push(newId);
            return newId;
        };
        TripleSetDataStore.prototype.makeNewItem = function () {
            // TODO: This needs to create an action that affects original list
            this.ensureSetExists();
            var newId = this.tripleStore.makeNewSetItem(this.setIdentifier, this.itemClassName);
            this.data.push(newId);
            return newId;
        };
        TripleSetDataStore.prototype.deleteItem = function (item) {
            // TODO: This needs to create an action that affects original list
            // TODO: Should the C be undefined instead of null?
            this.tripleStore.deleteSetItem(this.setIdentifier, item);
            var index = this.data.indexOf(item);
            this.data.splice(index, 1);
            return index;
        };
        TripleSetDataStore.prototype.moveItemUp = function (item) {
            throw new Error("TripleSetDataStore moveItemUp Unfinished");
        };
        TripleSetDataStore.prototype.moveItemDown = function (item) {
            throw new Error("TripleSetDataStore moveItemDown Unfinished");
        };
        TripleSetDataStore.prototype.idForItem = function (item) {
            return item;
        };
        TripleSetDataStore.prototype.valueForField = function (item, fieldName) {
            var value = this.tripleStore.queryLatestC(item, fieldName);
            if (this.valueTransform)
                value = this.valueTransform(value, fieldName);
            return value;
        };
        return TripleSetDataStore;
    })(DataStore);
    return GridWithItemPanel;
});

define('js/applicationWidgets/PatternExplorer',["require", "exports", "./charting", "../calculateStatistics", "../storyCardDisplay", "../questionnaireGeneration", "../panelBuilder/valuePathResolver", "mithril", "../Project", "../panelBuilder/GridWithItemPanel", "../pointrel20150417/generateRandomUuid", "../Globals", "lodash"], function (require, exports, charting, calculateStatistics, storyCardDisplay, questionnaireGeneration, valuePathResolver, m, Project, GridWithItemPanel, generateRandomUuid, Globals, _) {
    "use strict";
    // Question types that have data associated with them for filters and graphs
    var nominalQuestionTypes = ["select", "boolean", "checkbox", "checkboxes", "radiobuttons", "text"];
    var patternsPanelSpecification = {
        id: "patternsPanel",
        modelClass: "Pattern",
        panelFields: [
            { id: "id", displayName: "Index" },
            { id: "patternName", displayName: "Pattern name", valueOptions: [] },
            { id: "graphType", displayName: "Graph type", valueOptions: [] },
            { id: "significance", displayName: "Significance value", valueOptions: [] },
            // {id: "reviewed", displayName: "Reviewed", valueOptions: []},
            { id: "observation", displayName: "Observation", valueOptions: [] }
        ]
    };
    // TODO: Duplicate code for this function copied from charting
    function nameForQuestion(question) {
        if (question.displayName)
            return question.displayName;
        if (question.displayPrompt)
            return question.displayPrompt;
        return question.id;
    }
    // TODO: Next two functions from add_storyBrowser and so are duplicate code
    function buildStoryDisplayPanel(panelBuilder, model) {
        var storyCardDiv = storyCardDisplay.generateStoryCardContent(model);
        return storyCardDiv;
    }
    function makeItemPanelSpecificationForQuestions(questions) {
        // TODO: add more participant and survey info, like timestamps and participant ID
        var storyItemPanelSpecification = {
            id: "patternBrowserQuestions",
            modelClass: "Story",
            panelFields: questions,
            buildPanel: buildStoryDisplayPanel
        };
        return storyItemPanelSpecification;
    }
    // Do not store the option texts directly in selection as they might have braces
    //function sha256ForOption(optionText) {
    //    return SHA256(optionText, digests.outputTypes.Hex);
    //}
    function decodeBraces(optionText) {
        return optionText.replace("&#123;", "{").replace("&#125;", "}");
    }
    var PatternExplorer = (function () {
        function PatternExplorer(args) {
            this.project = null;
            this.catalysisReportIdentifier = null;
            this.catalysisReportObservationSetIdentifier = null;
            this.questionsToInclude = null;
            this.modelForPatternsGrid = { patterns: [] };
            this.questions = [];
            this.modelForStoryGrid = { storiesSelectedInGraph: [] };
            // TODO: Improve typing here that was GridDisplayConfiguration
            this.storyGridFieldSpecification = null;
            this.storyGrid = null;
            this.currentPattern = null;
            this.observationPanelSpecification = null;
            this.minimumStoryCountRequiredForTest = Project.defaultMinimumStoryCountRequiredForTest;
            this.project = Globals.project();
            // Graph display initialization
            this.graphHolder = {
                graphResultsPane: charting.createGraphResultsPane("narrafirma-graph-results-pane chartEnclosure"),
                chartPanes: [],
                allStories: [],
                currentGraph: null,
                currentSelectionExtentPercentages: null,
                minimumStoryCountRequiredForTest: Project.defaultMinimumStoryCountRequiredForTest
            };
            // Story grid initialization
            var storyItemPanelSpecification = makeItemPanelSpecificationForQuestions(this.questions);
            var storyGridConfiguration = {
                idProperty: "storyID",
                columnsToDisplay: ["storyName", "storyText"],
                viewButton: true,
                navigationButtons: true
            };
            this.storyGridFieldSpecification = {
                id: "storiesSelectedInGraph",
                itemPanelID: undefined,
                itemPanelSpecification: storyItemPanelSpecification,
                displayConfiguration: {
                    itemPanelSpecification: storyItemPanelSpecification,
                    gridConfiguration: storyGridConfiguration
                },
                // TODO: Why is gridConfiguration in here twice?
                gridConfiguration: storyGridConfiguration
            };
            this.storyGrid = new GridWithItemPanel({ panelBuilder: args.panelBuilder, model: this.modelForStoryGrid, fieldSpecification: this.storyGridFieldSpecification });
            // Observation panel initialization
            this.observationPanelSpecification = {
                "id": "observationPanel",
                panelFields: [
                    {
                        id: "observationPanel_insertGraphSelection",
                        displayPrompt: "Save graph selection",
                        displayType: "button",
                        displayPreventBreak: true,
                        displayConfiguration: this.insertGraphSelection.bind(this)
                    },
                    {
                        id: "observationPanel_resetGraphSelection",
                        displayPrompt: "Display chosen graph selection",
                        displayType: "button",
                        displayConfiguration: this.resetGraphSelection.bind(this)
                    },
                    {
                        id: "observationPanel_description",
                        valuePath: "currentObservationDescription",
                        displayName: "Observation",
                        displayPrompt: "If this pattern is noteworthy, enter an <strong>observation</strong> about the pattern here.",
                        displayType: "textarea"
                    },
                    {
                        id: "observationPanel_title",
                        valuePath: "currentObservationTitle",
                        displayName: "Observation",
                        displayPrompt: "Please give this observation a <strong>name</strong>.",
                        displayType: "text"
                    },
                    {
                        id: "observationPanel_interpretationsList",
                        valuePath: "currentObservationInterpretations",
                        valueType: "array",
                        displayType: "grid",
                        displayConfiguration: "panel_addInterpretation",
                        displayName: "Interpretation",
                        displayPrompt: "Enter at least two <strong>competing interpretations</strong> for the observation here.",
                        displayVisible: function (panelBuilder, model) {
                            return model.currentObservationDescription() || model.currentObservationTitle();
                        }
                    }
                ]
            };
            // Pattern grid initialization
            this.questionsToInclude = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "questionsToInclude");
            this.modelForPatternsGrid.patterns = this.buildPatternList();
            var patternsGridConfiguration = {
                idProperty: "id",
                columnsToDisplay: true,
                navigationButtons: true,
                selectCallback: this.patternSelected.bind(this)
            };
            var patternsGridFieldSpecification = {
                id: "patterns",
                displayConfiguration: {
                    itemPanelSpecification: patternsPanelSpecification,
                    gridConfiguration: patternsGridConfiguration
                }
            };
            this.patternsGrid = new GridWithItemPanel({ panelBuilder: args.panelBuilder, model: this.modelForPatternsGrid, fieldSpecification: patternsGridFieldSpecification });
            // TODO: selections in observation should be stored in original domain units, not scaled display units
            // Put up a "please pick pattern" message
            this.chooseGraph(null);
        }
        PatternExplorer.controller = function (args) {
            // console.log("Making PatternBrowser: ", args);
            return new PatternExplorer(args);
        };
        PatternExplorer.view = function (controller, args) {
            // console.log("PatternBrowser view called");
            return controller.calculateView(args);
        };
        PatternExplorer.prototype.calculateView = function (args) {
            // console.log("%%%%%%%%%%%%%%%%%%% PatternBrowser view called");
            var panelBuilder = args.panelBuilder;
            // Handling of caching of questions and stories
            var catalysisReportIdentifier = this.getCurrentCatalysisReportIdentifier(args);
            if (catalysisReportIdentifier !== this.catalysisReportIdentifier) {
                this.catalysisReportIdentifier = catalysisReportIdentifier;
                // console.log("storyCollectionIdentifier changed", this.catalysisReportIdentifier);
                this.currentCatalysisReportChanged(this.catalysisReportIdentifier);
            }
            var parts;
            function isMissingQuestionsToInclude(questionsToInclude) {
                if (!questionsToInclude)
                    return true;
                for (var keys in questionsToInclude) {
                    return false;
                }
                return true;
            }
            if (!this.catalysisReportIdentifier) {
                parts = [m("div.narrafirma-choose-catalysis-report", "Please select a catalysis report to work with.")];
            }
            else if (isMissingQuestionsToInclude(this.questionsToInclude)) {
                parts = [m("div.narrafirma-choose-questions-to-include", "Please select some questions to include in the report (on the previous page).")];
            }
            else {
                parts = [
                    this.patternsGrid.calculateView(),
                    this.currentPattern ?
                        [
                            m("div", { config: this.insertGraphResultsPaneConfig.bind(this) }),
                            m("div.narrafirma-pattern-browser-selected-stories-header", "Selected stories (" + this.modelForStoryGrid.storiesSelectedInGraph.length + ")"),
                            this.storyGrid.calculateView(),
                            panelBuilder.buildPanel(this.observationPanelSpecification, this)
                        ] :
                        // TODO: Translate
                        m("div.narrafirma-choose-pattern", "Please select a pattern to view as a graph.")
                ];
            }
            // TODO: Need to set class
            return m("div", parts);
        };
        PatternExplorer.prototype.insertGraphResultsPaneConfig = function (element, isInitialized, context) {
            if (!isInitialized) {
                // console.log("appending graph element");
                element.appendChild(this.graphHolder.graphResultsPane);
            }
        };
        PatternExplorer.prototype.observationAccessor = function (pattern, field, newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (!this.catalysisReportObservationSetIdentifier)
                throw new Error("observationAccessor: this.catalysisReportObservationSetIdentifier is undefined");
            var patternReference = this.patternReferenceForQuestions(pattern.questions);
            var observationIdentifier = this.project.tripleStore.queryLatestC(this.catalysisReportObservationSetIdentifier, patternReference);
            if (!observationIdentifier) {
                if (field !== "observationInterpretations" && newValue === undefined)
                    return "";
                // Lazy initialize the observation as will need to return a list which might be empty but could get used
                observationIdentifier = generateRandomUuid("Observation");
                // TODO: Ideally should not be creating entry just for looking at it
                this.project.tripleStore.addTriple(this.catalysisReportObservationSetIdentifier, patternReference, observationIdentifier);
                // Need this for printing later so know what questions & pattern go with the observation
                var patternCopyWithoutAccessorFunction = {
                    id: pattern.id,
                    graphType: pattern.graphType,
                    patternName: pattern.patternName,
                    questions: pattern.questions
                };
                this.project.tripleStore.addTriple(observationIdentifier, "pattern", patternCopyWithoutAccessorFunction);
            }
            // console.log("observationAccessor", pattern.questions, observationIdentifier, newValue);
            if (newValue === undefined) {
                var result = this.project.tripleStore.queryLatestC(observationIdentifier, field);
                if (result === undefined || result === null) {
                    result = "";
                }
                // console.log("observationAccessor", this.catalysisReportIdentifier, this.catalysisReportObservationSetIdentifier, patternReference, observation);
                return result;
            }
            else {
                this.project.tripleStore.addTriple(observationIdentifier, field, newValue);
                return newValue;
            }
        };
        PatternExplorer.prototype.currentObservationDescription = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (!this.currentPattern) {
                return "";
            }
            return this.observationAccessor(this.currentPattern, "observationDescription", newValue);
        };
        PatternExplorer.prototype.currentObservationTitle = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (!this.currentPattern) {
                return "";
            }
            return this.observationAccessor(this.currentPattern, "observationTitle", newValue);
        };
        PatternExplorer.prototype.currentObservationInterpretations = function (newValue) {
            if (newValue === void 0) { newValue = undefined; }
            if (!this.currentPattern) {
                return "";
            }
            return this.observationAccessor(this.currentPattern, "observationInterpretations", newValue);
        };
        // We don't make the set when the report is created; lazily make it if needed now
        PatternExplorer.prototype.getObservationSetIdentifier = function (catalysisReportIdentifier) {
            if (!catalysisReportIdentifier) {
                throw new Error("getObservationSetIdentifier: catalysisReportIdentifier is not defined");
            }
            var setIdentifier = this.project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
            if (!setIdentifier) {
                setIdentifier = generateRandomUuid("ObservationSet");
                this.project.tripleStore.addTriple(catalysisReportIdentifier, "catalysisReport_observations", setIdentifier);
            }
            return setIdentifier;
        };
        PatternExplorer.prototype.currentCatalysisReportChanged = function (catalysisReportIdentifier) {
            // console.log("currentCatalysisReportChanged", catalysisReportIdentifier);
            if (!catalysisReportIdentifier) {
                // TODO: should clear everything
                return;
            }
            this.minimumStoryCountRequiredForTest = this.project.minimumStoryCountRequiredForTest(catalysisReportIdentifier);
            // console.log("minimumStoryCountRequiredForTest", this.minimumStoryCountRequiredForTest);
            this.catalysisReportObservationSetIdentifier = this.getObservationSetIdentifier(catalysisReportIdentifier);
            this.graphHolder.allStories = this.project.storiesForCatalysisReport(catalysisReportIdentifier);
            // console.log("allStories", this.graphHolder.allStories);
            // TODO: Filter these questions by ones of interest for specific catalysis report
            this.questions = questionnaireGeneration.collectAllQuestions();
            // console.log("questions", this.questions);
            this.questionsToInclude = this.project.tripleStore.queryLatestC(this.catalysisReportIdentifier, "questionsToInclude");
            this.modelForPatternsGrid.patterns = this.buildPatternList();
            // console.log("patterns", this.modelForPatternsGrid.patterns);
            this.patternsGrid.updateData();
            // Update item panel in story list so it has the correct header
            this.storyGridFieldSpecification.itemPanelSpecification = makeItemPanelSpecificationForQuestions(this.questions);
            this.storyGrid.updateDisplayConfigurationAndData(this.storyGridFieldSpecification);
            this.chooseGraph(null);
        };
        // TODO: Similar to what is in add_graphBrowser
        PatternExplorer.prototype.getCurrentCatalysisReportIdentifier = function (args) {
            var model = args.model;
            var fieldSpecification = args.fieldSpecification;
            // Get selected catalysis report
            var catalysisReportShortName = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification)();
            // console.log("catalysisReportShortName", catalysisReportShortName);
            if (!catalysisReportShortName)
                return null;
            return this.project.findCatalysisReport(catalysisReportShortName);
        };
        PatternExplorer.prototype.patternReferenceForQuestions = function (questions) {
            // TODO: Maybe should be object instead of array?
            var result = [];
            questions.forEach(function (question) {
                result.push(question.id);
            });
            return { setItem: result };
        };
        PatternExplorer.prototype.makePattern = function (id, graphType, questions) {
            var _this = this;
            var pattern;
            if (questions.length === 1) {
                pattern = { id: id, observation: null, graphType: graphType, patternName: nameForQuestion(questions[0]), questions: questions };
            }
            else if (questions.length === 2) {
                pattern = { id: id, observation: null, graphType: graphType, patternName: nameForQuestion(questions[0]) + " vs. " + nameForQuestion(questions[1]), questions: questions };
            }
            else {
                console.log("Unexpected number of questions", questions);
                throw new Error("Unexpected number of questions: " + questions.length);
            }
            var observation = function () {
                return _this.observationAccessor(pattern, "observationTitle") || _this.observationAccessor(pattern, "observationDescription");
            };
            // Next assignment creates a circular reference
            pattern.observation = observation;
            return pattern;
        };
        PatternExplorer.prototype.buildPatternList = function () {
            var _this = this;
            var result = [];
            var nominalQuestions = [];
            var ratioQuestions = [];
            if (!this.questionsToInclude)
                return result;
            // TODO: create all supported graphable permutations of questions
            this.questions.forEach(function (question) {
                // Skip questions that are not included in configuration
                if (_this.questionsToInclude[question.id]) {
                    if (question.displayType === "slider") {
                        ratioQuestions.push(question);
                    }
                    else if (nominalQuestionTypes.indexOf(question.displayType) !== -1) {
                        // Ony use text questions that are annotations
                        if (question.displayType === "text" && (question.id || "").substring(2) !== "A_")
                            return;
                        nominalQuestions.push(question);
                    }
                }
            });
            var questionCount = 0;
            function nextID() {
                return ("00000" + questionCount++).slice(-5);
            }
            nominalQuestions.forEach(function (question1) {
                result.push(_this.makePattern(nextID(), "bar", [question1]));
            });
            // Prevent mirror duplicates and self-matching questions
            var usedQuestions;
            usedQuestions = [];
            nominalQuestions.forEach(function (question1) {
                usedQuestions.push(question1);
                nominalQuestions.forEach(function (question2) {
                    if (usedQuestions.indexOf(question2) !== -1)
                        return;
                    result.push(_this.makePattern(nextID(), "table", [question1, question2]));
                });
            });
            ratioQuestions.forEach(function (question1) {
                result.push(_this.makePattern(nextID(), "histogram", [question1]));
            });
            ratioQuestions.forEach(function (question1) {
                nominalQuestions.forEach(function (question2) {
                    result.push(_this.makePattern(nextID(), "multiple histogram", [question1, question2]));
                });
            });
            usedQuestions = [];
            ratioQuestions.forEach(function (question1) {
                usedQuestions.push(question1);
                ratioQuestions.forEach(function (question2) {
                    if (usedQuestions.indexOf(question2) !== -1)
                        return;
                    result.push(_this.makePattern(nextID(), "scatter", [question1, question2]));
                });
            });
            /* TODO: For later
            ratioQuestions.forEach((question1) => {
                ratioQuestions.forEach((question2) => {
                    nominalQuestions.forEach((question3) => {
                        result.push(this.makePattern(nextID(), "multiple scatter", [question1, question2, question3]});
                    });
                });
            });
            */
            result.forEach(function (pattern) {
                _this.calculateStatisticsForPattern(pattern);
            });
            // console.log("buildPatternsList", result);
            return result;
        };
        PatternExplorer.prototype.calculateStatisticsForPattern = function (pattern) {
            var graphType = pattern.graphType;
            var stories = this.graphHolder.allStories;
            var statistics = null;
            if (graphType === "bar") {
                statistics = calculateStatistics.calculateStatisticsForBarGraph(pattern.questions[0], stories, this.minimumStoryCountRequiredForTest);
            }
            else if (graphType === "table") {
                statistics = calculateStatistics.calculateStatisticsForTable(pattern.questions[0], pattern.questions[1], stories, this.minimumStoryCountRequiredForTest);
            }
            else if (graphType === "histogram") {
                statistics = calculateStatistics.calculateStatisticsForHistogram(pattern.questions[0], stories, this.minimumStoryCountRequiredForTest);
            }
            else if (graphType === "multiple histogram") {
                statistics = calculateStatistics.calculateStatisticsForMultipleHistogram(pattern.questions[0], pattern.questions[1], stories, this.minimumStoryCountRequiredForTest);
            }
            else if (graphType === "scatter") {
                statistics = calculateStatistics.calculateStatisticsForScatterPlot(pattern.questions[0], pattern.questions[1], stories, this.minimumStoryCountRequiredForTest);
            }
            else if (graphType === "multiple scatter") {
                console.log("ERROR: Not suported graphType: " + graphType);
                throw new Error("ERROR: Not suported graphType: " + graphType);
            }
            else {
                console.log("ERROR: Unexpected graphType: " + graphType);
                throw new Error("ERROR: Not suported graphType: " + graphType);
            }
            if (statistics) {
                pattern.significance = statistics.significance;
            }
            else {
                pattern.significance = "ERROR";
            }
        };
        PatternExplorer.prototype.chooseGraph = function (pattern) {
            // console.log("chooseGraph", pattern);
            // Remove old graph(s)
            while (this.graphHolder.chartPanes.length) {
                var chartPane = this.graphHolder.chartPanes.pop();
                this.graphHolder.graphResultsPane.removeChild(chartPane);
            }
            // Need to remove the float end node, if any        
            while (this.graphHolder.graphResultsPane.firstChild) {
                this.graphHolder.graphResultsPane.removeChild(this.graphHolder.graphResultsPane.firstChild);
            }
            this.modelForStoryGrid.storiesSelectedInGraph = [];
            if (pattern === null) {
                return;
            }
            this.graphHolder.currentGraph = PatternExplorer.makeGraph(pattern, this.graphHolder, this.updateStoriesPane.bind(this));
            this.graphHolder.currentSelectionExtentPercentages = null;
            // TODO: Is this obsolete? this.graphHolder.currentSelectionSubgraph = null;
        };
        PatternExplorer.makeGraph = function (pattern, graphHolder, selectionCallback) {
            var graphType = pattern.graphType;
            // var name = pattern.patternName;
            // console.log("patternName", name, graphType);
            var q1 = pattern.questions[0];
            var q2 = pattern.questions[1];
            var newGraph = null;
            switch (graphType) {
                case "bar":
                    newGraph = charting.d3BarChart(graphHolder, q1, selectionCallback);
                    break;
                case "table":
                    newGraph = charting.d3ContingencyTable(graphHolder, q1, q2, selectionCallback);
                    break;
                case "histogram":
                    newGraph = charting.d3HistogramChart(graphHolder, q1, null, null, selectionCallback);
                    break;
                case "multiple histogram":
                    // Choice question needs to come before scale question in args
                    newGraph = charting.multipleHistograms(graphHolder, q2, q1, selectionCallback);
                    break;
                case "scatter":
                    newGraph = charting.d3ScatterPlot(graphHolder, q1, q2, selectionCallback);
                    break;
                default:
                    console.log("ERROR: Unexpected graph type");
                    alert("ERROR: Unexpected graph type");
                    break;
            }
            return newGraph;
        };
        PatternExplorer.prototype.updateStoriesPane = function (stories) {
            this.modelForStoryGrid.storiesSelectedInGraph = stories;
            this.storyGrid.updateData();
        };
        PatternExplorer.prototype.patternSelected = function (selectedPattern) {
            // console.log("selectedPattern in pattern grid", selectedPattern);
            this.chooseGraph(selectedPattern);
            this.currentPattern = selectedPattern;
            this.modelForStoryGrid.storiesSelectedInGraph = [];
            this.storyGrid.updateData();
        };
        PatternExplorer.prototype.insertGraphSelection = function () {
            // console.log("insertGraphSelection");
            if (!this.graphHolder.currentGraph) {
                // TODO: Translated
                alert("Please select a pattern first");
                return;
            }
            if (!this.graphHolder.currentSelectionExtentPercentages) {
                alert("Please select something in a graph first");
                return;
            }
            // console.log("PatternsBrowser currentGraph", this.graphHolder.currentGraph);
            if (this.scanForSelectionJSON()) {
                // TODO: Translate
                alert("The insertion would change a previously saved selection within a {...} section;\nplease pick a different insertion point.");
                return;
            }
            if (!this.currentPattern)
                return;
            // Find observation textarea and other needed data
            var textarea = document.getElementById("observationPanel_description");
            var selection = this.graphHolder.currentSelectionExtentPercentages;
            var textToInsert = JSON.stringify(selection);
            // Replace the currently selected text in the textarea (or insert at caret if nothing selected)
            var selectionStart = textarea.selectionStart;
            var selectionEnd = textarea.selectionEnd;
            var oldText = this.currentObservationDescription();
            var newText = oldText.substring(0, selectionStart) + textToInsert + oldText.substring(selectionEnd);
            this.currentObservationDescription(newText);
            // Set the new value explicitly here rather than waiting for a Mithril redraw so that we can then select it
            textarea.value = newText;
            textarea.selectionStart = selectionStart;
            textarea.selectionEnd = selectionStart + textToInsert.length;
            textarea.focus();
        };
        PatternExplorer.prototype.scanForSelectionJSON = function (doFocus) {
            if (doFocus === void 0) { doFocus = false; }
            // console.log("scanForSelectionJSON");
            // TODO: Fix this for Mithril conversion
            var textarea = document.getElementById("observationPanel_description");
            if (!this.currentPattern)
                return;
            var text = this.currentObservationDescription();
            if (doFocus)
                textarea.focus();
            var selectionStart = textarea.selectionStart;
            var selectionEnd = textarea.selectionEnd;
            // Find the text for a selection surrounding the current insertion point
            // This assumes there are not nested objects with nested braces
            var start;
            var end;
            // Special case of entire selection -- but could return more complex nested object...
            if (selectionStart !== selectionEnd) {
                if (text.charAt(selectionStart) === "{" && text.charAt(selectionEnd - 1) === "}") {
                    return text.substring(selectionStart, selectionEnd);
                }
            }
            for (start = selectionStart - 1; start >= 0; start--) {
                if (text.charAt(start) === "}")
                    return null;
                if (text.charAt(start) === "{")
                    break;
            }
            if (start < 0)
                return null;
            // Now find the end
            for (end = start; end < text.length; end++) {
                if (text.charAt(end) === "}")
                    break;
            }
            if (end >= text.length)
                return null;
            return text.substring(start, end + 1);
        };
        PatternExplorer.prototype.resetGraphSelection = function () {
            // console.log("resetGraphSelection");
            if (!this.graphHolder.currentGraph) {
                // TODO: Translate
                alert("Please select a pattern first");
                return;
            }
            // TODO: Need better approach to finding brush extent text and safely parsing it
            // Find observation textarea and other needed data
            // var selectedText = oldText.substring(selectionStart, selectionEnd);
            var selectedText = this.scanForSelectionJSON(true);
            if (!selectedText) {
                // TODO: Translate
                alert("The text insertion point was not inside a graph selection description.\nTry clicking inside the {...} items first.");
                return;
            }
            var selection = null;
            try {
                selection = JSON.parse(selectedText);
            }
            catch (e) {
                console.log("JSON parse error", e);
            }
            if (!selection) {
                // TODO: Translate
                alert('The selected text was not a complete valid stored selection.\nTry clicking inside the {...} items first.');
                return;
            }
            // console.log("selection from user", selection);
            var graph = this.graphHolder.currentGraph;
            if (_.isArray(graph)) {
                var optionText = selection.subgraphChoice;
                if (!optionText) {
                    // TODO: Translate
                    alert("No subgraphChoice specified in stored selection");
                    return;
                }
                optionText = decodeBraces(optionText);
                var graphs = this.graphHolder.currentGraph;
                graphs.forEach(function (subgraph) {
                    if (subgraph.subgraphChoice === optionText) {
                        graph = subgraph;
                    }
                });
            }
            charting.restoreSelection(graph, selection);
        };
        return PatternExplorer;
    })();
    return PatternExplorer;
});

define('js/applicationWidgets/ClusteringDiagram',["require", "exports", "d3", "../pointrel20150417/generateRandomUuid", "../panelBuilder/dialogSupport", "mithril"], function (require, exports, d3, generateRandomUuid, dialogSupport, m) {
    "use strict";
    // TODO: Maybe add tooltip with notes for item? And then don't display item info at bottom?
    // TODO: Select and move groups of items
    // TODO: Make a systemic communications fix to PointrelClient so can stop using Math.round to ensure x and y are integers to avoid JSON conversion errors and sha256 error in WordPress plugin due to PHP and numeric precision (2015-10-08)
    var defaultSurfaceWidthInPixels = 800;
    var defaultSurfaceHeightInPixels = 500;
    // Caution: "this" may be undefined for functions called by this unless "bind" or "hitch" is used
    function forEach(theArray, theFunction) {
        if (!theArray) {
            console.log("theArray is invalid", theArray);
        }
        for (var index = 0, length = theArray.length; index < length; ++index) {
            theFunction(index, theArray[index], theArray);
        }
    }
    function removeItemFromArray(item, anArray) {
        var index = anArray.indexOf(item);
        if (index > -1) {
            anArray.splice(index, 1);
            return item;
        }
        return null;
    }
    // TODO: Unfortunate mix of canvas into an SVG app
    // Only straightforward way (without Dojo gfx) to get the text width, given the page may be hidden while making this, which causes text width to return 0 for SVG
    // Could not get other approaches of adding measuring div to dom to work, perhaps because top level body CSS styling
    // From: http://stackoverflow.com/questions/118241/calculate-text-width-with-javascript
    var measuringCanvas;
    function getTextWidth(text, textStyle) {
        // re-use canvas object for better performance
        var canvas = measuringCanvas || (measuringCanvas = document.createElement("canvas"));
        var context = canvas.getContext("2d");
        context.font = "normal normal " + textStyle.weight + " " + textStyle.size + " " + textStyle.family;
        var metrics = context.measureText(text);
        var result = metrics.width;
        // console.log("getTextWidth", text, result);
        return result;
    }
    function myWrap(text, itemText, textStyle, maxWidth) {
        // console.log("myWrap", itemText, textStyle, maxWidth);
        var lineHeight_em = 1.1;
        var words = itemText.split(/\s+/);
        var lines = [];
        var line = "";
        forEach(words, function (index, word) {
            if (lines.length >= 5) {
                line = "...";
                return;
            }
            if (line === "") {
                line = word;
            }
            else if (getTextWidth(line + " " + word, textStyle) < maxWidth) {
                // console.log("word fits", word);
                line += " " + word;
            }
            else {
                // console.log("word does not fit", word, "|", line);
                lines.push(line);
                line = word;
            }
        });
        if (line !== "")
            lines.push(line);
        // var startY = -((lines.length - 1) / 2) * lineHeight;
        var lineNumber = (Math.round(-lines.length / 2 + 0.5));
        // if (lines.length === 6) startY += lineHeight;
        forEach(lines, function (index, line) {
            var tspan = text.append("tspan")
                .attr("x", 0)
                .attr("y", 0)
                .attr("dy", (lineNumber++) * lineHeight_em + "em")
                .text(line)
                .style("fill", "black");
            // console.log("tspan", tspan);
        });
    }
    /** ClusteringDiagram-specific functions here */
    var ClusteringDiagram = (function () {
        function ClusteringDiagram(storageFunction, autosave) {
            // console.log("Creating ClusteringDiagram");
            this.model = null;
            this.mainButtons = [];
            this.autosave = false;
            this.lastSelectedItem = null;
            this.divForResizing = null;
            this._mainSurface = null;
            this.mainSurface = null;
            this.itemToDisplayObjectMap = {};
            this.d3DivForResizing = null;
            this.background = null;
            this.showEntryDialog = false;
            this.itemBeingEdited = null;
            this.itemBeingEditedCopy = null;
            this.isEditedItemNew = false;
            this.storageFunction = storageFunction;
            this.autosave = autosave;
            this.model = storageFunction();
            if (!this.model) {
                this.model = ClusteringDiagram.newDiagramModel();
            }
            // console.log("diagram", JSON.stringify(this.diagram, null, 2));
            this.setupMainButtons();
            this.setupMainSurface();
        }
        // This is static so other code can create and store diagram contents directly as source
        ClusteringDiagram.newDiagramModel = function () {
            return {
                surfaceWidthInPixels: defaultSurfaceWidthInPixels,
                surfaceHeightInPixels: defaultSurfaceHeightInPixels,
                items: [],
                changesCount: 0
            };
        };
        ClusteringDiagram.newItem = function (itemType, name, notes, x, y) {
            if (itemType === void 0) { itemType = "item"; }
            if (name === void 0) { name = ""; }
            if (notes === void 0) { notes = ""; }
            if (x === void 0) { x = ClusteringDiagram.initialDisplacement; }
            if (y === void 0) { y = ClusteringDiagram.initialDisplacement; }
            // if (name === null) name = "Untitled " + itemType + " #" + (++this.itemsMade);
            var item = {
                uuid: generateRandomUuid("ClusteringDiagramItem"),
                "type": itemType,
                name: name,
                notes: notes,
                x: Math.round(x),
                y: Math.round(y)
            };
            // item.bodyColor = defaultBodyColor;
            // item.borderWidth = defaultBorderWidth;
            // item.borderColor = defaultBorderColor;
            // item.radius = defaultRadius;
            // item.textStyle = defaultTextStyle;
            return item;
        };
        ClusteringDiagram.bumpXYOfItem = function (item) {
            ClusteringDiagram.bumpedItemCount++;
            item.x = Math.round(item.x + (ClusteringDiagram.bumpedItemCount * ClusteringDiagram.bumpXShiftPerItem) % ClusteringDiagram.bumpXRange);
            item.y = Math.round(item.y + (ClusteringDiagram.bumpedItemCount / 10 * ClusteringDiagram.bumpYShiftPerItem) % ClusteringDiagram.bumpYRange);
        };
        ClusteringDiagram.addNewItemToDiagram = function (diagram, itemType, name, notes) {
            if (notes === void 0) { notes = ""; }
            var item = ClusteringDiagram.newItem(itemType, name, notes);
            ClusteringDiagram.bumpXYOfItem(item);
            diagram.items.push(item);
            diagram.changesCount++;
            return item;
        };
        ClusteringDiagram.controller = function (args) {
            // console.log("Making ClusteringDiagram: ", args);
            return new ClusteringDiagram(args.storageFunction, args.autosave);
        };
        ClusteringDiagram.view = function (controller, args) {
            // console.log("ClusteringDiagram view called");
            return controller.calculateView(args);
        };
        ClusteringDiagram.prototype.calculateView = function (args) {
            // Make sure the mdoel is up-to-date
            // this seems wasteful but there is no toehr way to be sure jave the letstest ada
            this.updateDiagram(this.storageFunction());
            var entryDialog = [];
            if (this.showEntryDialog) {
                entryDialog.push(this.buildEntryDialog());
            }
            var textForItemName = "";
            var textForItemNotes = "";
            if (this.lastSelectedItem) {
                // TODO: Translate labels
                textForItemName = "Name: " + (this.lastSelectedItem.name || "");
                textForItemNotes = "Notes: " + (this.lastSelectedItem.notes || "");
            }
            return m("div", [
                this.mainButtons,
                m("div", { config: this.configSurface.bind(this) }),
                // m("div", {style: "text-overflow: ellipsis;"}, textForItemName),
                // m("div", {style: "text-overflow: ellipsis;"}, textForItemUrl),
                entryDialog
            ]);
        };
        ClusteringDiagram.prototype.configSurface = function (element, isInitialized, context) {
            // console.log("configSurface called");
            if (!isInitialized) {
                element.appendChild(this.divForResizing);
            }
        };
        ClusteringDiagram.prototype.incrementChangesCount = function () {
            // console.log("incrementChangesCount", new Error());
            this.model.changesCount++;
            if (this.autosave) {
                // console.log("Saving changes");
                this.saveChanges();
            }
        };
        ClusteringDiagram.prototype.setupMainSurface = function () {
            var _this = this;
            var divForResizing = document.createElement("div");
            this.divForResizing = divForResizing;
            var divUUID = generateRandomUuid("ResizeableCanvasHolder");
            divForResizing.setAttribute("id", divUUID);
            //divForResizing.setAttribute("style", "width: " + this.diagram.surfaceWidthInPixels + "px; height: " + this.diagram.surfaceHeightInPixels + "px; border: solid 1px; position: relative");
            //divForResizing.setAttribute("style", "resize: auto; border: solid 1px");
            var width = this.model.surfaceWidthInPixels;
            var height = this.model.surfaceHeightInPixels;
            this.d3DivForResizing = d3.select(divForResizing);
            this._mainSurface = this.d3DivForResizing.append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('class', 'clustering');
            // this._mainSurface.append("circle").attr("cx", 25).attr("cy", 25).attr("r", 25).style("fill", "purple").on("mousedown", function () {console.log("purple circle clicked");});
            this.background = this._mainSurface.append("rect")
                .attr('width', "100%")
                .attr('height', "100%")
                .attr('class', 'clusteringDiagramBackground')
                .style('fill', 'white')
                .style('stroke-width', '3')
                .style('stroke', '#a7a5a5')
                .on("mousedown", function () {
                // console.log("mousedown in background");
                _this.selectItem(null);
                // console.log("mousedown item", item);
            });
            this.mainSurface = this._mainSurface.append('g')
                .attr('class', 'mainSurface');
            // console.log("setup main surface", this);
            this.recreateDisplayObjectsForAllItems();
            /* TODO: What to do about handle?
            var handle = new ResizeHandle({
                targetId: divUUID,
                // Need either activeResize true or animateSizing false so that onResize will only be called when totally done resizing
                // and not with animation still running and node not quite the final size
                // Updating seems to look worse with activeResize true as canvas still draws old size while rectangle shrinks or grows
                // activeResize: true,
                animateSizing: false,
                // style: "bottom: 4px; right: 4px;",
                onResize: this.updateSizeOfCanvasFromResizeHandle.bind(this)
            }).placeAt(divForResizing);
            // Need to call startup as made div and added it outside of existing connected ContentPane
            handle.startup();
            */
        };
        ClusteringDiagram.prototype.updateSizeOfCanvasFromResizeHandle = function () {
            var newWidth = this.divForResizing.clientWidth;
            var newHeight = this.divForResizing.clientHeight;
            // console.log("resize from ResizeHandle drag", newWidth, newHeight);
            this._mainSurface.attr("width", newWidth).attr("height", newHeight);
            this.background.attr('width', newWidth).attr('height', newHeight);
            this.model.surfaceWidthInPixels = newWidth;
            this.model.surfaceHeightInPixels = newHeight;
            this.incrementChangesCount();
        };
        ClusteringDiagram.prototype.updateSizeOfCanvasFromModel = function () {
            var newWidth = this.model.surfaceWidthInPixels;
            var newHeight = this.model.surfaceHeightInPixels;
            // console.log("resize from model change", newWidth, newHeight);
            this.divForResizing.setAttribute("style", "width: " + this.model.surfaceWidthInPixels + "px; height: " + this.model.surfaceHeightInPixels + "px; border: solid 1px; position: relative");
            this._mainSurface.attr("width", newWidth).attr("height", newHeight);
            this.background.attr('width', newWidth).attr('height', newHeight);
        };
        ClusteringDiagram.prototype.newButton = function (name, label, callback) {
            var button = m("button", { onclick: callback, "class": name }, label);
            this.mainButtons.push(button);
            return button;
        };
        ClusteringDiagram.prototype.setupMainButtons = function () {
            var _this = this;
            var mainButtons = [];
            // TODO: Translate
            this.newButton("newItemButton", "New item", function () {
                var aNewItem = _this.newItem("item");
                _this.openEntryDialog(aNewItem, false);
            });
            this.newButton("newClusterButton", "New cluster", function () {
                var aNewItem = _this.newItem("cluster");
                _this.openEntryDialog(aNewItem, false);
            });
            // TODO: Translate
            this.newButton("editItemButton", "Edit", function () {
                if (_this.lastSelectedItem) {
                    _this.openEntryDialog(_this.lastSelectedItem, true);
                }
                else {
                    // TODO: Translate
                    alert("Please select an item to update first");
                }
            });
            // TODO: Translate
            this.newButton("deleteButton", "Delete", function () {
                if (!_this.lastSelectedItem) {
                    // TODO: Translate
                    alert("Please select an item to delete first.");
                    return;
                }
                dialogSupport.confirm("Are you sure you want to delete the item or cluster called '" + _this.lastSelectedItem.name + "'?", function () {
                    _this.updateDisplayForChangedItem(_this.lastSelectedItem, "delete");
                    removeItemFromArray(_this.lastSelectedItem, _this.model.items);
                    _this.clearSelection();
                    _this.incrementChangesCount();
                });
            });
            // TODO: Translate
            this.newButton("canvasSizeButton", "Diagram size", function () {
                _this.openCanvasSizeDialog();
            });
            if (!this.autosave) {
                // TODO: Translate
                this.newButton("saveChangesButton", "Save Changes", function () {
                    // console.log("About to save");
                    _this.saveChanges();
                });
            }
            // TODO: Translate
            this.newButton("sourceButton", "Diagram Source", function () {
                _this.openSourceDialog(JSON.stringify(_this.model, null, 2));
            });
        };
        // typeOfChange should be either "delete" or "update"
        ClusteringDiagram.prototype.updateDisplayForChangedItem = function (item, typeOfChange) {
            if (item === null) {
                console.log("updateDisplayForChangedItem item is null", typeOfChange);
                return;
            }
            var displayObject = this.itemToDisplayObjectMap[item.uuid];
            if (typeOfChange === "delete") {
                delete this.itemToDisplayObjectMap[item.uuid];
                displayObject.remove();
                return;
            }
            displayObject.remove();
            var newDisplayObject = this.addDisplayObjectForItem(this.mainSurface, item);
            this.itemToDisplayObjectMap[item.uuid] = newDisplayObject;
        };
        ClusteringDiagram.prototype.openCanvasSizeDialog = function () {
            // console.log("openCanvasSizeDialog");  
            // alert("This should open a dialog");
            // TODO: Make a single dialog
            // TODO: Translate
            var newWidthString = prompt("How wide (in pixels) would you like this clustering diagram to be?", "" + this.model.surfaceWidthInPixels);
            if (!newWidthString)
                return;
            var newWidth = parseInt(newWidthString.trim(), 10);
            if (!newWidth)
                return;
            var newHeightString = prompt("How high (in pixels) would you like this clustering diagram to be?", "" + this.model.surfaceHeightInPixels);
            if (!newHeightString)
                return;
            var newHeight = parseInt(newHeightString.trim(), 10);
            if (!newHeight)
                return;
            if (newWidth !== this.model.surfaceWidthInPixels || newHeight !== this.model.surfaceHeightInPixels) {
                this.model.surfaceWidthInPixels = newWidth;
                this.model.surfaceHeightInPixels = newHeight;
                this._mainSurface
                    .attr('width', newWidth)
                    .attr('height', newHeight);
                this.incrementChangesCount();
            }
        };
        ClusteringDiagram.prototype.openEntryDialog = function (item, isExistingItem) {
            // console.log("openEntryDialog", item, isExistingItem);
            this.itemBeingEdited = item;
            this.itemBeingEditedCopy = JSON.parse(JSON.stringify(item));
            this.isEditedItemNew = !isExistingItem;
            // alert("This should open a dialog");
            this.showEntryDialog = true;
        };
        ClusteringDiagram.prototype.acceptChangesForItemBeingEdited = function () {
            this.showEntryDialog = false;
            // console.log("ok", this.itemBeingEditedCopy);
            this.itemBeingEdited.name = this.itemBeingEditedCopy.name;
            // Ensure the item has a name
            // TODO: This allows duplicate names if items have been deleted
            if (!this.itemBeingEdited.name) {
                this.itemBeingEdited.name = "Untitled " + this.itemBeingEdited.type + " #" + (this.model.items.length + 1);
            }
            this.itemBeingEdited.notes = this.itemBeingEditedCopy.notes;
            if (this.isEditedItemNew) {
                // console.log("not existing item");
                this.model.items.push(this.itemBeingEdited);
                this.addDisplayObjectForItem(this.mainSurface, this.itemBeingEdited);
            }
            else {
                this.updateDisplayForChangedItem(this.itemBeingEdited, "update");
            }
            // console.log("items", this.diagram.items);
            this.incrementChangesCount();
            this.selectItem(this.itemBeingEdited);
        };
        ClusteringDiagram.prototype.buildEntryDialog = function () {
            /*
            return m("div", [
                "Entry dialog 2",
                m("br"),
                m("button", {onclick: () => { this.showEntryDialog = false; }}, "Close")
            ]);
            */
            var _this = this;
            return m("div.overlay", m("div.modal-content", [
                "Edit " + this.itemBeingEditedCopy.type,
                m("br"),
                m("br"),
                m('label', { "for": "itemDialog_name" }, "Name:"),
                m('input[type=text]', {
                    id: "itemDialog_name",
                    value: this.itemBeingEditedCopy.name || "",
                    onchange: function (event) { _this.itemBeingEditedCopy.name = event.target.value; }
                }),
                m('br'),
                m('br'),
                m('label', { "for": "itemDialog_notes" }, "Notes:"),
                m('textarea[class=narrafirma-textbox]', {
                    id: "itemDialog_notes",
                    value: this.itemBeingEditedCopy.notes || "",
                    onchange: function (event) { _this.itemBeingEditedCopy.notes = event.target.value; }
                }),
                m("br"),
                m("button", {
                    onclick: function () {
                        _this.showEntryDialog = false;
                        // console.log("cancel", this.itemBeingEditedCopy);
                    }
                }, "Cancel"),
                m("button", {
                    onclick: function () {
                        _this.acceptChangesForItemBeingEdited();
                    }
                }, "OK")
            ]));
        };
        ClusteringDiagram.prototype.updateSourceClicked = function (text, hideDialogMethod) {
            // console.log("updateSourceClicked", text);
            var newDiagram;
            try {
                newDiagram = JSON.parse(text);
            }
            catch (e) {
                alert("Problem parsing source\n" + e);
                return;
            }
            hideDialogMethod();
            // console.log("parsed diagram", newDiagram);
            this.updateDiagram(newDiagram);
            this.incrementChangesCount();
        };
        ClusteringDiagram.prototype.updateDiagram = function (newDiagram) {
            // console.log("updateDiagram", this.diagram, newDiagram);
            if (!newDiagram)
                return;
            if (this.model.changesCount === newDiagram.changesCount) {
                // console.log("Changes count match at", newDiagram.changesCount);
                // Optimize out reflections of our changes back to us if the diagrams are the same
                // Extra cautious to compare JSON; otherwise probably could just return
                if (JSON.stringify(this.model) === JSON.stringify(newDiagram)) {
                    // console.log("updateDiagram: new diagram seems identical to the old; not updating");
                    return;
                }
            } // else {
            // console.log("updateDiagram: changes counts do not match", this.diagram.changesCount, newDiagram.changesCount);
            // }
            this.model = newDiagram;
            this.recreateDisplayObjectsForAllItems();
            // console.log("updateDiagram: Updated OK");
            this.clearSelection();
            this.updateSizeOfCanvasFromModel();
        };
        ClusteringDiagram.prototype.clearSelection = function () {
            this.selectItem(null);
        };
        ClusteringDiagram.prototype.openSourceDialog = function (text) {
            dialogSupport.openTextEditorDialog(text, "#clusterDiagramSource_titleID|Clustering Diagram", "#clusterDiagramSource_okButtonID|OK", this.updateSourceClicked.bind(this));
        };
        ClusteringDiagram.prototype.recreateDisplayObjectsForAllItems = function () {
            // console.log("recreateDisplayObjectsForAllItems");
            this.itemToDisplayObjectMap = {};
            this.mainSurface.selectAll("*").remove();
            // console.log("before forEach this:", this);
            var thisObject = this;
            forEach(this.model.items, function (index, item) {
                // console.log("looping over: ", item, "this:", this);
                var displayObject = thisObject.addDisplayObjectForItem(thisObject.mainSurface, item);
            });
            // console.log("done recreateDisplayObjectsForAllItems");
        };
        ClusteringDiagram.prototype.saveChanges = function () {
            this.storageFunction(this.model);
        };
        ClusteringDiagram.prototype.newItem = function (itemType, name, notes) {
            if (itemType === void 0) { itemType = "item"; }
            if (name === void 0) { name = ""; }
            if (notes === void 0) { notes = ""; }
            var newItem = ClusteringDiagram.newItem(itemType, name, notes);
            ClusteringDiagram.bumpXYOfItem(newItem);
            return newItem;
        };
        // TODO: Clean up duplication here and elsewhere with calculating border color and width
        ClusteringDiagram.prototype.selectItem = function (item) {
            // console.log("selectItem", item);
            if (item === this.lastSelectedItem) {
                // console.log("lastSelectedItem and new selected item are the same; not updating");
                return;
            }
            if (this.lastSelectedItem) {
                // console.log("lastSelected", this.lastSelectedItem);
                var lastSelectedDisplayObject = this.itemToDisplayObjectMap[this.lastSelectedItem.uuid];
                if (lastSelectedDisplayObject) {
                    lastSelectedDisplayObject.circle
                        .style("stroke-width", lastSelectedDisplayObject.borderWidth);
                }
            }
            if (item) {
                var displayObject = this.itemToDisplayObjectMap[item.uuid];
                displayObject.circle
                    .style("stroke-width", displayObject.borderWidth * 5);
            }
            this.lastSelectedItem = item;
            // Queue redrawing as this was selected via D3 not Mithril
            m.redraw();
        };
        ClusteringDiagram.prototype.addDisplayObjectForItem = function (surface, item) {
            // console.log("addDisplayObjectForItem item", item);
            var _this = this;
            var bodyColor = item.bodyColor;
            if (!bodyColor)
                bodyColor = ClusteringDiagram.defaultBodyColor;
            var borderColor = item.borderColor;
            if (!borderColor)
                borderColor = ClusteringDiagram.defaultBorderColor;
            var borderWidth = item.borderWidth;
            if (!borderWidth)
                borderWidth = ClusteringDiagram.defaultBorderWidth;
            // if (item.type === "cluster") borderWidth = borderWidth * 2;
            var radius = item.radius;
            if (!radius)
                radius = ClusteringDiagram.defaultRadius;
            var textStyle = item.textStyle;
            if (!textStyle)
                textStyle = ClusteringDiagram.defaultTextStyle;
            var group;
            if (item.type === "cluster") {
                group = surface.insert('g', ':first-child')
                    .attr('transform', 'translate(' + item.x + ',' + item.y + ')')
                    .attr('class', 'item');
            }
            else {
                group = surface.append('g')
                    .attr('transform', 'translate(' + item.x + ',' + item.y + ')')
                    .attr('class', 'item');
            }
            // TODO: Does this work with SVG elements? Are they really D3 selections? Or maybe could also map data to element with D3?
            group.item = item;
            // console.log("group etc.", group, item, bodyColor, borderColor, borderWidth, radius, textStyle);
            if (item.type === "cluster") {
                var clusterRectangleOuter = group.append("circle")
                    .attr("r", radius * 3)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .style("fill", bodyColor) // d3.rgb(bodyColor).brighter())
                    .style("opacity", 0.25)
                    .style("stroke", d3.rgb(borderColor))
                    .style("stroke-width", borderWidth * 2);
                /*
                var clusterRectangleInner = group.append("circle")
                    .attr("r", radius)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .style("fill", d3.rgb(bodyColor))
                    // Make translucent
                    .style("opacity", 0.75)
                    .style("stroke", d3.rgb(borderColor))
                    .style("stroke-width", borderWidth);
                */
                group.circle = clusterRectangleOuter;
            }
            else {
                var itemCircle = group.append("circle")
                    .attr("r", radius)
                    .attr("cx", 0)
                    .attr("cy", 0)
                    .style("fill", d3.rgb(bodyColor))
                    .style("opacity", 0.5)
                    .style("stroke", d3.rgb(borderColor))
                    .style("stroke-width", borderWidth);
                group.circle = itemCircle;
            }
            var hoverText = item.name;
            if (item.notes)
                hoverText += "\n----------\n" + item.notes;
            group.append("title")
                .text(hoverText);
            group.borderColor = borderColor;
            group.borderWidth = borderWidth;
            this.addText(group, item.name, radius * 1.5, textStyle);
            // console.log("group", group);
            // console.log("itemCircle", itemCircle);
            group.on("mousedown", function () {
                // console.log("mousedown item", item);
                _this.selectItem(item);
            });
            var self = this;
            var drag = d3.behavior.drag();
            // drag.origin({x: item.x, y: item.y});
            var moved = false;
            drag.on("dragstart", function () {
                // console.log("dragstart item", item);
                self.selectItem(item);
                moved = false;
            });
            drag.on("drag", function () {
                // console.log("drag item", item);
                // TODO: Casting to any as workaround to silence TypeScritp error for maybe incomplete d3 typing file
                item.x = Math.round(item.x + d3.event.dx);
                item.y = Math.round(item.y + d3.event.dy);
                group.attr('transform', 'translate(' + item.x + ',' + item.y + ')');
                moved = true;
            });
            drag.on("dragend", function () {
                if (moved)
                    self.incrementChangesCount();
            });
            group.call(drag);
            /*
            group.on("dblclick", (e) => {
                // alert("triggered ondblclick");
                this.go(group.item.url);
            });
            */
            this.itemToDisplayObjectMap[item.uuid] = group;
            return group;
        };
        ClusteringDiagram.prototype.addText = function (group, itemText, maxWidth, textStyle) {
            if (itemText === undefined)
                itemText = "[missing text]";
            var text = group.append("text")
                .style("font-family", textStyle.family)
                .style("font-size", textStyle.size)
                .style("font-weight", textStyle.weight)
                .style("text-anchor", "middle");
            myWrap(text, itemText, textStyle, maxWidth);
            // wrap(text, maxWidth, textStyle);
        };
        ClusteringDiagram.calculateClusteringForDiagram = function (clusteringDiagram) {
            var result = [];
            if (!clusteringDiagram)
                return result;
            var clusters = clusteringDiagram.items.filter(function (item) {
                return item.type === "cluster";
            });
            // console.log("clusters", clusters);
            var items = clusteringDiagram.items.filter(function (item) {
                return item.type === "item";
            });
            // console.log("items", items);
            items.forEach(function (item) {
                item.clusterDistance = Number.MAX_VALUE;
                item.cluster = null;
                clusters.forEach(function (cluster) {
                    var dx = item.x - cluster.x;
                    var dy = item.y - cluster.y;
                    var distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < item.clusterDistance) {
                        item.clusterDistance = distance;
                        item.cluster = cluster;
                    }
                });
            });
            clusters.forEach(function (cluster) {
                cluster.items = [];
                items.forEach(function (item) {
                    if (item.cluster === cluster)
                        cluster.items.push(item);
                });
            });
            clusteringDiagram.clusters = clusters;
        };
        ClusteringDiagram.defaultBodyColor = "#abb6ce"; // light blue
        // var defaultBodyColor = [0, 0, 155, 0.5]; // light blue, transparent
        ClusteringDiagram.defaultBorderColor = "#2e4a85";
        // var defaultBorderColor = "green";
        ClusteringDiagram.defaultBorderWidth = 1;
        // var defaultHasNoteBorderColor = "green";
        // var defaultTextStyle = {family: "Arial", size: "10pt", weight: "bold"};
        ClusteringDiagram.defaultTextStyle = { family: "Arial", size: "9pt", weight: "normal" };
        ClusteringDiagram.defaultRadius = 44;
        ClusteringDiagram.bumpedItemCount = 0;
        ClusteringDiagram.bumpXShiftPerItem = 50;
        ClusteringDiagram.bumpYShiftPerItem = 50;
        ClusteringDiagram.initialDisplacement = 100;
        ClusteringDiagram.bumpXRange = 400;
        ClusteringDiagram.bumpYRange = 400;
        return ClusteringDiagram;
    })();
    return ClusteringDiagram;
});

/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
 
(function ( global ) {
 
	function RGBColor(color_string)
	{
		this.ok = false;

		// strip any leading #
		if (color_string.charAt(0) == '#') { // remove # if any
			color_string = color_string.substr(1,6);
		}

		color_string = color_string.replace(/ /g,'');
		color_string = color_string.toLowerCase();

		// before getting into regexps, try simple matches
		// and overwrite the input
		var simple_colors = {
			aliceblue: 'f0f8ff',
			antiquewhite: 'faebd7',
			aqua: '00ffff',
			aquamarine: '7fffd4',
			azure: 'f0ffff',
			beige: 'f5f5dc',
			bisque: 'ffe4c4',
			black: '000000',
			blanchedalmond: 'ffebcd',
			blue: '0000ff',
			blueviolet: '8a2be2',
			brown: 'a52a2a',
			burlywood: 'deb887',
			cadetblue: '5f9ea0',
			chartreuse: '7fff00',
			chocolate: 'd2691e',
			coral: 'ff7f50',
			cornflowerblue: '6495ed',
			cornsilk: 'fff8dc',
			crimson: 'dc143c',
			cyan: '00ffff',
			darkblue: '00008b',
			darkcyan: '008b8b',
			darkgoldenrod: 'b8860b',
			darkgray: 'a9a9a9',
			darkgreen: '006400',
			darkkhaki: 'bdb76b',
			darkmagenta: '8b008b',
			darkolivegreen: '556b2f',
			darkorange: 'ff8c00',
			darkorchid: '9932cc',
			darkred: '8b0000',
			darksalmon: 'e9967a',
			darkseagreen: '8fbc8f',
			darkslateblue: '483d8b',
			darkslategray: '2f4f4f',
			darkturquoise: '00ced1',
			darkviolet: '9400d3',
			deeppink: 'ff1493',
			deepskyblue: '00bfff',
			dimgray: '696969',
			dodgerblue: '1e90ff',
			feldspar: 'd19275',
			firebrick: 'b22222',
			floralwhite: 'fffaf0',
			forestgreen: '228b22',
			fuchsia: 'ff00ff',
			gainsboro: 'dcdcdc',
			ghostwhite: 'f8f8ff',
			gold: 'ffd700',
			goldenrod: 'daa520',
			gray: '808080',
			green: '008000',
			greenyellow: 'adff2f',
			honeydew: 'f0fff0',
			hotpink: 'ff69b4',
			indianred : 'cd5c5c',
			indigo : '4b0082',
			ivory: 'fffff0',
			khaki: 'f0e68c',
			lavender: 'e6e6fa',
			lavenderblush: 'fff0f5',
			lawngreen: '7cfc00',
			lemonchiffon: 'fffacd',
			lightblue: 'add8e6',
			lightcoral: 'f08080',
			lightcyan: 'e0ffff',
			lightgoldenrodyellow: 'fafad2',
			lightgrey: 'd3d3d3',
			lightgreen: '90ee90',
			lightpink: 'ffb6c1',
			lightsalmon: 'ffa07a',
			lightseagreen: '20b2aa',
			lightskyblue: '87cefa',
			lightslateblue: '8470ff',
			lightslategray: '778899',
			lightsteelblue: 'b0c4de',
			lightyellow: 'ffffe0',
			lime: '00ff00',
			limegreen: '32cd32',
			linen: 'faf0e6',
			magenta: 'ff00ff',
			maroon: '800000',
			mediumaquamarine: '66cdaa',
			mediumblue: '0000cd',
			mediumorchid: 'ba55d3',
			mediumpurple: '9370d8',
			mediumseagreen: '3cb371',
			mediumslateblue: '7b68ee',
			mediumspringgreen: '00fa9a',
			mediumturquoise: '48d1cc',
			mediumvioletred: 'c71585',
			midnightblue: '191970',
			mintcream: 'f5fffa',
			mistyrose: 'ffe4e1',
			moccasin: 'ffe4b5',
			navajowhite: 'ffdead',
			navy: '000080',
			oldlace: 'fdf5e6',
			olive: '808000',
			olivedrab: '6b8e23',
			orange: 'ffa500',
			orangered: 'ff4500',
			orchid: 'da70d6',
			palegoldenrod: 'eee8aa',
			palegreen: '98fb98',
			paleturquoise: 'afeeee',
			palevioletred: 'd87093',
			papayawhip: 'ffefd5',
			peachpuff: 'ffdab9',
			peru: 'cd853f',
			pink: 'ffc0cb',
			plum: 'dda0dd',
			powderblue: 'b0e0e6',
			purple: '800080',
			red: 'ff0000',
			rosybrown: 'bc8f8f',
			royalblue: '4169e1',
			saddlebrown: '8b4513',
			salmon: 'fa8072',
			sandybrown: 'f4a460',
			seagreen: '2e8b57',
			seashell: 'fff5ee',
			sienna: 'a0522d',
			silver: 'c0c0c0',
			skyblue: '87ceeb',
			slateblue: '6a5acd',
			slategray: '708090',
			snow: 'fffafa',
			springgreen: '00ff7f',
			steelblue: '4682b4',
			tan: 'd2b48c',
			teal: '008080',
			thistle: 'd8bfd8',
			tomato: 'ff6347',
			turquoise: '40e0d0',
			violet: 'ee82ee',
			violetred: 'd02090',
			wheat: 'f5deb3',
			white: 'ffffff',
			whitesmoke: 'f5f5f5',
			yellow: 'ffff00',
			yellowgreen: '9acd32'
		};
		for (var key in simple_colors) {
			if (color_string == key) {
				color_string = simple_colors[key];
			}
		}
		// emd of simple type-in colors

		// array of color definition objects
		var color_defs = [
			{
				re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
				example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
				process: function (bits){
					return [
						parseInt(bits[1]),
						parseInt(bits[2]),
						parseInt(bits[3])
					];
				}
			},
			{
				re: /^(\w{2})(\w{2})(\w{2})$/,
				example: ['#00ff00', '336699'],
				process: function (bits){
					return [
						parseInt(bits[1], 16),
						parseInt(bits[2], 16),
						parseInt(bits[3], 16)
					];
				}
			},
			{
				re: /^(\w{1})(\w{1})(\w{1})$/,
				example: ['#fb0', 'f0f'],
				process: function (bits){
					return [
						parseInt(bits[1] + bits[1], 16),
						parseInt(bits[2] + bits[2], 16),
						parseInt(bits[3] + bits[3], 16)
					];
				}
			}
		];

		// search through the definitions to find a match
		for (var i = 0; i < color_defs.length; i++) {
			var re = color_defs[i].re;
			var processor = color_defs[i].process;
			var bits = re.exec(color_string);
			if (bits) {
				channels = processor(bits);
				this.r = channels[0];
				this.g = channels[1];
				this.b = channels[2];
				this.ok = true;
			}

		}

		// validate/cleanup values
		this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
		this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
		this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

		// some getters
		this.toRGB = function () {
			return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
		}
		this.toHex = function () {
			var r = this.r.toString(16);
			var g = this.g.toString(16);
			var b = this.b.toString(16);
			if (r.length == 1) r = '0' + r;
			if (g.length == 1) g = '0' + g;
			if (b.length == 1) b = '0' + b;
			return '#' + r + g + b;
		}

		// help
		this.getHelpXML = function () {

			var examples = new Array();
			// add regexps
			for (var i = 0; i < color_defs.length; i++) {
				var example = color_defs[i].example;
				for (var j = 0; j < example.length; j++) {
					examples[examples.length] = example[j];
				}
			}
			// add type-in colors
			for (var sc in simple_colors) {
				examples[examples.length] = sc;
			}

			var xml = document.createElement('ul');
			xml.setAttribute('id', 'rgbcolor-examples');
			for (var i = 0; i < examples.length; i++) {
				try {
					var list_item = document.createElement('li');
					var list_color = new RGBColor(examples[i]);
					var example_div = document.createElement('div');
					example_div.style.cssText =
							'margin: 3px; '
							+ 'border: 1px solid black; '
							+ 'background:' + list_color.toHex() + '; '
							+ 'color:' + list_color.toHex()
					;
					example_div.appendChild(document.createTextNode('test'));
					var list_item_value = document.createTextNode(
						' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
					);
					list_item.appendChild(example_div);
					list_item.appendChild(list_item_value);
					xml.appendChild(list_item);

				} catch(e){}
			}
			return xml;

		}

	}

    // export as AMD...
    if ( typeof define !== 'undefined' && define.amd ) {
        define( 'rgbcolor',[],function () { return RGBColor; });
    }

    // ...or as browserify
    else if ( typeof module !== 'undefined' && module.exports ) {
        module.exports = RGBColor;
    }

    global.RGBColor = RGBColor;

}( typeof window !== 'undefined' ? window : this ));
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

(function ( global ) {

	var mul_table = [
			512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
			454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
			482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
			437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
			497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
			320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
			446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
			329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
			505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
			399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
			324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
			268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
			451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
			385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
			332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
			289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
			
	   
	var shg_table = [
			 9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
			17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
			19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
			20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
			21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
			21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
			22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
			22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
			23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
			23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
			23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
			23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

	function premultiplyAlpha(imageData)
	{
		var pixels = imageData.data;
		var size = imageData.width * imageData.height * 4;
		
		for (var i=0; i<size; i+=4)
		{
			var a = pixels[i+3] / 255;
			pixels[i  ] *= a;
			pixels[i+1] *= a;
			pixels[i+2] *= a;
		}
	}

	function unpremultiplyAlpha(imageData)
	{
		var pixels = imageData.data;
		var size = imageData.width * imageData.height * 4;
		
		for (var i=0; i<size; i+=4)
		{
			var a = pixels[i+3];
			if (a != 0)
			{
				a = 255 / a;
				pixels[i  ] *= a;
				pixels[i+1] *= a;
				pixels[i+2] *= a;
			}
		}
	}

	function stackBlurImage( imageID, canvasID, radius, blurAlphaChannel )
	{
				
		var img = document.getElementById( imageID );
		var w = img.naturalWidth;
		var h = img.naturalHeight;
		   
		var canvas = document.getElementById( canvasID );
		  
		canvas.style.width  = w + "px";
		canvas.style.height = h + "px";
		canvas.width = w;
		canvas.height = h;
		
		var context = canvas.getContext("2d");
		context.clearRect( 0, 0, w, h );
		context.drawImage( img, 0, 0 );

		if ( isNaN(radius) || radius < 1 ) return;
		
		if ( blurAlphaChannel )
			stackBlurCanvasRGBA( canvasID, 0, 0, w, h, radius );
		else 
			stackBlurCanvasRGB( canvasID, 0, 0, w, h, radius );
	}


	function stackBlurCanvasRGBA( id, top_x, top_y, width, height, radius )
	{
		if ( isNaN(radius) || radius < 1 ) return;
		radius |= 0;
		
		var canvas  = document.getElementById( id );
		var context = canvas.getContext("2d");
		var imageData;
		
		try {
		  try {
			imageData = context.getImageData( top_x, top_y, width, height );
		  } catch(e) {
		  
			// NOTE: this part is supposedly only needed if you want to work with local files
			// so it might be okay to remove the whole try/catch block and just use
			// imageData = context.getImageData( top_x, top_y, width, height );
			try {
				netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
				imageData = context.getImageData( top_x, top_y, width, height );
			} catch(e) {
				alert("Cannot access local image");
				throw new Error("unable to access local image data: " + e);
				return;
			}
		  }
		} catch(e) {
		  alert("Cannot access image");
		  throw new Error("unable to access image data: " + e);
		}
		
		premultiplyAlpha(imageData);
		
		var pixels = imageData.data;
				
		var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
		r_out_sum, g_out_sum, b_out_sum, a_out_sum,
		r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
		pr, pg, pb, pa, rbs;
				
		var div = radius + radius + 1;
		var w4 = width << 2;
		var widthMinus1  = width - 1;
		var heightMinus1 = height - 1;
		var radiusPlus1  = radius + 1;
		var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
		
		var stackStart = new BlurStack();
		var stack = stackStart;
		for ( i = 1; i < div; i++ )
		{
			stack = stack.next = new BlurStack();
			if ( i == radiusPlus1 ) var stackEnd = stack;
		}
		stack.next = stackStart;
		var stackIn = null;
		var stackOut = null;
		
		yw = yi = 0;
		
		var mul_sum = mul_table[radius];
		var shg_sum = shg_table[radius];
		
		for ( y = 0; y < height; y++ )
		{
			r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
			
			r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
			g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
			b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
			a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
			
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			a_sum += sumFactor * pa;
			
			stack = stackStart;
			
			for( i = 0; i < radiusPlus1; i++ )
			{
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack.a = pa;
				stack = stack.next;
			}
			
			for( i = 1; i < radiusPlus1; i++ )
			{
				p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
				r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
				g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
				b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
				a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
				
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				a_in_sum += pa;
				
				stack = stack.next;
			}
			
			stackIn = stackStart;
			stackOut = stackEnd;
			for ( x = 0; x < width; x++ )
			{
				pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
				pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
				pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;
				pixels[yi+3] = (a_sum * mul_sum) >> shg_sum;
				
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				a_sum -= a_out_sum;
				
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				a_out_sum -= stackIn.a;
				
				p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
				
				r_in_sum += ( stackIn.r = pixels[p]);
				g_in_sum += ( stackIn.g = pixels[p+1]);
				b_in_sum += ( stackIn.b = pixels[p+2]);
				a_in_sum += ( stackIn.a = pixels[p+3]);
				
				r_sum += r_in_sum;
				g_sum += g_in_sum;
				b_sum += b_in_sum;
				a_sum += a_in_sum;
				
				stackIn = stackIn.next;
				
				r_out_sum += ( pr = stackOut.r );
				g_out_sum += ( pg = stackOut.g );
				b_out_sum += ( pb = stackOut.b );
				a_out_sum += ( pa = stackOut.a );
				
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				a_in_sum -= pa;
				
				stackOut = stackOut.next;

				yi += 4;
			}
			yw += width;
		}

		
		for ( x = 0; x < width; x++ )
		{
			g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
			
			yi = x << 2;
			r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
			g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
			b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
			a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
			
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			a_sum += sumFactor * pa;
			
			stack = stackStart;
			
			for( i = 0; i < radiusPlus1; i++ )
			{
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack.a = pa;
				stack = stack.next;
			}
			
			yp = width;
			
			for( i = 1; i <= radius; i++ )
			{
				yi = ( yp + x ) << 2;
				
				r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
				g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
				b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
				a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
			   
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				a_in_sum += pa;
				
				stack = stack.next;
			
				if( i < heightMinus1 )
				{
					yp += width;
				}
			}
			
			yi = x;
			stackIn = stackStart;
			stackOut = stackEnd;
			for ( y = 0; y < height; y++ )
			{
				p = yi << 2;
				pixels[p]   = (r_sum * mul_sum) >> shg_sum;
				pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
				pixels[p+2] = (b_sum * mul_sum) >> shg_sum;
				pixels[p+3] = (a_sum * mul_sum) >> shg_sum;
				
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				a_sum -= a_out_sum;
			   
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				a_out_sum -= stackIn.a;
				
				p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
				
				r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
				g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
				b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
				a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
			   
				stackIn = stackIn.next;
				
				r_out_sum += ( pr = stackOut.r );
				g_out_sum += ( pg = stackOut.g );
				b_out_sum += ( pb = stackOut.b );
				a_out_sum += ( pa = stackOut.a );
				
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				a_in_sum -= pa;
				
				stackOut = stackOut.next;
				
				yi += width;
			}
		}
		
		unpremultiplyAlpha(imageData);
		
		context.putImageData( imageData, top_x, top_y );
	}


	function stackBlurCanvasRGB( id, top_x, top_y, width, height, radius )
	{
		if ( isNaN(radius) || radius < 1 ) return;
		radius |= 0;
		
		var canvas  = document.getElementById( id );
		var context = canvas.getContext("2d");
		var imageData;
		
		try {
		  try {
			imageData = context.getImageData( top_x, top_y, width, height );
		  } catch(e) {
		  
			// NOTE: this part is supposedly only needed if you want to work with local files
			// so it might be okay to remove the whole try/catch block and just use
			// imageData = context.getImageData( top_x, top_y, width, height );
			try {
				netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
				imageData = context.getImageData( top_x, top_y, width, height );
			} catch(e) {
				alert("Cannot access local image");
				throw new Error("unable to access local image data: " + e);
				return;
			}
		  }
		} catch(e) {
		  alert("Cannot access image");
		  throw new Error("unable to access image data: " + e);
		}
				
		var pixels = imageData.data;
				
		var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum,
		r_out_sum, g_out_sum, b_out_sum,
		r_in_sum, g_in_sum, b_in_sum,
		pr, pg, pb, rbs;
				
		var div = radius + radius + 1;
		var w4 = width << 2;
		var widthMinus1  = width - 1;
		var heightMinus1 = height - 1;
		var radiusPlus1  = radius + 1;
		var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
		
		var stackStart = new BlurStack();
		var stack = stackStart;
		for ( i = 1; i < div; i++ )
		{
			stack = stack.next = new BlurStack();
			if ( i == radiusPlus1 ) var stackEnd = stack;
		}
		stack.next = stackStart;
		var stackIn = null;
		var stackOut = null;
		
		yw = yi = 0;
		
		var mul_sum = mul_table[radius];
		var shg_sum = shg_table[radius];
		
		for ( y = 0; y < height; y++ )
		{
			r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;
			
			r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
			g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
			b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
			
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			
			stack = stackStart;
			
			for( i = 0; i < radiusPlus1; i++ )
			{
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack = stack.next;
			}
			
			for( i = 1; i < radiusPlus1; i++ )
			{
				p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
				r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
				g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
				b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
				
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				
				stack = stack.next;
			}
			
			
			stackIn = stackStart;
			stackOut = stackEnd;
			for ( x = 0; x < width; x++ )
			{
				pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
				pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
				pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;
				
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				
				p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
				
				r_in_sum += ( stackIn.r = pixels[p]);
				g_in_sum += ( stackIn.g = pixels[p+1]);
				b_in_sum += ( stackIn.b = pixels[p+2]);
				
				r_sum += r_in_sum;
				g_sum += g_in_sum;
				b_sum += b_in_sum;
				
				stackIn = stackIn.next;
				
				r_out_sum += ( pr = stackOut.r );
				g_out_sum += ( pg = stackOut.g );
				b_out_sum += ( pb = stackOut.b );
				
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				
				stackOut = stackOut.next;

				yi += 4;
			}
			yw += width;
		}

		
		for ( x = 0; x < width; x++ )
		{
			g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;
			
			yi = x << 2;
			r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
			g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
			b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
			
			r_sum += sumFactor * pr;
			g_sum += sumFactor * pg;
			b_sum += sumFactor * pb;
			
			stack = stackStart;
			
			for( i = 0; i < radiusPlus1; i++ )
			{
				stack.r = pr;
				stack.g = pg;
				stack.b = pb;
				stack = stack.next;
			}
			
			yp = width;
			
			for( i = 1; i <= radius; i++ )
			{
				yi = ( yp + x ) << 2;
				
				r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
				g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
				b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
				
				r_in_sum += pr;
				g_in_sum += pg;
				b_in_sum += pb;
				
				stack = stack.next;
			
				if( i < heightMinus1 )
				{
					yp += width;
				}
			}
			
			yi = x;
			stackIn = stackStart;
			stackOut = stackEnd;
			for ( y = 0; y < height; y++ )
			{
				p = yi << 2;
				pixels[p]   = (r_sum * mul_sum) >> shg_sum;
				pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
				pixels[p+2] = (b_sum * mul_sum) >> shg_sum;
				
				r_sum -= r_out_sum;
				g_sum -= g_out_sum;
				b_sum -= b_out_sum;
				
				r_out_sum -= stackIn.r;
				g_out_sum -= stackIn.g;
				b_out_sum -= stackIn.b;
				
				p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
				
				r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
				g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
				b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
				
				stackIn = stackIn.next;
				
				r_out_sum += ( pr = stackOut.r );
				g_out_sum += ( pg = stackOut.g );
				b_out_sum += ( pb = stackOut.b );
				
				r_in_sum -= pr;
				g_in_sum -= pg;
				b_in_sum -= pb;
				
				stackOut = stackOut.next;
				
				yi += width;
			}
		}
		
		context.putImageData( imageData, top_x, top_y );
		
	}

	function BlurStack()
	{
		this.r = 0;
		this.g = 0;
		this.b = 0;
		this.a = 0;
		this.next = null;
	}

	var stackBlur = {
		image: stackBlurImage,
		canvasRGBA: stackBlurCanvasRGBA,
		canvasRGB: stackBlurCanvasRGB
	};

	// export as AMD...
	if ( typeof define !== 'undefined' && define.amd ) {
	    define( 'stackblur',[],function () { return stackBlur; });
	}

	// ...or as browserify
	else if ( typeof module !== 'undefined' && module.exports ) {
	    module.exports = stackBlur;
	}

	global.stackBlur = stackBlur;

}( typeof window !== 'undefined' ? window : this ));
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
 (function ( global, factory ) {

	'use strict';

	// export as AMD...
	if ( typeof define !== 'undefined' && define.amd ) {
		define('canvgModule', [ 'rgbcolor', 'stackblur' ], factory );
	}

	// ...or as browserify
	else if ( typeof module !== 'undefined' && module.exports ) {
		module.exports = factory( require( 'rgbcolor' ), require( 'stackblur' ) );
	}

	global.canvg = factory( global.RGBColor, global.stackBlur );

}( typeof window !== 'undefined' ? window : this, function ( RGBColor, stackBlur ) {
 
	// canvg(target, s)
	// empty parameters: replace all 'svg' elements on page with 'canvas' elements
	// target: canvas element or the id of a canvas element
	// s: svg string, url to svg file, or xml document
	// opts: optional hash of options
	//		 ignoreMouse: true => ignore mouse events
	//		 ignoreAnimation: true => ignore animations
	//		 ignoreDimensions: true => does not try to resize canvas
	//		 ignoreClear: true => does not clear canvas
	//		 offsetX: int => draws at a x offset
	//		 offsetY: int => draws at a y offset
	//		 scaleWidth: int => scales horizontally to width
	//		 scaleHeight: int => scales vertically to height
	//		 renderCallback: function => will call the function after the first render is completed
	//		 forceRedraw: function => will call the function on every frame, if it returns true, will redraw
	var canvg = function (target, s, opts) {
		// no parameters
		if (target == null && s == null && opts == null) {
			var svgTags = document.querySelectorAll('svg');
			for (var i=0; i<svgTags.length; i++) {
				var svgTag = svgTags[i];
				var c = document.createElement('canvas');
				c.width = svgTag.clientWidth;
				c.height = svgTag.clientHeight;
				svgTag.parentNode.insertBefore(c, svgTag);
				svgTag.parentNode.removeChild(svgTag);
				var div = document.createElement('div');
				div.appendChild(svgTag);
				canvg(c, div.innerHTML);
			}
			return;
		}

		if (typeof target == 'string') {
			target = document.getElementById(target);
		}

		// store class on canvas
		if (target.svg != null) target.svg.stop();
		var svg = build(opts || {});
		// on i.e. 8 for flash canvas, we can't assign the property so check for it
		if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;

		var ctx = target.getContext('2d');
		if (typeof(s.documentElement) != 'undefined') {
			// load from xml doc
			svg.loadXmlDoc(ctx, s);
		}
		else if (s.substr(0,1) == '<') {
			// load from xml string
			svg.loadXml(ctx, s);
		}
		else {
			// load from url
			svg.load(ctx, s);
		}
	}

	// see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
	var matchesSelector;
	if (typeof(Element.prototype.matches) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.matches(selector);
		};
	} else if (typeof(Element.prototype.webkitMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.webkitMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.mozMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.mozMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.msMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.msMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.oMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.oMatchesSelector(selector);
		};
	} else {
		// requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation
		// or jQuery: http://jquery.com/download/
		// or Zepto: http://zeptojs.com/#
		// without it, this is a ReferenceError

		if (typeof jQuery === 'function' || typeof Zepto === 'function') {
			matchesSelector = function (node, selector) {
				return $(node).is(selector);
			};
		}

		if (typeof matchesSelector === 'undefined') {
			matchesSelector = Sizzle.matchesSelector;
		}
	}

	// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi;
	var pseudoClassWithBracketsRegex = /(:[\w-]+\([^\)]*\))/gi;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	function getSelectorSpecificity(selector) {
		var typeCount = [0, 0, 0];
		var findMatch = function(regex, type) {
			var matches = selector.match(regex);
			if (matches == null) {
				return;
			}
			typeCount[type] += matches.length;
			selector = selector.replace(regex, ' ');
		};

		selector = selector.replace(/:not\(([^\)]*)\)/g, '     $1 ');
		selector = selector.replace(/{[^]*/gm, ' ');
		findMatch(attributeRegex, 1);
		findMatch(idRegex, 0);
		findMatch(classRegex, 1);
		findMatch(pseudoElementRegex, 2);
		findMatch(pseudoClassWithBracketsRegex, 1);
		findMatch(pseudoClassRegex, 1);
		selector = selector.replace(/[\*\s\+>~]/g, ' ');
		selector = selector.replace(/[#\.]/g, ' ');
		findMatch(elementRegex, 2);
		return typeCount.join('');
	}

	function build(opts) {
		var svg = { opts: opts };

		svg.FRAMERATE = 30;
		svg.MAX_VIRTUAL_PIXELS = 30000;

		svg.log = function(msg) {};
		if (svg.opts['log'] == true && typeof(console) != 'undefined') {
			svg.log = function(msg) { console.log(msg); };
		};

		// globals
		svg.init = function(ctx) {
			var uniqueId = 0;
			svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
			svg.Definitions = {};
			svg.Styles = {};
			svg.StylesSpecificity = {};
			svg.Animations = [];
			svg.Images = [];
			svg.ctx = ctx;
			svg.ViewPort = new (function () {
				this.viewPorts = [];
				this.Clear = function() { this.viewPorts = []; }
				this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
				this.RemoveCurrent = function() { this.viewPorts.pop(); }
				this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
				this.width = function() { return this.Current().width; }
				this.height = function() { return this.Current().height; }
				this.ComputeSize = function(d) {
					if (d != null && typeof(d) == 'number') return d;
					if (d == 'x') return this.width();
					if (d == 'y') return this.height();
					return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
				}
			});
		}
		svg.init();

		// images loaded
		svg.ImagesLoaded = function() {
			for (var i=0; i<svg.Images.length; i++) {
				if (!svg.Images[i].loaded) return false;
			}
			return true;
		}

		// trim
		svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }

		// compress spaces
		svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }

		// ajax
		svg.ajax = function(url) {
			var AJAX;
			if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
			else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
			if(AJAX){
			   AJAX.open('GET',url,false);
			   AJAX.send(null);
			   return AJAX.responseText;
			}
			return null;
		}

		// parse xml
		svg.parseXml = function(xml) {
			if (typeof(Windows) != 'undefined' && typeof(Windows.Data) != 'undefined' && typeof(Windows.Data.Xml) != 'undefined') {
				var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
				var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
				settings.prohibitDtd = false;
				xmlDoc.loadXml(xml, settings);
				return xmlDoc;
			}
			else if (window.DOMParser)
			{
				var parser = new DOMParser();
				return parser.parseFromString(xml, 'text/xml');
			}
			else
			{
				xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
				var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.async = 'false';
				xmlDoc.loadXML(xml);
				return xmlDoc;
			}
		}

		svg.Property = function(name, value) {
			this.name = name;
			this.value = value;
		}
			svg.Property.prototype.getValue = function() {
				return this.value;
			}

			svg.Property.prototype.hasValue = function() {
				return (this.value != null && this.value !== '');
			}

			// return the numerical value of the property
			svg.Property.prototype.numValue = function() {
				if (!this.hasValue()) return 0;

				var n = parseFloat(this.value);
				if ((this.value + '').match(/%$/)) {
					n = n / 100.0;
				}
				return n;
			}

			svg.Property.prototype.valueOrDefault = function(def) {
				if (this.hasValue()) return this.value;
				return def;
			}

			svg.Property.prototype.numValueOrDefault = function(def) {
				if (this.hasValue()) return this.numValue();
				return def;
			}

			// color extensions
				// augment the current color value with the opacity
				svg.Property.prototype.addOpacity = function(opacityProp) {
					var newValue = this.value;
					if (opacityProp.value != null && opacityProp.value != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
						var color = new RGBColor(this.value);
						if (color.ok) {
							newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
						}
					}
					return new svg.Property(this.name, newValue);
				}

			// definition extensions
				// get the definition from the definitions table
				svg.Property.prototype.getDefinition = function() {
					var name = this.value.match(/#([^\)'"]+)/);
					if (name) { name = name[1]; }
					if (!name) { name = this.value; }
					return svg.Definitions[name];
				}

				svg.Property.prototype.isUrlDefinition = function() {
					return this.value.indexOf('url(') == 0
				}

				svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
					var def = this.getDefinition();

					// gradient
					if (def != null && def.createGradient) {
						return def.createGradient(svg.ctx, e, opacityProp);
					}

					// pattern
					if (def != null && def.createPattern) {
						if (def.getHrefAttribute().hasValue()) {
							var pt = def.attribute('patternTransform');
							def = def.getHrefAttribute().getDefinition();
							if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
						}
						return def.createPattern(svg.ctx, e);
					}

					return null;
				}

			// length extensions
				svg.Property.prototype.getDPI = function(viewPort) {
					return 96.0; // TODO: compute?
				}

				svg.Property.prototype.getEM = function(viewPort) {
					var em = 12;

					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);

					return em;
				}

				svg.Property.prototype.getUnits = function() {
					var s = this.value+'';
					return s.replace(/[0-9\.\-]/g,'');
				}

				// get the length as pixels
				svg.Property.prototype.toPixels = function(viewPort, processPercent) {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
					if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
					if (s.match(/px$/)) return this.numValue();
					if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
					if (s.match(/pc$/)) return this.numValue() * 15;
					if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
					if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
					if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
					if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
					var n = this.numValue();
					if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
					return n;
				}

			// time extensions
				// get the time as milliseconds
				svg.Property.prototype.toMilliseconds = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/s$/)) return this.numValue() * 1000;
					if (s.match(/ms$/)) return this.numValue();
					return this.numValue();
				}

			// angle extensions
				// get the angle as radians
				svg.Property.prototype.toRadians = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
					if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
					if (s.match(/rad$/)) return this.numValue();
					return this.numValue() * (Math.PI / 180.0);
				}

			// text extensions
				// get the text baseline
				var textBaselineMapping = {
					'baseline': 'alphabetic',
					'before-edge': 'top',
					'text-before-edge': 'top',
					'middle': 'middle',
					'central': 'middle',
					'after-edge': 'bottom',
					'text-after-edge': 'bottom',
					'ideographic': 'ideographic',
					'alphabetic': 'alphabetic',
					'hanging': 'hanging',
					'mathematical': 'alphabetic'
				};
				svg.Property.prototype.toTextBaseline = function () {
					if (!this.hasValue()) return null;
					return textBaselineMapping[this.value];
				}

		// fonts
		svg.Font = new (function() {
			this.Styles = 'normal|italic|oblique|inherit';
			this.Variants = 'normal|small-caps|inherit';
			this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

			this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
				var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
				return {
					fontFamily: fontFamily || f.fontFamily,
					fontSize: fontSize || f.fontSize,
					fontStyle: fontStyle || f.fontStyle,
					fontWeight: fontWeight || f.fontWeight,
					fontVariant: fontVariant || f.fontVariant,
					toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }
				}
			}

			var that = this;
			this.Parse = function(s) {
				var f = {};
				var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
				var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
				var ff = '';
				for (var i=0; i<d.length; i++) {
					if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
					else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
					else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
					else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
					else { if (d[i] != 'inherit') ff += d[i]; }
				} if (ff != '') f.fontFamily = ff;
				return f;
			}
		});

		// points and paths
		svg.ToNumberArray = function(s) {
			var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
			for (var i=0; i<a.length; i++) {
				a[i] = parseFloat(a[i]);
			}
			return a;
		}
		svg.Point = function(x, y) {
			this.x = x;
			this.y = y;
		}
			svg.Point.prototype.angleTo = function(p) {
				return Math.atan2(p.y - this.y, p.x - this.x);
			}

			svg.Point.prototype.applyTransform = function(v) {
				var xp = this.x * v[0] + this.y * v[2] + v[4];
				var yp = this.x * v[1] + this.y * v[3] + v[5];
				this.x = xp;
				this.y = yp;
			}

		svg.CreatePoint = function(s) {
			var a = svg.ToNumberArray(s);
			return new svg.Point(a[0], a[1]);
		}
		svg.CreatePath = function(s) {
			var a = svg.ToNumberArray(s);
			var path = [];
			for (var i=0; i<a.length; i+=2) {
				path.push(new svg.Point(a[i], a[i+1]));
			}
			return path;
		}

		// bounding box
		svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
			this.x1 = Number.NaN;
			this.y1 = Number.NaN;
			this.x2 = Number.NaN;
			this.y2 = Number.NaN;

			this.x = function() { return this.x1; }
			this.y = function() { return this.y1; }
			this.width = function() { return this.x2 - this.x1; }
			this.height = function() { return this.y2 - this.y1; }

			this.addPoint = function(x, y) {
				if (x != null) {
					if (isNaN(this.x1) || isNaN(this.x2)) {
						this.x1 = x;
						this.x2 = x;
					}
					if (x < this.x1) this.x1 = x;
					if (x > this.x2) this.x2 = x;
				}

				if (y != null) {
					if (isNaN(this.y1) || isNaN(this.y2)) {
						this.y1 = y;
						this.y2 = y;
					}
					if (y < this.y1) this.y1 = y;
					if (y > this.y2) this.y2 = y;
				}
			}
			this.addX = function(x) { this.addPoint(x, null); }
			this.addY = function(y) { this.addPoint(null, y); }

			this.addBoundingBox = function(bb) {
				this.addPoint(bb.x1, bb.y1);
				this.addPoint(bb.x2, bb.y2);
			}

			this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
				var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
				var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
				this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
			}

			this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
				// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
				var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
				this.addPoint(p0[0], p0[1]);
				this.addPoint(p3[0], p3[1]);

				for (i=0; i<=1; i++) {
					var f = function(t) {
						return Math.pow(1-t, 3) * p0[i]
						+ 3 * Math.pow(1-t, 2) * t * p1[i]
						+ 3 * (1-t) * Math.pow(t, 2) * p2[i]
						+ Math.pow(t, 3) * p3[i];
					}

					var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
					var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
					var c = 3 * p1[i] - 3 * p0[i];

					if (a == 0) {
						if (b == 0) continue;
						var t = -c / b;
						if (0 < t && t < 1) {
							if (i == 0) this.addX(f(t));
							if (i == 1) this.addY(f(t));
						}
						continue;
					}

					var b2ac = Math.pow(b, 2) - 4 * c * a;
					if (b2ac < 0) continue;
					var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
					if (0 < t1 && t1 < 1) {
						if (i == 0) this.addX(f(t1));
						if (i == 1) this.addY(f(t1));
					}
					var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
					if (0 < t2 && t2 < 1) {
						if (i == 0) this.addX(f(t2));
						if (i == 1) this.addY(f(t2));
					}
				}
			}

			this.isPointInBox = function(x, y) {
				return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
			}

			this.addPoint(x1, y1);
			this.addPoint(x2, y2);
		}

		// transforms
		svg.Transform = function(v) {
			var that = this;
			this.Type = {}

			// translate
			this.Type.translate = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
				}
				this.unapply = function(ctx) {
					ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
				}
			}

			// rotate
			this.Type.rotate = function(s) {
				var a = svg.ToNumberArray(s);
				this.angle = new svg.Property('angle', a[0]);
				this.cx = a[1] || 0;
				this.cy = a[2] || 0;
				this.apply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.unapply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(-1.0 * this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.applyToPoint = function(p) {
					var a = this.angle.toRadians();
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
					p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
					p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
				}
			}

			this.Type.scale = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
				}
				this.unapply = function(ctx) {
					ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
				}
			}

			this.Type.matrix = function(s) {
				this.m = svg.ToNumberArray(s);
				this.apply = function(ctx) {
					ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
				}
				this.unapply = function(ctx) {
					var a = this.m[0];
					var b = this.m[2];
					var c = this.m[4];
					var d = this.m[1];
					var e = this.m[3];
					var f = this.m[5];
					var g = 0.0;
					var h = 0.0;
					var i = 1.0;
					var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
					ctx.transform(
						det*(e*i-f*h),
						det*(f*g-d*i),
						det*(c*h-b*i),
						det*(a*i-c*g),
						det*(b*f-c*e),
						det*(c*d-a*f)
					);
				}
				this.applyToPoint = function(p) {
					p.applyTransform(this.m);
				}
			}

			this.Type.SkewBase = function(s) {
				this.base = that.Type.matrix;
				this.base(s);
				this.angle = new svg.Property('angle', s);
			}
			this.Type.SkewBase.prototype = new this.Type.matrix;

			this.Type.skewX = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
			}
			this.Type.skewX.prototype = new this.Type.SkewBase;

			this.Type.skewY = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
			}
			this.Type.skewY.prototype = new this.Type.SkewBase;

			this.transforms = [];

			this.apply = function(ctx) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].apply(ctx);
				}
			}

			this.unapply = function(ctx) {
				for (var i=this.transforms.length-1; i>=0; i--) {
					this.transforms[i].unapply(ctx);
				}
			}

			this.applyToPoint = function(p) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].applyToPoint(p);
				}
			}

			var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
			for (var i=0; i<data.length; i++) {
				var type = svg.trim(data[i].split('(')[0]);
				var s = data[i].split('(')[1].replace(')','');
				var transform = new this.Type[type](s);
				transform.type = type;
				this.transforms.push(transform);
			}
		}

		// aspect ratio
		svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
			// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
			aspectRatio = svg.compressSpaces(aspectRatio);
			aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
			var align = aspectRatio.split(' ')[0] || 'xMidYMid';
			var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';

			// calculate scale
			var scaleX = width / desiredWidth;
			var scaleY = height / desiredHeight;
			var scaleMin = Math.min(scaleX, scaleY);
			var scaleMax = Math.max(scaleX, scaleY);
			if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
			if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }

			refX = new svg.Property('refX', refX);
			refY = new svg.Property('refY', refY);
			if (refX.hasValue() && refY.hasValue()) {
				ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
			}
			else {
				// align
				if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
				if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
				if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);
				if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);
			}

			// scale
			if (align == 'none') ctx.scale(scaleX, scaleY);
			else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);
			else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);

			// translate
			ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
		}

		// elements
		svg.Element = {}

		svg.EmptyProperty = new svg.Property('EMPTY', '');

		svg.Element.ElementBase = function(node) {
			this.attributes = {};
			this.styles = {};
			this.stylesSpecificity = {};
			this.children = [];

			// get or create attribute
			this.attribute = function(name, createIfNotExists) {
				var a = this.attributes[name];
				if (a != null) return a;

				if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
				return a || svg.EmptyProperty;
			}

			this.getHrefAttribute = function() {
				for (var a in this.attributes) {
					if (a == 'href' || a.match(/:href$/)) {
						return this.attributes[a];
					}
				}
				return svg.EmptyProperty;
			}

			// get or create style, crawls up node tree
			this.style = function(name, createIfNotExists, skipAncestors) {
				var s = this.styles[name];
				if (s != null) return s;

				var a = this.attribute(name);
				if (a != null && a.hasValue()) {
					this.styles[name] = a; // move up to me to cache
					return a;
				}

				if (skipAncestors != true) {
					var p = this.parent;
					if (p != null) {
						var ps = p.style(name);
						if (ps != null && ps.hasValue()) {
							return ps;
						}
					}
				}

				if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
				return s || svg.EmptyProperty;
			}

			// base render
			this.render = function(ctx) {
				// don't render display=none
				if (this.style('display').value == 'none') return;

				// don't render visibility=hidden
				if (this.style('visibility').value == 'hidden') return;

				ctx.save();
				if (this.style('mask').hasValue()) { // mask
					var mask = this.style('mask').getDefinition();
					if (mask != null) mask.apply(ctx, this);
				}
				else if (this.style('filter').hasValue()) { // filter
					var filter = this.style('filter').getDefinition();
					if (filter != null) filter.apply(ctx, this);
				}
				else {
					this.setContext(ctx);
					this.renderChildren(ctx);
					this.clearContext(ctx);
				}
				ctx.restore();
			}

			// base set context
			this.setContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base clear context
			this.clearContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base render children
			this.renderChildren = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					this.children[i].render(ctx);
				}
			}

			this.addChild = function(childNode, create) {
				var child = childNode;
				if (create) child = svg.CreateElement(childNode);
				child.parent = this;
				if (child.type != 'title') { this.children.push(child);	}
			}
			
			this.addStylesFromStyleDefinition = function () {
				// add styles
				for (var selector in svg.Styles) {
					if (selector[0] != '@' && matchesSelector(node, selector)) {
						var styles = svg.Styles[selector];
						var specificity = svg.StylesSpecificity[selector];
						if (styles != null) {
							for (var name in styles) {
								var existingSpecificity = this.stylesSpecificity[name];
								if (typeof(existingSpecificity) == 'undefined') {
									existingSpecificity = '000';
								}
								if (specificity > existingSpecificity) {
									this.styles[name] = styles[name];
									this.stylesSpecificity[name] = specificity;
								}
							}
						}
					}
				}
			};

			if (node != null && node.nodeType == 1) { //ELEMENT_NODE
				// add attributes
				for (var i=0; i<node.attributes.length; i++) {
					var attribute = node.attributes[i];
					this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.value);
				}
				
				this.addStylesFromStyleDefinition();

				// add inline styles
				if (this.attribute('style').hasValue()) {
					var styles = this.attribute('style').value.split(';');
					for (var i=0; i<styles.length; i++) {
						if (svg.trim(styles[i]) != '') {
							var style = styles[i].split(':');
							var name = svg.trim(style[0]);
							var value = svg.trim(style[1]);
							this.styles[name] = new svg.Property(name, value);
						}
					}
				}

				// add id
				if (this.attribute('id').hasValue()) {
					if (svg.Definitions[this.attribute('id').value] == null) {
						svg.Definitions[this.attribute('id').value] = this;
					}
				}

				// add children
				for (var i=0; i<node.childNodes.length; i++) {
					var childNode = node.childNodes[i];
					if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
					if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
						var text = childNode.value || childNode.text || childNode.textContent || '';
						if (svg.compressSpaces(text) != '') {
							this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
						}
					}
				}
			}
		}

		svg.Element.RenderedElementBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.setContext = function(ctx) {
				// fill
				if (this.style('fill').isUrlDefinition()) {
					var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
					if (fs != null) ctx.fillStyle = fs;
				}
				else if (this.style('fill').hasValue()) {
					var fillStyle = this.style('fill');
					if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
					if (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
				}
				if (this.style('fill-opacity').hasValue()) {
					var fillStyle = new svg.Property('fill', ctx.fillStyle);
					fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
					ctx.fillStyle = fillStyle.value;
				}

				// stroke
				if (this.style('stroke').isUrlDefinition()) {
					var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
					if (fs != null) ctx.strokeStyle = fs;
				}
				else if (this.style('stroke').hasValue()) {
					var strokeStyle = this.style('stroke');
					if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
					if (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
				}
				if (this.style('stroke-opacity').hasValue()) {
					var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
					strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
					ctx.strokeStyle = strokeStyle.value;
				}
				if (this.style('stroke-width').hasValue()) {
					var newLineWidth = this.style('stroke-width').toPixels();
					ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
			    }
				if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
				if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
				if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
				if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
					var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
					if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
					else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
					else if (typeof(ctx.mozDash) != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }

					var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
					if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
					else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
					else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
				}

				// font
				if (typeof(ctx.font) != 'undefined') {
					ctx.font = svg.Font.CreateFont(
						this.style('font-style').value,
						this.style('font-variant').value,
						this.style('font-weight').value,
						this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',
						this.style('font-family').value).toString();
				}

				// transform
				if (this.style('transform', false, true).hasValue()) {
					var transform = new svg.Transform(this.style('transform', false, true).value);
					transform.apply(ctx);
				}

				// clip
				if (this.style('clip-path', false, true).hasValue()) {
					var clip = this.style('clip-path', false, true).getDefinition();
					if (clip != null) clip.apply(ctx);
				}

				// opacity
				if (this.style('opacity').hasValue()) {
					ctx.globalAlpha = this.style('opacity').numValue();
				}
			}
		}
		svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;

		svg.Element.PathElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.path = function(ctx) {
				if (ctx != null) ctx.beginPath();
				return new svg.BoundingBox();
			}

			this.renderChildren = function(ctx) {
				this.path(ctx);
				svg.Mouse.checkPath(this, ctx);
				if (ctx.fillStyle != '') {
					if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
					else { ctx.fill(); }
				}
				if (ctx.strokeStyle != '') ctx.stroke();

				var markers = this.getMarkers();
				if (markers != null) {
					if (this.style('marker-start').isUrlDefinition()) {
						var marker = this.style('marker-start').getDefinition();
						marker.render(ctx, markers[0][0], markers[0][1]);
					}
					if (this.style('marker-mid').isUrlDefinition()) {
						var marker = this.style('marker-mid').getDefinition();
						for (var i=1;i<markers.length-1;i++) {
							marker.render(ctx, markers[i][0], markers[i][1]);
						}
					}
					if (this.style('marker-end').isUrlDefinition()) {
						var marker = this.style('marker-end').getDefinition();
						marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
					}
				}
			}

			this.getBoundingBox = function() {
				return this.path();
			}

			this.getMarkers = function() {
				return null;
			}
		}
		svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;

		// svg element
		svg.Element.svg = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseClearContext = this.clearContext;
			this.clearContext = function(ctx) {
				this.baseClearContext(ctx);
				svg.ViewPort.RemoveCurrent();
			}

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				// initial values and defaults
				ctx.strokeStyle = 'rgba(0,0,0,0)';
				ctx.lineCap = 'butt';
				ctx.lineJoin = 'miter';
				ctx.miterLimit = 4;
				if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
					ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
				}

				this.baseSetContext(ctx);

				// create new view port
				if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
				if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
				ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));

				var width = svg.ViewPort.width();
				var height = svg.ViewPort.height();

				if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
				if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
				if (typeof(this.root) == 'undefined') {
					width = this.attribute('width').toPixels('x');
					height = this.attribute('height').toPixels('y');

					var x = 0;
					var y = 0;
					if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
						x = -this.attribute('refX').toPixels('x');
						y = -this.attribute('refY').toPixels('y');
					}

					if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
						ctx.beginPath();
						ctx.moveTo(x, y);
						ctx.lineTo(width, y);
						ctx.lineTo(width, height);
						ctx.lineTo(x, height);
						ctx.closePath();
						ctx.clip();
					}
				}
				svg.ViewPort.SetCurrent(width, height);

				// viewbox
				if (this.attribute('viewBox').hasValue()) {
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];

					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									svg.ViewPort.width(),
									width,
									svg.ViewPort.height(),
									height,
									minX,
									minY,
									this.attribute('refX').value,
									this.attribute('refY').value);

					svg.ViewPort.RemoveCurrent();
					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
				}
			}
		}
		svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

		// rect element
		svg.Element.rect = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
				if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
				rx = Math.min(rx, width / 2.0);
				ry = Math.min(ry, height / 2.0);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(x + rx, y);
					ctx.lineTo(x + width - rx, y);
					ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
					ctx.lineTo(x + width, y + height - ry);
					ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
					ctx.lineTo(x + rx, y + height);
					ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
					ctx.lineTo(x, y + ry);
					ctx.quadraticCurveTo(x, y, x + rx, y)
					ctx.closePath();
				}

				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.rect.prototype = new svg.Element.PathElementBase;

		// circle element
		svg.Element.circle = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				var r = this.attribute('r').toPixels();

				if (ctx != null) {
					ctx.beginPath();
					ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
			}
		}
		svg.Element.circle.prototype = new svg.Element.PathElementBase;

		// ellipse element
		svg.Element.ellipse = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(cx, cy - ry);
					ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
					ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
					ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
					ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
			}
		}
		svg.Element.ellipse.prototype = new svg.Element.PathElementBase;

		// line element
		svg.Element.line = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.getPoints = function() {
				return [
					new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
					new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
			}

			this.path = function(ctx) {
				var points = this.getPoints();

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(points[0].x, points[0].y);
					ctx.lineTo(points[1].x, points[1].y);
				}

				return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
			}

			this.getMarkers = function() {
				var points = this.getPoints();
				var a = points[0].angleTo(points[1]);
				return [[points[0], a], [points[1], a]];
			}
		}
		svg.Element.line.prototype = new svg.Element.PathElementBase;

		// polyline element
		svg.Element.polyline = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.points = svg.CreatePath(this.attribute('points').value);
			this.path = function(ctx) {
				var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(this.points[0].x, this.points[0].y);
				}
				for (var i=1; i<this.points.length; i++) {
					bb.addPoint(this.points[i].x, this.points[i].y);
					if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
				}
				return bb;
			}

			this.getMarkers = function() {
				var markers = [];
				for (var i=0; i<this.points.length - 1; i++) {
					markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
				}
				markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
				return markers;
			}
		}
		svg.Element.polyline.prototype = new svg.Element.PathElementBase;

		// polygon element
		svg.Element.polygon = function(node) {
			this.base = svg.Element.polyline;
			this.base(node);

			this.basePath = this.path;
			this.path = function(ctx) {
				var bb = this.basePath(ctx);
				if (ctx != null) {
					ctx.lineTo(this.points[0].x, this.points[0].y);
					ctx.closePath();
				}
				return bb;
			}
		}
		svg.Element.polygon.prototype = new svg.Element.polyline;

		// path element
		svg.Element.path = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			var d = this.attribute('d').value;
			// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
			d = d.replace(/,/gm,' '); // get rid of all commas
			// As the end of a match can also be the start of the next match, we need to run this replace twice.
			for(var i=0; i<2; i++)
				d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // suffix commands with spaces
			d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // prefix commands with spaces
			d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits on +- signs
			// Again, we need to run this twice to find all occurances
			for(var i=0; i<2; i++)
				d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when they start with a comma
			d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
			d = svg.compressSpaces(d); // compress multiple spaces
			d = svg.trim(d);
			this.PathParser = new (function(d) {
				this.tokens = d.split(' ');

				this.reset = function() {
					this.i = -1;
					this.command = '';
					this.previousCommand = '';
					this.start = new svg.Point(0, 0);
					this.control = new svg.Point(0, 0);
					this.current = new svg.Point(0, 0);
					this.points = [];
					this.angles = [];
				}

				this.isEnd = function() {
					return this.i >= this.tokens.length - 1;
				}

				this.isCommandOrEnd = function() {
					if (this.isEnd()) return true;
					return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
				}

				this.isRelativeCommand = function() {
					switch(this.command)
					{
						case 'm':
						case 'l':
						case 'h':
						case 'v':
						case 'c':
						case 's':
						case 'q':
						case 't':
						case 'a':
						case 'z':
							return true;
							break;
					}
					return false;
				}

				this.getToken = function() {
					this.i++;
					return this.tokens[this.i];
				}

				this.getScalar = function() {
					return parseFloat(this.getToken());
				}

				this.nextCommand = function() {
					this.previousCommand = this.command;
					this.command = this.getToken();
				}

				this.getPoint = function() {
					var p = new svg.Point(this.getScalar(), this.getScalar());
					return this.makeAbsolute(p);
				}

				this.getAsControlPoint = function() {
					var p = this.getPoint();
					this.control = p;
					return p;
				}

				this.getAsCurrentPoint = function() {
					var p = this.getPoint();
					this.current = p;
					return p;
				}

				this.getReflectedControlPoint = function() {
					if (this.previousCommand.toLowerCase() != 'c' &&
					    this.previousCommand.toLowerCase() != 's' &&
						this.previousCommand.toLowerCase() != 'q' &&
						this.previousCommand.toLowerCase() != 't' ){
						return this.current;
					}

					// reflect point
					var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
					return p;
				}

				this.makeAbsolute = function(p) {
					if (this.isRelativeCommand()) {
						p.x += this.current.x;
						p.y += this.current.y;
					}
					return p;
				}

				this.addMarker = function(p, from, priorTo) {
					// if the last angle isn't filled in because we didn't have this point yet ...
					if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
						this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
					}
					this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
				}

				this.addMarkerAngle = function(p, a) {
					this.points.push(p);
					this.angles.push(a);
				}

				this.getMarkerPoints = function() { return this.points; }
				this.getMarkerAngles = function() {
					for (var i=0; i<this.angles.length; i++) {
						if (this.angles[i] == null) {
							for (var j=i+1; j<this.angles.length; j++) {
								if (this.angles[j] != null) {
									this.angles[i] = this.angles[j];
									break;
								}
							}
						}
					}
					return this.angles;
				}
			})(d);

			this.path = function(ctx) {
				var pp = this.PathParser;
				pp.reset();

				var bb = new svg.BoundingBox();
				if (ctx != null) ctx.beginPath();
				while (!pp.isEnd()) {
					pp.nextCommand();
					switch (pp.command) {
					case 'M':
					case 'm':
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.moveTo(p.x, p.y);
						pp.start = pp.current;
						while (!pp.isCommandOrEnd()) {
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, pp.start);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'L':
					case 'l':
						while (!pp.isCommandOrEnd()) {
							var c = pp.current;
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, c);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'H':
					case 'h':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'V':
					case 'v':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'C':
					case 'c':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'S':
					case 's':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getReflectedControlPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'Q':
					case 'q':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'T':
					case 't':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getReflectedControlPoint();
							pp.control = cntrl;
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'A':
					case 'a':
						while (!pp.isCommandOrEnd()) {
						    var curr = pp.current;
							var rx = pp.getScalar();
							var ry = pp.getScalar();
							var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
							var largeArcFlag = pp.getScalar();
							var sweepFlag = pp.getScalar();
							var cp = pp.getAsCurrentPoint();

							// Conversion from endpoint to center parameterization
							// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
							// x1', y1'
							var currp = new svg.Point(
								Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
								-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
							);
							// adjust radii
							var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
							if (l > 1) {
								rx *= Math.sqrt(l);
								ry *= Math.sqrt(l);
							}
							// cx', cy'
							var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
								((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
								(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
							);
							if (isNaN(s)) s = 0;
							var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
							// cx, cy
							var centp = new svg.Point(
								(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
								(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
							);
							// vector magnitude
							var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
							// ratio between two vectors
							var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
							// angle between two vectors
							var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
							// initial angle
							var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
							// angle delta
							var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
							var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
							var ad = a(u, v);
							if (r(u,v) <= -1) ad = Math.PI;
							if (r(u,v) >= 1) ad = 0;

							// for markers
							var dir = 1 - sweepFlag ? 1.0 : -1.0;
							var ah = a1 + dir * (ad / 2.0);
							var halfWay = new svg.Point(
								centp.x + rx * Math.cos(ah),
								centp.y + ry * Math.sin(ah)
							);
							pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
							pp.addMarkerAngle(cp, ah - dir * Math.PI);

							bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
							if (ctx != null) {
								var r = rx > ry ? rx : ry;
								var sx = rx > ry ? 1 : rx / ry;
								var sy = rx > ry ? ry / rx : 1;

								ctx.translate(centp.x, centp.y);
								ctx.rotate(xAxisRotation);
								ctx.scale(sx, sy);
								ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
								ctx.scale(1/sx, 1/sy);
								ctx.rotate(-xAxisRotation);
								ctx.translate(-centp.x, -centp.y);
							}
						}
						break;
					case 'Z':
					case 'z':
						if (ctx != null) ctx.closePath();
						pp.current = pp.start;
					}
				}

				return bb;
			}

			this.getMarkers = function() {
				var points = this.PathParser.getMarkerPoints();
				var angles = this.PathParser.getMarkerAngles();

				var markers = [];
				for (var i=0; i<points.length; i++) {
					markers.push([points[i], angles[i]]);
				}
				return markers;
			}
		}
		svg.Element.path.prototype = new svg.Element.PathElementBase;

		// pattern element
		svg.Element.pattern = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.createPattern = function(ctx, element) {
				var width = this.attribute('width').toPixels('x', true);
				var height = this.attribute('height').toPixels('y', true);

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
				tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
				tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
				tempSvg.children = this.children;

				var c = document.createElement('canvas');
				c.width = width;
				c.height = height;
				var cctx = c.getContext('2d');
				if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
					cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
				}
				// render 3x3 grid so when we transform there's no white space on edges
				for (var x=-1; x<=1; x++) {
					for (var y=-1; y<=1; y++) {
						cctx.save();
						tempSvg.attributes['x'] = new svg.Property('x', x * c.width);
						tempSvg.attributes['y'] = new svg.Property('y', y * c.height);
						tempSvg.render(cctx);
						cctx.restore();
					}
				}
				var pattern = ctx.createPattern(c, 'repeat');
				return pattern;
			}
		}
		svg.Element.pattern.prototype = new svg.Element.ElementBase;

		// marker element
		svg.Element.marker = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.baseRender = this.render;
			this.render = function(ctx, point, angle) {
				ctx.translate(point.x, point.y);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
				ctx.save();

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
				tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
				tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
				tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
				tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
				tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
				tempSvg.children = this.children;
				tempSvg.render(ctx);

				ctx.restore();
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
				ctx.translate(-point.x, -point.y);
			}
		}
		svg.Element.marker.prototype = new svg.Element.ElementBase;

		// definitions element
		svg.Element.defs = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NOOP
			}
		}
		svg.Element.defs.prototype = new svg.Element.ElementBase;

		// base for gradients
		svg.Element.GradientBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.stops = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'stop') this.stops.push(child);
			}

			this.getGradient = function() {
				// OVERRIDE ME!
			}
			
			this.gradientUnits = function () {
				return this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
			}
			
			this.attributesToInherit = ['gradientUnits'];
			
			this.inheritStopContainer = function (stopsContainer) {
				for (var i=0; i<this.attributesToInherit.length; i++) {
					var attributeToInherit = this.attributesToInherit[i];
					if (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {
						this.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;
					}
				}
			}

			this.createGradient = function(ctx, element, parentOpacityProp) {
				var stopsContainer = this;
				if (this.getHrefAttribute().hasValue()) {
					stopsContainer = this.getHrefAttribute().getDefinition();
					this.inheritStopContainer(stopsContainer);
				}

				var addParentOpacity = function (color) {
					if (parentOpacityProp.hasValue()) {
						var p = new svg.Property('color', color);
						return p.addOpacity(parentOpacityProp).value;
					}
					return color;
				};

				var g = this.getGradient(ctx, element);
				if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
				for (var i=0; i<stopsContainer.stops.length; i++) {
					g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
				}

				if (this.attribute('gradientTransform').hasValue()) {
					// render as transformed pattern on temporary canvas
					var rootView = svg.ViewPort.viewPorts[0];

					var rect = new svg.Element.rect();
					rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
					rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);

					var group = new svg.Element.g();
					group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
					group.children = [ rect ];

					var tempSvg = new svg.Element.svg();
					tempSvg.attributes['x'] = new svg.Property('x', 0);
					tempSvg.attributes['y'] = new svg.Property('y', 0);
					tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
					tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
					tempSvg.children = [ group ];

					var c = document.createElement('canvas');
					c.width = rootView.width;
					c.height = rootView.height;
					var tempCtx = c.getContext('2d');
					tempCtx.fillStyle = g;
					tempSvg.render(tempCtx);
					return tempCtx.createPattern(c, 'no-repeat');
				}

				return g;
			}
		}
		svg.Element.GradientBase.prototype = new svg.Element.ElementBase;

		// linear gradient element
		svg.Element.linearGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('x1');
			this.attributesToInherit.push('y1');
			this.attributesToInherit.push('x2');
			this.attributesToInherit.push('y2');

			this.getGradient = function(ctx, element) {
				var bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;

				if (!this.attribute('x1').hasValue()
				 && !this.attribute('y1').hasValue()
				 && !this.attribute('x2').hasValue()
				 && !this.attribute('y2').hasValue()) {
					this.attribute('x1', true).value = 0;
					this.attribute('y1', true).value = 0;
					this.attribute('x2', true).value = 1;
					this.attribute('y2', true).value = 0;
				 }

				var x1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x1').numValue()
					: this.attribute('x1').toPixels('x'));
				var y1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y1').numValue()
					: this.attribute('y1').toPixels('y'));
				var x2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x2').numValue()
					: this.attribute('x2').toPixels('x'));
				var y2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y2').numValue()
					: this.attribute('y2').toPixels('y'));

				if (x1 == x2 && y1 == y2) return null;
				return ctx.createLinearGradient(x1, y1, x2, y2);
			}
		}
		svg.Element.linearGradient.prototype = new svg.Element.GradientBase;

		// radial gradient element
		svg.Element.radialGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('cx');
			this.attributesToInherit.push('cy');
			this.attributesToInherit.push('r');
			this.attributesToInherit.push('fx');
			this.attributesToInherit.push('fy');

			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();

				if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
				if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
				if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';

				var cx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('cx').numValue()
					: this.attribute('cx').toPixels('x'));
				var cy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('cy').numValue()
					: this.attribute('cy').toPixels('y'));

				var fx = cx;
				var fy = cy;
				if (this.attribute('fx').hasValue()) {
					fx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('fx').numValue()
					: this.attribute('fx').toPixels('x'));
				}
				if (this.attribute('fy').hasValue()) {
					fy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('fy').numValue()
					: this.attribute('fy').toPixels('y'));
				}

				var r = (this.gradientUnits() == 'objectBoundingBox'
					? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
					: this.attribute('r').toPixels());

				return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
			}
		}
		svg.Element.radialGradient.prototype = new svg.Element.GradientBase;

		// gradient stop element
		svg.Element.stop = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.offset = this.attribute('offset').numValue();
			if (this.offset < 0) this.offset = 0;
			if (this.offset > 1) this.offset = 1;

			var stopColor = this.style('stop-color', true);
			if (stopColor.value === '') stopColor.value = '#000';
			if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
			this.color = stopColor.value;
		}
		svg.Element.stop.prototype = new svg.Element.ElementBase;

		// animation base element
		svg.Element.AnimateBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			svg.Animations.push(this);

			this.duration = 0.0;
			this.begin = this.attribute('begin').toMilliseconds();
			this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();

			this.getProperty = function() {
				var attributeType = this.attribute('attributeType').value;
				var attributeName = this.attribute('attributeName').value;

				if (attributeType == 'CSS') {
					return this.parent.style(attributeName, true);
				}
				return this.parent.attribute(attributeName, true);
			};

			this.initialValue = null;
			this.initialUnits = '';
			this.removed = false;

			this.calcValue = function() {
				// OVERRIDE ME!
				return '';
			}

			this.update = function(delta) {
				// set initial value
				if (this.initialValue == null) {
					this.initialValue = this.getProperty().value;
					this.initialUnits = this.getProperty().getUnits();
				}

				// if we're past the end time
				if (this.duration > this.maxDuration) {
					// loop for indefinitely repeating animations
					if (this.attribute('repeatCount').value == 'indefinite'
					 || this.attribute('repeatDur').value == 'indefinite') {
						this.duration = 0.0
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
						this.frozen = true;
						this.parent.animationFrozen = true;
						this.parent.animationFrozenValue = this.getProperty().value;
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
						this.removed = true;
						this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
						return true;
					}
					return false;
				}
				this.duration = this.duration + delta;

				// if we're past the begin time
				var updated = false;
				if (this.begin < this.duration) {
					var newValue = this.calcValue(); // tween

					if (this.attribute('type').hasValue()) {
						// for transform, etc.
						var type = this.attribute('type').value;
						newValue = type + '(' + newValue + ')';
					}

					this.getProperty().value = newValue;
					updated = true;
				}

				return updated;
			}

			this.from = this.attribute('from');
			this.to = this.attribute('to');
			this.values = this.attribute('values');
			if (this.values.hasValue()) this.values.value = this.values.value.split(';');

			// fraction of duration we've covered
			this.progress = function() {
				var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
				if (this.values.hasValue()) {
					var p = ret.progress * (this.values.value.length - 1);
					var lb = Math.floor(p), ub = Math.ceil(p);
					ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
					ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
					ret.progress = (p - lb) / (ub - lb);
				}
				else {
					ret.from = this.from;
					ret.to = this.to;
				}
				return ret;
			}
		}
		svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;

		// animate element
		svg.Element.animate = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
				return newValue + this.initialUnits;
			};
		}
		svg.Element.animate.prototype = new svg.Element.AnimateBase;

		// animate color element
		svg.Element.animateColor = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();
				var from = new RGBColor(p.from.value);
				var to = new RGBColor(p.to.value);

				if (from.ok && to.ok) {
					// tween color linearly
					var r = from.r + (to.r - from.r) * p.progress;
					var g = from.g + (to.g - from.g) * p.progress;
					var b = from.b + (to.b - from.b) * p.progress;
					return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
				}
				return this.attribute('from').value;
			};
		}
		svg.Element.animateColor.prototype = new svg.Element.AnimateBase;

		// animate transform element
		svg.Element.animateTransform = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var from = svg.ToNumberArray(p.from.value);
				var to = svg.ToNumberArray(p.to.value);
				var newValue = '';
				for (var i=0; i<from.length; i++) {
					newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
				}
				return newValue;
			};
		}
		svg.Element.animateTransform.prototype = new svg.Element.animate;

		// font element
		svg.Element.font = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();

			this.isRTL = false;
			this.isArabic = false;
			this.fontFace = null;
			this.missingGlyph = null;
			this.glyphs = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'font-face') {
					this.fontFace = child;
					if (child.style('font-family').hasValue()) {
						svg.Definitions[child.style('font-family').value] = this;
					}
				}
				else if (child.type == 'missing-glyph') this.missingGlyph = child;
				else if (child.type == 'glyph') {
					if (child.arabicForm != '') {
						this.isRTL = true;
						this.isArabic = true;
						if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
						this.glyphs[child.unicode][child.arabicForm] = child;
					}
					else {
						this.glyphs[child.unicode] = child;
					}
				}
			}
		}
		svg.Element.font.prototype = new svg.Element.ElementBase;

		// font-face element
		svg.Element.fontface = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.ascent = this.attribute('ascent').value;
			this.descent = this.attribute('descent').value;
			this.unitsPerEm = this.attribute('units-per-em').numValue();
		}
		svg.Element.fontface.prototype = new svg.Element.ElementBase;

		// missing-glyph element
		svg.Element.missingglyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = 0;
		}
		svg.Element.missingglyph.prototype = new svg.Element.path;

		// glyph element
		svg.Element.glyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();
			this.unicode = this.attribute('unicode').value;
			this.arabicForm = this.attribute('arabic-form').value;
		}
		svg.Element.glyph.prototype = new svg.Element.path;

		// text element
		svg.Element.text = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);

				var textBaseline = this.style('dominant-baseline').toTextBaseline();
				if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
				if (textBaseline != null) ctx.textBaseline = textBaseline;
			}

			this.getBoundingBox = function () {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
				return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
			}

			this.renderChildren = function(ctx) {
				this.x = this.attribute('x').toPixels('x');
				this.y = this.attribute('y').toPixels('y');
				if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
				if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
				this.x += this.getAnchorDelta(ctx, this, 0);
				for (var i=0; i<this.children.length; i++) {
					this.renderChild(ctx, this, i);
				}
			}

			this.getAnchorDelta = function (ctx, parent, startI) {
				var textAnchor = this.style('text-anchor').valueOrDefault('start');
				if (textAnchor != 'start') {
					var width = 0;
					for (var i=startI; i<parent.children.length; i++) {
						var child = parent.children[i];
						if (i > startI && child.attribute('x').hasValue()) break; // new group
						width += child.measureTextRecursive(ctx);
					}
					return -1 * (textAnchor == 'end' ? width : width / 2.0);
				}
				return 0;
			}

			this.renderChild = function(ctx, parent, i) {
				var child = parent.children[i];
				if (child.attribute('x').hasValue()) {
					child.x = child.attribute('x').toPixels('x') + parent.getAnchorDelta(ctx, parent, i);
					if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
				}
				else {
					if (child.attribute('dx').hasValue()) parent.x += child.attribute('dx').toPixels('x');
					child.x = parent.x;
				}
				parent.x = child.x + child.measureText(ctx);

				if (child.attribute('y').hasValue()) {
					child.y = child.attribute('y').toPixels('y');
					if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
				}
				else {
					if (child.attribute('dy').hasValue()) parent.y += child.attribute('dy').toPixels('y');
					child.y = parent.y;
				}
				parent.y = child.y;

				child.render(ctx);

				for (var i=0; i<child.children.length; i++) {
					parent.renderChild(ctx, child, i);
				}
			}
		}
		svg.Element.text.prototype = new svg.Element.RenderedElementBase;

		// text base
		svg.Element.TextElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getGlyph = function(font, text, i) {
				var c = text[i];
				var glyph = null;
				if (font.isArabic) {
					var arabicForm = 'isolated';
					if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';
					if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
					if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
					if (typeof(font.glyphs[c]) != 'undefined') {
						glyph = font.glyphs[c][arabicForm];
						if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
					}
				}
				else {
					glyph = font.glyphs[c];
				}
				if (glyph == null) glyph = font.missingGlyph;
				return glyph;
			}

			this.renderChildren = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");

					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						var scale = fontSize / customFont.fontFace.unitsPerEm;
						ctx.translate(this.x, this.y);
						ctx.scale(scale, -scale);
						var lw = ctx.lineWidth;
						ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
						if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
						glyph.render(ctx);
						if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
						ctx.lineWidth = lw;
						ctx.scale(1/scale, -1/scale);
						ctx.translate(-this.x, -this.y);

						this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							this.x += dx[i];
						}
					}
					return;
				}

				if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
				if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
			}

			this.getText = function() {
				// OVERRIDE ME
			}

			this.measureTextRecursive = function(ctx) {
				var width = this.measureText(ctx);
				for (var i=0; i<this.children.length; i++) {
					width += this.children[i].measureTextRecursive(ctx);
				}
				return width;
			}

			this.measureText = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var measure = 0;
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							measure += dx[i];
						}
					}
					return measure;
				}

				var textToMeasure = svg.compressSpaces(this.getText());
				if (!ctx.measureText) return textToMeasure.length * 10;

				ctx.save();
				this.setContext(ctx);
				var width = ctx.measureText(textToMeasure).width;
				ctx.restore();
				return width;
			}
		}
		svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

		// tspan
		svg.Element.tspan = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.text = svg.compressSpaces(node.value || node.text || node.textContent || '');
			this.getText = function() {
				// if this node has children, then they own the text
				if (this.children.length > 0) { return ''; }
				return this.text;
			}
		}
		svg.Element.tspan.prototype = new svg.Element.TextElementBase;

		// tref
		svg.Element.tref = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.getText = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (element != null) return element.children[0].getText();
			}
		}
		svg.Element.tref.prototype = new svg.Element.TextElementBase;

		// a element
		svg.Element.a = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.hasText = node.childNodes.length > 0;
			for (var i=0; i<node.childNodes.length; i++) {
				if (node.childNodes[i].nodeType != 3) this.hasText = false;
			}

			// this might contain text
			this.text = this.hasText ? node.childNodes[0].value : '';
			this.getText = function() {
				return this.text;
			}

			this.baseRenderChildren = this.renderChildren;
			this.renderChildren = function(ctx) {
				if (this.hasText) {
					// render as text element
					this.baseRenderChildren(ctx);
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
				}
				else if (this.children.length > 0) {
					// render as temporary group
					var g = new svg.Element.g();
					g.children = this.children;
					g.parent = this;
					g.render(ctx);
				}
			}

			this.onclick = function() {
				window.open(this.getHrefAttribute().value);
			}

			this.onmousemove = function() {
				svg.ctx.canvas.style.cursor = 'pointer';
			}
		}
		svg.Element.a.prototype = new svg.Element.TextElementBase;

		// image element
		svg.Element.image = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			var href = this.getHrefAttribute().value;
			if (href == '') { return; }
			var isSvg = href.match(/\.svg$/)

			svg.Images.push(this);
			this.loaded = false;
			if (!isSvg) {
				this.img = document.createElement('img');
				if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
				var self = this;
				this.img.onload = function() { self.loaded = true; }
				this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
				this.img.src = href;
			}
			else {
				this.img = svg.ajax(href);
				this.loaded = true;
			}

			this.renderChildren = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');

				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				if (width == 0 || height == 0) return;

				ctx.save();
				if (isSvg) {
					ctx.drawSvg(this.img, x, y, width, height);
				}
				else {
					ctx.translate(x, y);
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									width,
									this.img.width,
									height,
									this.img.height,
									0,
									0);
					ctx.drawImage(this.img, 0, 0);
				}
				ctx.restore();
			}

			this.getBoundingBox = function() {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.image.prototype = new svg.Element.RenderedElementBase;

		// group element
		svg.Element.g = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getBoundingBox = function() {
				var bb = new svg.BoundingBox();
				for (var i=0; i<this.children.length; i++) {
					bb.addBoundingBox(this.children[i].getBoundingBox());
				}
				return bb;
			};
		}
		svg.Element.g.prototype = new svg.Element.RenderedElementBase;

		// symbol element
		svg.Element.symbol = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NO RENDER
			};
		}
		svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;

		// style element
		svg.Element.style = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			// text, or spaces then CDATA
			var css = ''
			for (var i=0; i<node.childNodes.length; i++) {
			  css += node.childNodes[i].data;
			}
			css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
			css = svg.compressSpaces(css); // replace whitespace
			var cssDefs = css.split('}');
			for (var i=0; i<cssDefs.length; i++) {
				if (svg.trim(cssDefs[i]) != '') {
					var cssDef = cssDefs[i].split('{');
					var cssClasses = cssDef[0].split(',');
					var cssProps = cssDef[1].split(';');
					for (var j=0; j<cssClasses.length; j++) {
						var cssClass = svg.trim(cssClasses[j]);
						if (cssClass != '') {
							var props = svg.Styles[cssClass] || {};
							for (var k=0; k<cssProps.length; k++) {
								var prop = cssProps[k].indexOf(':');
								var name = cssProps[k].substr(0, prop);
								var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
								if (name != null && value != null) {
									props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
								}
							}
							svg.Styles[cssClass] = props;
							svg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
							if (cssClass == '@font-face') {
								var fontFamily = props['font-family'].value.replace(/"/g,'');
								var srcs = props['src'].value.split(',');
								for (var s=0; s<srcs.length; s++) {
									if (srcs[s].indexOf('format("svg")') > 0) {
										var urlStart = srcs[s].indexOf('url');
										var urlEnd = srcs[s].indexOf(')', urlStart);
										var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
										var doc = svg.parseXml(svg.ajax(url));
										var fonts = doc.getElementsByTagName('font');
										for (var f=0; f<fonts.length; f++) {
											var font = svg.CreateElement(fonts[f]);
											svg.Definitions[fontFamily] = font;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		svg.Element.style.prototype = new svg.Element.ElementBase;

		// use element
		svg.Element.use = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
				if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
			}

			var element = this.getHrefAttribute().getDefinition();

			this.path = function(ctx) {
				if (element != null) element.path(ctx);
			}

			this.getBoundingBox = function() {
				if (element != null) return element.getBoundingBox();
			}

			this.renderChildren = function(ctx) {
				if (element != null) {
					var tempSvg = element;
					if (element.type == 'symbol') {
						// render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
						tempSvg = new svg.Element.svg();
						tempSvg.type = 'svg';
						tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
						tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
						tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
						tempSvg.children = element.children;
					}
					if (tempSvg.type == 'svg') {
						// if symbol or svg, inherit width/height from me
						if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
						if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
					}
					var oldParent = tempSvg.parent;
					tempSvg.parent = null;
					tempSvg.render(ctx);
					tempSvg.parent = oldParent;
				}
			}
		}
		svg.Element.use.prototype = new svg.Element.RenderedElementBase;

		// mask element
		svg.Element.mask = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');

				if (width == 0 && height == 0) {
					var bb = new svg.BoundingBox();
					for (var i=0; i<this.children.length; i++) {
						bb.addBoundingBox(this.children[i].getBoundingBox());
					}
					var x = Math.floor(bb.x1);
					var y = Math.floor(bb.y1);
					var width = Math.floor(bb.width());
					var	height = Math.floor(bb.height());
				}

				// temporarily remove mask to avoid recursion
				var mask = element.attribute('mask').value;
				element.attribute('mask').value = '';

					var cMask = document.createElement('canvas');
					cMask.width = x + width;
					cMask.height = y + height;
					var maskCtx = cMask.getContext('2d');
					this.renderChildren(maskCtx);

					var c = document.createElement('canvas');
					c.width = x + width;
					c.height = y + height;
					var tempCtx = c.getContext('2d');
					element.render(tempCtx);
					tempCtx.globalCompositeOperation = 'destination-in';
					tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
					tempCtx.fillRect(0, 0, x + width, y + height);

					ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
					ctx.fillRect(0, 0, x + width, y + height);

				// reassign mask
				element.attribute('mask').value = mask;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.mask.prototype = new svg.Element.ElementBase;

		// clip element
		svg.Element.clipPath = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx) {
				var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
				CanvasRenderingContext2D.prototype.beginPath = function () { };

				var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
				CanvasRenderingContext2D.prototype.closePath = function () { };

				oldBeginPath.call(ctx);
				for (var i=0; i<this.children.length; i++) {
					var child = this.children[i];
					if (typeof(child.path) != 'undefined') {
						var transform = null;
						if (child.style('transform', false, true).hasValue()) {
							transform = new svg.Transform(child.style('transform', false, true).value);
							transform.apply(ctx);
						}
						child.path(ctx);
						CanvasRenderingContext2D.prototype.closePath = oldClosePath;
						if (transform) { transform.unapply(ctx); }
					}
				}
				oldClosePath.call(ctx);
				ctx.clip();

				CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
				CanvasRenderingContext2D.prototype.closePath = oldClosePath;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.clipPath.prototype = new svg.Element.ElementBase;

		// filters
		svg.Element.filter = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var bb = element.getBoundingBox();
				var x = Math.floor(bb.x1);
				var y = Math.floor(bb.y1);
				var width = Math.floor(bb.width());
				var	height = Math.floor(bb.height());

				// temporarily remove filter to avoid recursion
				var filter = element.style('filter').value;
				element.style('filter').value = '';

				var px = 0, py = 0;
				for (var i=0; i<this.children.length; i++) {
					var efd = this.children[i].extraFilterDistance || 0;
					px = Math.max(px, efd);
					py = Math.max(py, efd);
				}

				var c = document.createElement('canvas');
				c.width = width + 2*px;
				c.height = height + 2*py;
				var tempCtx = c.getContext('2d');
				tempCtx.translate(-x + px, -y + py);
				element.render(tempCtx);

				// apply filters
				for (var i=0; i<this.children.length; i++) {
					if (typeof(this.children[i].apply) === 'function') {
						this.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);
					}
				}

				// render on me
				ctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);

				// reassign filter
				element.style('filter', true).value = filter;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.filter.prototype = new svg.Element.ElementBase;

		svg.Element.feMorphology = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feMorphology.prototype = new svg.Element.ElementBase;

		svg.Element.feComposite = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feComposite.prototype = new svg.Element.ElementBase;

		svg.Element.feColorMatrix = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			var matrix = svg.ToNumberArray(this.attribute('values').value);
			switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
				case 'saturate':
					var s = matrix[0];
					matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'hueRotate':
					var a = matrix[0] * Math.PI / 180.0;
					var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
					matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
							  c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
							  c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'luminanceToAlpha':
					matrix = [0,0,0,0,0,
							  0,0,0,0,0,
							  0,0,0,0,0,
							  0.2125,0.7154,0.0721,0,0,
							  0,0,0,0,1];
					break;
			}

			function imGet(img, x, y, width, height, rgba) {
				return img[y*width*4 + x*4 + rgba];
			}

			function imSet(img, x, y, width, height, rgba, val) {
				img[y*width*4 + x*4 + rgba] = val;
			}

			function m(i, v) {
				var mi = matrix[i];
				return mi * (mi < 0 ? v - 255 : v);
			}

			this.apply = function(ctx, x, y, width, height) {
				// assuming x==0 && y==0 for now
				var srcData = ctx.getImageData(0, 0, width, height);
				for (var y = 0; y < height; y++) {
					for (var x = 0; x < width; x++) {
						var r = imGet(srcData.data, x, y, width, height, 0);
						var g = imGet(srcData.data, x, y, width, height, 1);
						var b = imGet(srcData.data, x, y, width, height, 2);
						var a = imGet(srcData.data, x, y, width, height, 3);
						imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
						imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
						imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
						imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
					}
				}
				ctx.clearRect(0, 0, width, height);
				ctx.putImageData(srcData, 0, 0);
			}
		}
		svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;

		svg.Element.feGaussianBlur = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
			this.extraFilterDistance = this.blurRadius;

			this.apply = function(ctx, x, y, width, height) {
				if (typeof(stackBlur.canvasRGBA) == 'undefined') {
					svg.log('ERROR: StackBlur.js must be included for blur to work');
					return;
				}

				// StackBlur requires canvas be on document
				ctx.canvas.id = svg.UniqueId();
				ctx.canvas.style.display = 'none';
				document.body.appendChild(ctx.canvas);
				stackBlur.canvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
				document.body.removeChild(ctx.canvas);
			}
		}
		svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;

		// title element, do nothing
		svg.Element.title = function(node) {
		}
		svg.Element.title.prototype = new svg.Element.ElementBase;

		// desc element, do nothing
		svg.Element.desc = function(node) {
		}
		svg.Element.desc.prototype = new svg.Element.ElementBase;

		svg.Element.MISSING = function(node) {
			svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
		}
		svg.Element.MISSING.prototype = new svg.Element.ElementBase;

		// element factory
		svg.CreateElement = function(node) {
			var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
			className = className.replace(/\-/g,''); // remove dashes
			var e = null;
			if (typeof(svg.Element[className]) != 'undefined') {
				e = new svg.Element[className](node);
			}
			else {
				e = new svg.Element.MISSING(node);
			}

			e.type = node.nodeName;
			return e;
		}

		// load from url
		svg.load = function(ctx, url) {
			svg.loadXml(ctx, svg.ajax(url));
		}

		// load from xml
		svg.loadXml = function(ctx, xml) {
			svg.loadXmlDoc(ctx, svg.parseXml(xml));
		}

		svg.loadXmlDoc = function(ctx, dom) {
			svg.init(ctx);

			var mapXY = function(p) {
				var e = ctx.canvas;
				while (e) {
					p.x -= e.offsetLeft;
					p.y -= e.offsetTop;
					e = e.offsetParent;
				}
				if (window.scrollX) p.x += window.scrollX;
				if (window.scrollY) p.y += window.scrollY;
				return p;
			}

			// bind mouse
			if (svg.opts['ignoreMouse'] != true) {
				ctx.canvas.onclick = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onclick(p.x, p.y);
				};
				ctx.canvas.onmousemove = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onmousemove(p.x, p.y);
				};
			}

			var e = svg.CreateElement(dom.documentElement);
			e.root = true;
			e.addStylesFromStyleDefinition();

			// render loop
			var isFirstRender = true;
			var draw = function() {
				svg.ViewPort.Clear();
				if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);

				if (svg.opts['ignoreDimensions'] != true) {
					// set canvas size
					if (e.style('width').hasValue()) {
						ctx.canvas.width = e.style('width').toPixels('x');
						ctx.canvas.style.width = ctx.canvas.width + 'px';
					}
					if (e.style('height').hasValue()) {
						ctx.canvas.height = e.style('height').toPixels('y');
						ctx.canvas.style.height = ctx.canvas.height + 'px';
					}
				}
				var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
				var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
				if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
					cWidth = e.style('width').toPixels('x');
					cHeight = e.style('height').toPixels('y');
				}
				svg.ViewPort.SetCurrent(cWidth, cHeight);

				if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
				if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
				if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
					var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);

					if (svg.opts['scaleWidth'] != null) {
						if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
						else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
					}

					if (svg.opts['scaleHeight'] != null) {
						if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
						else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
					}

					if (xRatio == null) { xRatio = yRatio; }
					if (yRatio == null) { yRatio = xRatio; }

					e.attribute('width', true).value = svg.opts['scaleWidth'];
					e.attribute('height', true).value = svg.opts['scaleHeight'];
					e.style('transform', true, true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
				}

				// clear and render
				if (svg.opts['ignoreClear'] != true) {
					ctx.clearRect(0, 0, cWidth, cHeight);
				}
				e.render(ctx);
				if (isFirstRender) {
					isFirstRender = false;
					if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
				}
			}

			var waitingForImages = true;
			if (svg.ImagesLoaded()) {
				waitingForImages = false;
				draw();
			}
			svg.intervalID = setInterval(function() {
				var needUpdate = false;

				if (waitingForImages && svg.ImagesLoaded()) {
					waitingForImages = false;
					needUpdate = true;
				}

				// need update from mouse events?
				if (svg.opts['ignoreMouse'] != true) {
					needUpdate = needUpdate | svg.Mouse.hasEvents();
				}

				// need update from animations?
				if (svg.opts['ignoreAnimation'] != true) {
					for (var i=0; i<svg.Animations.length; i++) {
						needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
					}
				}

				// need update from redraw?
				if (typeof(svg.opts['forceRedraw']) == 'function') {
					if (svg.opts['forceRedraw']() == true) needUpdate = true;
				}

				// render if needed
				if (needUpdate) {
					draw();
					svg.Mouse.runEvents(); // run and clear our events
				}
			}, 1000 / svg.FRAMERATE);
		}

		svg.stop = function() {
			if (svg.intervalID) {
				clearInterval(svg.intervalID);
			}
		}

		svg.Mouse = new (function() {
			this.events = [];
			this.hasEvents = function() { return this.events.length != 0; }

			this.onclick = function(x, y) {
				this.events.push({ type: 'onclick', x: x, y: y,
					run: function(e) { if (e.onclick) e.onclick(); }
				});
			}

			this.onmousemove = function(x, y) {
				this.events.push({ type: 'onmousemove', x: x, y: y,
					run: function(e) { if (e.onmousemove) e.onmousemove(); }
				});
			}

			this.eventElements = [];

			this.checkPath = function(element, ctx) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.checkBoundingBox = function(element, bb) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.runEvents = function() {
				svg.ctx.canvas.style.cursor = '';

				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					var element = this.eventElements[i];
					while (element) {
						e.run(element);
						element = element.parent;
					}
				}

				// done running, clear
				this.events = [];
				this.eventElements = [];
			}
		});

		return svg;
	};

	if (typeof(CanvasRenderingContext2D) != 'undefined') {
		CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
			canvg(this.canvas, s, {
				ignoreMouse: true,
				ignoreAnimation: true,
				ignoreDimensions: true,
				ignoreClear: true,
				offsetX: dx,
				offsetY: dy,
				scaleWidth: dw,
				scaleHeight: dh
			});
		}
	}

	return canvg;

}));

define('js/printing',["require", "exports", "./surveyCollection", "./storyCardDisplay", "./Globals", "mithril", "./sanitizeHTML", "./applicationWidgets/PatternExplorer", "./applicationWidgets/ClusteringDiagram", "./applicationWidgets/charting", "./panelBuilder/dialogSupport", "canvgModule"], function (require, exports, surveyCollection, storyCardDisplay, Globals, m, sanitizeHTML, PatternExplorer, ClusteringDiagram, charting, dialogSupport, canvg) {
    "use strict";
    // TODO: Translate
    // why are all of the bar graphs and histograms being drawn with a left axis color of #C26E00
    // when this never appears in the code? might be a canvg thing?
    // TODO: Rules should be read from loaded stylesheet
    var graphResultsPaneCSS = "\n    .narrafirma-graph-results-pane {\n        width: 850px;\n        margin: 5px auto 0px auto;\n    }\n    \n    .chartBackground {\n        width: 700px;\n        fill: none;\n    }\n    \n    .chartBodyBackground {\n        fill: none;\n    }\n    \n    .chart {\n        background-color: white;\n    }\n    \n    .bar {\n      fill: none;\n    }\n    \n    .x-axis {\n        fill: none;\n        stroke: #231f20;\n        stroke-width: 1px;\n        shape-rendering: crispEdges;    \n    }\n    \n    .y-axis {\n        fill: none;\n        stroke: #231f20;\n        stroke-width: 1px;\n        shape-rendering: crispEdges;    \n    }\n    \n    .x-axis text {\n        fill: #231f20;\n        stroke-width: 0.5px;\n        font-family: sans-serif;\n        font-size: 1.2em;\n    }\n    \n    .y-axis text {\n        fill: #231f20;\n        stroke-width: 0.5px;\n        font-family: sans-serif;\n        font-size: 1.2em;\n    }\n    \n    .x-axis-label {\n        fill: #231f20;\n        stroke-width: 0.5px;\n        font-family: sans-serif;\n        font-size: 1.4em;\n    }\n    \n    .y-axis-label {\n        fill: #231f20;\n        stroke-width: 0.5px;\n        font-family: sans-serif;\n        font-size: 1.4em;\n    }\n    \n    .story.even {\n      fill: #2e4a85;\n    }\n    \n    .story.odd {\n      fill: #7b8cb2;\n    }\n    \n    .brush .extent {\n      fill-opacity: 0.3;\n      fill: #ff7d00;\n      stroke: #cc6400;\n      stroke-width: 1px;\n      shape-rendering: auto; /* was crispEdges; auto turns on anti-aliasing */\n    }\n    \n    .histogram-mean {\n        stroke: red;\n        stroke-width: 2px;\n    }\n    \n    .histogram-standard-deviation-low {\n        stroke: #8db500;\n        stroke-width: 1.5px;\n    }\n    \n    .histogram-standard-deviation-high {\n        stroke: #8db500;    \n        stroke-width: 1.5px;\n    }\n    \n    .scatterPlot .story {\n      stroke: #2e4a85;\n      stroke-width: 0.2px;\n      fill: #2e4a85;\n      fill-opacity: 0.7;\n    }\n    \n    .contingencyChart .storyCluster.observed {\n      stroke-width: 3px;\n      stroke: #2e4a85;\n      fill: #d5dae6;\n    }\n    \n    .contingencyChart .expected {\n      stroke-width: 1px;\n      stroke: #8e8789;\n      stroke-dasharray: \"5,5\";\n      fill: none;\n    }\n    \n    .contingencyChart .axis path {\n      display: none;\n    }\n    \n    .contingencyChart .axis line {\n      shape-rendering: crispEdges;\n      stroke: gray;\n    }\n";
    function printHTML(htmlToPrint) {
        // Display HTML in a new window
        // onsole.log("printHTML", htmlToPrint);
        var w = window.open();
        w.document.write(htmlToPrint);
        w.document.close();
        // w.print();
        // w.close();
    }
    function generateHTMLForPage(title, stylesheetReference, vdom) {
        var output = "";
        output += "<!DOCTYPE html>\n";
        output += "<head>\n";
        output += "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n";
        output += "<title>" + escapeHtml(title) + "</title>\n";
        if (stylesheetReference) {
            output += "<link rel=\"stylesheet\" href=\"" + stylesheetReference + "\">\n";
        }
        output += "</head>\n\n";
        output += "<body>\n";
        output += htmlForMithril(vdom);
        output += "\n</body>\n</html>";
        return output;
    }
    function htmlForMithril(vdom) {
        // Convert Mithril vdom objects to HTML
        var temporaryDiv = document.createElement('div');
        m.render(temporaryDiv, vdom);
        return temporaryDiv.innerHTML;
    }
    // escapeHtml from: http://shebang.brandonmintern.com/foolproof-html-escaping-in-javascript/
    function escapeHtml(str) {
        var div = document.createElement('div');
        div.appendChild(document.createTextNode(str));
        return div.innerHTML;
    }
    ;
    function repeatTags(count, tags) {
        var result = [];
        for (var i = 0; i < count; i++) {
            result.push(tags);
        }
        return result;
    }
    function printText(text) {
        return sanitizeHTML.generateSanitizedHTMLForMithril(text);
    }
    function printReturn() {
        return [
            m("br"),
            "\n"
        ];
    }
    function printReturnAndBlankLine() {
        return [
            printReturn(),
            printReturn()
        ];
    }
    function printCheckbox(text) {
        return m("div.narrafirma-survey-print-checkbox", [
            "[ ] ",
            printText(text),
            "\n"
        ]);
    }
    function printOption(text) {
        return m("div.narrafirma-survey-print-radiobutton", [
            "( ) ",
            printText(text),
            "\n"
        ]);
    }
    function printQuestionText(question, instructions) {
        if (instructions === void 0) { instructions = ""; }
        var questionTextForPrinting = printText(question.displayPrompt);
        if (question.displayType === "header") {
            questionTextForPrinting = m("b", questionTextForPrinting);
        }
        if (instructions)
            instructions = " (" + instructions + ")";
        return m("div.narrafirma-survey-print-question-text", [
            questionTextForPrinting,
            m("span.narrafirma-survey-print-instruction", instructions)
        ]);
    }
    // TODO: Translate
    function printQuestion(question) {
        // console.log("printQuestion", question.displayType, question);
        var result;
        switch (question.displayType) {
            case "boolean":
                result = [
                    printQuestionText(question, "Choose only one"),
                    printOption("yes"),
                    printOption("no")
                ];
                break;
            case "label":
                result = [
                    printQuestionText(question),
                ];
                break;
            case "header":
                result = [
                    printQuestionText(question),
                ];
                break;
            case "checkbox":
                result = [
                    printQuestionText(question),
                    printCheckbox("yes")
                ];
                break;
            case "checkboxes":
                result = [
                    printQuestionText(question, "Choose any combination"),
                    question.valueOptions.map(function (option, index) {
                        return printCheckbox(option);
                    })
                ];
                break;
            case "text":
                result = [
                    printQuestionText(question),
                    m("div.narrafirma-survey-print-blank-text-line", "_________________________________________________________________________")
                ];
                break;
            case "textarea":
                result = [
                    printQuestionText(question),
                    m("div.narrafirma-survey-print-textarea", printReturnAndBlankLine())
                ];
                break;
            case "select":
                result = [
                    printQuestionText(question, "Choose only one"),
                    question.valueOptions.map(function (option, index) {
                        return printOption(option);
                    })
                ];
                break;
            case "radiobuttons":
                result = [
                    printQuestionText(question, "Choose only one"),
                    question.valueOptions.map(function (option, index) {
                        return printOption(option);
                    })
                ];
                break;
            case "slider":
                result = [
                    printQuestionText(question, "Mark on the line"),
                    m("div.narrafirma-survey-print-slider", [
                        question.displayConfiguration[0],
                        " -------------------------------------------------- ",
                        question.displayConfiguration[1]])
                ];
                break;
        }
        return result;
    }
    function generateHTMLForQuestionnaire(questionnaire) {
        // TODO: Translate
        var vdom = m(".narrafirma-questionnaire-for-printing", [
            "\n",
            m("div.narrafirma-survey-print-title", printText(questionnaire.title)),
            m("div.narrafirma-survey-print-intro", printText(questionnaire.startText)),
            m("div.narrafirma-survey-print-please-select", "Please select one of the following questions to answer:"),
            questionnaire.elicitingQuestions.map(function (elicitingQuestion) {
                return printOption(elicitingQuestion.text);
            }),
            m("div.narrafirma-survey-print-enter-response", "Please enter your response here:"),
            questionnaire.storyQuestions.map(function (storyQuestion) {
                return printQuestion(storyQuestion);
            }),
            questionnaire.participantQuestions.map(function (participantQuestion) {
                return printQuestion(participantQuestion);
            }),
            m("div.narrafirma-survey-print-end-text", printText(questionnaire.endText || ""))
        ]);
        return generateHTMLForPage(questionnaire.title || "NarraFirma Story Form", "css/survey.css", vdom);
    }
    function printStoryForm(model, fieldSpecification, value) {
        // console.log("printStoryForm");
        var storyCollectionName = Globals.clientState().storyCollectionName();
        if (!storyCollectionName) {
            // TODO: translate
            alert("Please select a story collection first.");
            return null;
        }
        var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName);
        if (!questionnaire)
            return;
        var output = generateHTMLForQuestionnaire(questionnaire);
        printHTML(output);
    }
    exports.printStoryForm = printStoryForm;
    function printStoryCards() {
        // console.log("printStoryCards");
        if (!Globals.clientState().storyCollectionName()) {
            alert("Please select a story collection for which to print story cards");
            return;
        }
        var storyCollectionName = Globals.clientState().storyCollectionName();
        var allStoriesInStoryCollection = surveyCollection.getStoriesForStoryCollection(storyCollectionName);
        // console.log("allStoriesInStoryCollection", allStoriesInStoryCollection);
        var storyDivs = [];
        for (var storyIndex = 0; storyIndex < allStoriesInStoryCollection.length; storyIndex++) {
            var storyModel = allStoriesInStoryCollection[storyIndex];
            var storyContent = storyCardDisplay.generateStoryCardContent(storyModel, { storyTextAtTop: true });
            var storyDiv = m(".storyCardForPrinting", storyContent);
            storyDivs.push(storyDiv);
        }
        var htmlForPage = generateHTMLForPage("Story cards for: " + storyCollectionName, "css/standard.css", storyDivs);
        printHTML(htmlForPage);
    }
    exports.printStoryCards = printStoryCards;
    function printItem(item, fieldsToIgnore) {
        if (fieldsToIgnore === void 0) { fieldsToIgnore = {}; }
        var result = [];
        // console.log("presentationElement", presentationElement);
        for (var fieldName in item) {
            if (fieldsToIgnore[fieldName])
                continue;
            var fieldSpecification = Globals.panelSpecificationCollection().getFieldSpecificationForFieldID(fieldName);
            var shortName = fieldSpecification ? fieldSpecification.displayName : "Problem with: " + fieldName;
            var fieldValue = item[fieldName];
            // console.log("field", fieldName, fieldValue, shortName, fieldSpecification);
            // console.log("$", shortName + ":", fieldValue);
            result.push([
                m("div", shortName + ": " + fieldValue)
            ]);
        }
        ;
        return result;
    }
    function printList(list, fieldsToIgnore, printItemFunction) {
        if (fieldsToIgnore === void 0) { fieldsToIgnore = {}; }
        if (printItemFunction === void 0) { printItemFunction = printItem; }
        var result = [];
        var project = Globals.project();
        list.forEach(function (id) {
            // console.log("id", id);
            var item = project.tripleStore.makeObject(id, true);
            // console.log("presentationElement", presentationElement);
            result.push(printItemFunction(item, fieldsToIgnore));
            result.push([
                printReturn()
            ]);
        });
        return result;
    }
    function exportPresentationOutline() {
        var project = Globals.project();
        var presentationElementsList = project.getListForField("project_presentationElementsList");
        // console.log("presentationElementsList", presentationElementsList);
        // console.log("Globals.panelSpecificationCollection()", Globals.panelSpecificationCollection());
        var printItems = [
            m("div", "Presentation Outline generated " + new Date()),
            printReturnAndBlankLine()
        ];
        printItems.push(printList(presentationElementsList));
        var htmlForPage = generateHTMLForPage("Presentation Outline", "css/standard.css", printItems);
        printHTML(htmlForPage);
    }
    exports.exportPresentationOutline = exportPresentationOutline;
    function exportCollectionSessionAgenda(itemID) {
        var project = Globals.project();
        var collectionSessionAgenda = project.tripleStore.makeObject(itemID, true);
        // console.log("collectionSessionAgenda", collectionSessionAgenda);
        var activitiesListID = collectionSessionAgenda["collectionSessionPlan_activitiesList"];
        var activitiesList = project.tripleStore.getListForSetIdentifier(activitiesListID);
        var printItems = [
            m("div", "Story collection session agenda generated " + new Date()),
            printReturnAndBlankLine()
        ];
        printItems.push([
            printItem(collectionSessionAgenda, { collectionSessionPlan_activitiesList: true }),
            printReturnAndBlankLine()
        ]);
        printItems.push(printList(activitiesList));
        var htmlForPage = generateHTMLForPage("Story collection session agenda", "css/standard.css", printItems);
        printHTML(htmlForPage);
    }
    exports.exportCollectionSessionAgenda = exportCollectionSessionAgenda;
    function printSensemakingSessionAgenda(itemID) {
        var project = Globals.project();
        var sensemakingSessionAgenda = project.tripleStore.makeObject(itemID, true);
        // console.log("collectionSessionAgenda", collectionSessionAgenda);
        var activitiesListID = sensemakingSessionAgenda["sensemakingSessionPlan_activitiesList"];
        var activitiesList = project.tripleStore.getListForSetIdentifier(activitiesListID);
        var printItems = [
            m("div", "Sensemaking session agenda generated " + new Date()),
            printReturnAndBlankLine()
        ];
        printItems.push([
            printItem(sensemakingSessionAgenda, { sensemakingSessionPlan_activitiesList: true }),
            printReturnAndBlankLine()
        ]);
        printItems.push(printList(activitiesList));
        var htmlForPage = generateHTMLForPage("Sensemaking session agenda", "css/standard.css", printItems);
        printHTML(htmlForPage);
    }
    exports.printSensemakingSessionAgenda = printSensemakingSessionAgenda;
    function displayForGraphHolder(graphHolder) {
        // console.log("displayForGraph graphHolder", graphHolder);
        if (graphHolder.chartPanes.length > 1) {
            // multiple histograms
            var result = [];
            // Add the title
            result.push(m.trust(graphHolder.chartPanes[0].outerHTML));
            // Add the charts
            var charts = [];
            for (var i = 1; i < graphHolder.chartPanes.length; i++) {
                var graphPane = graphHolder.chartPanes[i];
                charts.push(m("td", displayForGraph(graphPane)));
            }
            result.push(m("table", { "class": "narrafirma-print-multiple-histograms" }, m("tr", charts)));
            // Add the statistics
            var statisticsPanel = graphHolder.graphResultsPane.lastChild;
            result.push(m.trust(statisticsPanel.outerHTML));
            return result;
        }
        else {
            return displayForGraph(graphHolder.graphResultsPane.firstChild);
        }
    }
    function displayForGraph(graphNode) {
        // console.log("graphNode", graphNode);
        var styleNode = document.createElement("style");
        styleNode.type = 'text/css';
        /*
        if (styleNode.styleSheet) {
            // IE support; cast to silence TypeScript warning
            (<any>styleNode.styleSheet).cssText = css;
        } else {
            styleNode.appendChild(document.createTextNode(css));
        }
        */
        styleNode.innerHTML = "<![CDATA[" + graphResultsPaneCSS + "]]>";
        // console.log("styleNode", styleNode);
        graphNode.firstChild.insertBefore(styleNode, graphNode.firstChild.firstChild);
        // console.log("graphNode", graphNode);
        var imageForGraph = null;
        // remove the statistics panel
        var statisticsPanel = graphNode.childNodes.item(1);
        graphNode.removeChild(statisticsPanel);
        var svgText = graphNode.innerHTML;
        // console.log("svgText", svgText);
        var canvas = document.createElement("canvas");
        canvg(canvas, svgText);
        var imgData = canvas.toDataURL("image/png");
        // console.log("imgData", imgData);
        // m.trust(graphHolder.graphResultsPane.outerHTML),
        imageForGraph = m("img", {
            //src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==",
            //src: `data:image/svg+xml;utf8,<svg width="400" height="110"><rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)"></rect>Sorry, your browser does not support inline SVG.</svg>`,
            src: imgData,
            alt: "Graph!!!"
        });
        return [
            imageForGraph || [],
            printReturnAndBlankLine(),
            m.trust(statisticsPanel.outerHTML),
            printReturnAndBlankLine()
        ];
    }
    function printObservationList(observationList, allStories, minimumStoryCountRequiredForTest) {
        // For now, just print all observations
        return printList(observationList, {}, function (item) {
            var project = Globals.project();
            // TODO: pattern
            var pattern = item.pattern;
            // console.log("pattern", pattern);
            var selectionCallback = function () { return this; };
            var graphHolder = {
                graphResultsPane: charting.createGraphResultsPane("narrafirma-graph-results-pane chartEnclosure"),
                chartPanes: [],
                allStories: allStories,
                currentGraph: null,
                currentSelectionExtentPercentages: null,
                excludeStoryTooltips: true,
                minimumStoryCountRequiredForTest: minimumStoryCountRequiredForTest
            };
            var graph = PatternExplorer.makeGraph(pattern, graphHolder, selectionCallback);
            // console.log("graph", graph);
            return [
                m("div.narrafirma-catalysis-report-observation", item.observationTitle),
                m("div.narrafirma-catalysis-report-observation-description", item.observationDescription),
                displayForGraphHolder(graphHolder),
                printReturnAndBlankLine()
            ];
        });
    }
    function makeObservationListForInterpretation(project, allObservations, interpretationName) {
        // console.log("makeObservationListForInterpretation", interpretationName);
        var result = [];
        allObservations.forEach(function (observation) {
            // console.log("observation", observation);
            var interpretationsListIdentifier = project.tripleStore.queryLatestC(observation, "observationInterpretations");
            // console.log("interpretationsListIdentifier", interpretationsListIdentifier);
            var interpretationsList = project.tripleStore.getListForSetIdentifier(interpretationsListIdentifier);
            // console.log("interpretationsList", interpretationsList);
            interpretationsList.forEach(function (interpretationIdentifier) {
                var interpretation = project.tripleStore.makeObject(interpretationIdentifier, true);
                var name = interpretation.interpretation_name;
                if (name === interpretationName) {
                    // console.log("found observation that has matching interpretation", interpretation, observation);
                    result.push(observation);
                }
            });
        });
        return result;
    }
    function printCatalysisReport() {
        var project = Globals.project();
        var catalysisReportName = Globals.clientState().catalysisReportName();
        // console.log("printCatalysisReport", catalysisReportName);
        if (!catalysisReportName) {
            alert("Please pick a catalysis report to print.");
            return;
        }
        var catalysisReportIdentifier = project.findCatalysisReport(catalysisReportName);
        // console.log("catalysisReport", catalysisReportIdentifier);
        var clusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "interpretationsClusteringDiagram");
        // console.log("clusteringDiagram", clusteringDiagram);
        if (!clusteringDiagram) {
            // console.log("clusteringDiagram not defined");
            alert("Please cluster interpretations before printing.");
            return;
        }
        var allStories = project.storiesForCatalysisReport(catalysisReportIdentifier);
        // console.log("allStories", allStories);
        var catalysisReportObservationSetIdentifier = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
        // console.log("catalysisReportObservationSetIdentifier", catalysisReportObservationSetIdentifier);
        if (!catalysisReportObservationSetIdentifier) {
            console.log("catalysisReportObservationSetIdentifier not defined");
            return;
        }
        var progressModel = dialogSupport.openProgressDialog("Starting up...", "Generating catalysis report", "Cancel", dialogCancelled);
        var allObservations = project.tripleStore.getListForSetIdentifier(catalysisReportObservationSetIdentifier);
        // console.log("allObservations", allObservations);
        var reportNotes = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_notes");
        var printItems = [
            m("div.narrafirma-catalysis-report-title", catalysisReportName),
            m("div.narrafirma-catalysis-report-project-name", "Project: " + project.projectIdentifier),
            m("div.narrafirma-catalysis-report-date", "Generated: " + new Date().toString()),
            m("div.narrafirma-catalysis-report-intro-note", reportNotes)
        ];
        ClusteringDiagram.calculateClusteringForDiagram(clusteringDiagram);
        // console.log("clusteringDiagram with clusters", clusteringDiagram);
        var perspectives = clusteringDiagram.clusters;
        // list of links to perspectives
        printItems.push(m("div.narrafirma-catalysis-report-perspective-link-header", "Perspectives in this report (" + perspectives.length + "):"));
        for (var i = 0; i < perspectives.length; i++) {
            var perspective = perspectives[i];
            printItems.push(m("div.narrafirma-catalysis-report-perspective-link", m("a", { href: "#" + perspective.name }, perspective.name)));
        }
        printItems.push(m("br"));
        var minimumStoryCountRequiredForTest = project.minimumStoryCountRequiredForTest(catalysisReportIdentifier);
        function progressText(perspectiveIndex, interpretationIndex) {
            return "Perspective " + (perspectiveIndex + 1) + " of " + perspectives.length + ", interpretation " + (interpretationIndex + 1) + " of " + perspectives[perspectiveIndex].items.length;
        }
        function dialogCancelled(dialogConfiguration, hideDialogMethod) {
            progressModel.cancelled = true;
            hideDialogMethod();
        }
        var perspectiveIndex = 0;
        var interpretationIndex = 0;
        function printNextPerspective() {
            // console.log("printNextPerspective", perspectiveIndex, interpretationIndex);
            // console.log("sendNextMessage", messageIndexToSend);
            if (progressModel.cancelled) {
                alert("Cancelled after working on " + (perspectiveIndex + 1) + " perspective(s)");
            }
            else if (perspectiveIndex >= perspectives.length) {
                progressModel.hideDialogMethod();
                // Trying to avoid popup warning if open window from timeout by using finish dialog button press to display results
                var finishModel = dialogSupport.openFinishedDialog("Done creating report; display it?", "Finished generating catalysis report", "Display", "Cancel", function (dialogConfiguration, hideDialogMethod) {
                    // "css/standard.css"
                    var htmlForPage = generateHTMLForPage(catalysisReportName, "css/standard.css", printItems);
                    printHTML(htmlForPage);
                    hideDialogMethod();
                    progressModel.redraw();
                });
                finishModel.redraw();
            }
            else {
                var perspective = perspectives[perspectiveIndex];
                if (interpretationIndex === 0) {
                    printItems.push(m("a", { name: perspective.name }));
                    printItems.push(m("div.narrafirma-catalysis-report-perspective", perspective.name));
                    if (perspective.notes)
                        printItems.push(m("div.narrafirma-catalysis-report-perspective-notes", perspective.notes));
                    // list of links to interpretations in this perspective
                    printItems.push(m("div.narrafirma-catalysis-report-interp-link-header", "Interpretations in this perspective (" + perspective.items.length + "):"));
                    for (var i = 0; i < perspective.items.length; i++) {
                        var interpretation = perspective.items[i];
                        printItems.push(m("div.narrafirma-catalysis-report-interp-link", m("a", { href: "#" + interpretation.name }, interpretation.name)));
                    }
                    printItems.push(m("br"));
                }
                var interpretations = perspective.items;
                if (interpretationIndex >= interpretations.length) {
                    perspectiveIndex++;
                    interpretationIndex = 0;
                }
                else {
                    var interpretation = interpretations[interpretationIndex];
                    printItems.push(m("a", { name: interpretation.name }));
                    printItems.push(m("div.narrafirma-catalysis-report-interpretation", interpretation.name));
                    if (interpretation.notes)
                        printItems.push(m("div.narrafirma-catalysis-report-interpretation-notes", interpretation.notes));
                    var observationList = makeObservationListForInterpretation(project, allObservations, interpretation.name);
                    printItems.push(printObservationList(observationList, allStories, minimumStoryCountRequiredForTest));
                    // TODO: Translate
                    progressModel.progressText = progressText(perspectiveIndex, interpretationIndex);
                    progressModel.redraw();
                    interpretationIndex++;
                }
                setTimeout(function () { printNextPerspective(); }, 0);
            }
        }
        setTimeout(function () { printNextPerspective(); }, 0);
    }
    exports.printCatalysisReport = printCatalysisReport;
});

define('js/projectImportExport',["require", "exports", "./Globals", "./panelBuilder/dialogSupport", "./surveyStorage", "FileSaver"], function (require, exports, Globals, dialogSupport, surveyStorage, saveAs) {
    "use strict";
    var allMessagesExportType = "NarraFirma_allMessages";
    var allMessagesExportFormat = "0.1.0";
    var currentProjectStateExportType = "NarraFirma_currentProjectState";
    var currentProjectStateExportFormat = "0.1.1";
    function exportEntireProject() {
        if (!confirm("Export entire project?\n(This may take a while.)"))
            return;
        var project = Globals.project();
        // var json = JSON.stringify(project.tripleStore.tripleMessages, null, 4);
        var exportObject = {
            projectIdentifier: project.projectIdentifier,
            timestamp: new Date().toISOString(),
            exportType: allMessagesExportType,
            exportFormat: allMessagesExportFormat,
            userIdentifier: project.pointrelClient.userIdentifier,
            messages: project.pointrelClient.messagesSortedByReceivedTimeArray
        };
        var json = JSON.stringify(exportObject, null, 4);
        // var printItems = m("pre", json);
        // var htmlForPage = generateHTMLForPage("NarraFirma project export for " + project.projectIdentifier + " on " + new Date().toISOString(), null, printItems);
        // printHTML(htmlForPage);
        var questionnaireBlob = new Blob([json], { type: "application/json;charset=utf-8" });
        saveAs(questionnaireBlob, exportObject.projectIdentifier + " exported at " + exportObject.timestamp + ".json");
    }
    exports.exportEntireProject = exportEntireProject;
    function chooseProjectFileToImport(callback) {
        // console.log("chooseFileToImport");
        var projectFileUploader = document.getElementById("projectFileUploader");
        // console.log("cvsFileUploader", cvsFileUploader);
        projectFileUploader.onchange = function () {
            var file = projectFileUploader.files[0];
            if (!file) {
                return;
            }
            var reader = new FileReader();
            reader.onload = function (e) {
                var contents = e.target.result;
                callback(contents);
            };
            reader.readAsText(file);
        };
        projectFileUploader.click();
    }
    function importEntireProject() {
        var project = Globals.project();
        if (!confirm("Import entire project?"))
            return;
        console.log("importEntireProject");
        chooseProjectFileToImport(function (contents) {
            // console.log("contents", contents);
            var importObject = JSON.parse(contents);
            // importObject.messages.forEach((message) => {
            //    // if (message._topicIdentifier === "surveyResults")
            //    console.log("message", message._topicIdentifier);
            //});
            // TODO: Similar to what is in csvImportExport -- could any duplication be refactored out?
            if (importObject.exportType !== allMessagesExportType) {
                alert('Wrong export file type; expected exportType of "' + allMessagesExportType + '" but found: "' + importObject.exportType + '"');
                return;
            }
            if (importObject.exportFormat > allMessagesExportFormat) {
                if (!confirm("The file has an export format of: " + importObject.exportFormat + " which is later than this application's of: " + allMessagesExportFormat + "\nTry importing anyway (not recommended)?")) {
                    return;
                }
            }
            var progressModel = dialogSupport.openProgressDialog("Importing project messages...", "Progress importing project messsages", "Cancel", dialogCancelled);
            function dialogCancelled(dialogConfiguration, hideDialogMethod) {
                progressModel.cancelled = true;
                hideDialogMethod();
            }
            var messageIndexToSend = 0;
            function sendNextMessage() {
                // console.log("sendNextMessage", messageIndexToSend);
                if (progressModel.cancelled) {
                    alert("Cancelled after importing " + messageIndexToSend + " messages");
                }
                else if (messageIndexToSend >= importObject.messages.length) {
                    alert("Done importing messages");
                    progressModel.hideDialogMethod();
                    progressModel.redraw();
                }
                else {
                    var message = importObject.messages[messageIndexToSend++];
                    // Rewrite project references in triples, but not in survey results
                    // TODO: The message trace is no longer valid if do rewrite
                    if (message.change && message.change.triple && message.change.triple.a === importObject.projectIdentifier) {
                        message.change.triple.a = project.projectIdentifier;
                    }
                    if (message.change && message.change.projectIdentifier === importObject.projectIdentifier) {
                        message.change.projectIdentifier = project.projectIdentifier;
                    }
                    // TODO: Translate
                    progressModel.progressText = "Importing " + messageIndexToSend + " of " + importObject.messages.length + " messages";
                    progressModel.redraw();
                    setTimeout(function () { project.pointrelClient.sendMessage(message, sendNextMessage); }, 0);
                }
            }
            // Start sending project messages
            sendNextMessage();
        });
    }
    exports.importEntireProject = importEntireProject;
    function exportProjectCurrentState(includeSurveyResults) {
        // TODO: Translate
        var promptMessage = includeSurveyResults ?
            "Export current state of project with survey results?" :
            "Export current state of project without survey results?";
        if (!confirm(promptMessage))
            return;
        var project = Globals.project();
        var tripleStore = project.tripleStore;
        var projectCurrentState = {};
        var aKeys = Object.keys(tripleStore.indexABC);
        // console.log("aKeys", aKeys);
        aKeys.sort();
        for (var aKeyIndex = 0; aKeyIndex < aKeys.length; aKeyIndex++) {
            var aKey = aKeys[aKeyIndex];
            // console.log("aKey", aKey);
            var aObject = tripleStore.indexABC[aKey];
            // console.log("aObject", aObject);
            var bResult = {};
            projectCurrentState[aKey] = bResult;
            var bKeys = Object.keys(aObject);
            bKeys.sort();
            // console.log("bKeys", bKeys);
            for (var bKeyIndex = 0; bKeyIndex < bKeys.length; bKeyIndex++) {
                var bKey = bKeys[bKeyIndex];
                bResult[bKey] = aObject[bKey].latestC;
            }
        }
        // console.log("exportProjectCurrentState", projectCurrentState);
        var activeQuestionnaires = null;
        var storyCollections = null;
        if (includeSurveyResults) {
            var questionnaireMessages = project.pointrelClient.filterMessages(function (message) {
                return message._topicIdentifier === "questionnaires";
            });
            if (questionnaireMessages.length)
                activeQuestionnaires = questionnaireMessages[questionnaireMessages.length - 1].change;
            var surveyResultMessages = project.pointrelClient.filterMessages(function (message) {
                return message._topicIdentifier === "surveyResults";
            });
            storyCollections = {};
            surveyResultMessages.forEach(function (message) {
                var storyCollectionIdentifier = message.change.storyCollectionIdentifier;
                var storyCollection = storyCollections[storyCollectionIdentifier];
                if (!storyCollection) {
                    storyCollection = [];
                    storyCollections[storyCollectionIdentifier] = storyCollection;
                }
                storyCollection.push(message.change.surveyResult);
            });
        }
        var exportObject = {
            projectIdentifier: project.projectIdentifier,
            timestamp: new Date().toISOString(),
            exportType: currentProjectStateExportType,
            exportFormat: currentProjectStateExportFormat,
            userIdentifier: project.pointrelClient.userIdentifier,
            projectCurrentState: projectCurrentState,
            activeQuestionnaires: activeQuestionnaires,
            storyCollections: storyCollections
        };
        var json = JSON.stringify(exportObject, null, 4);
        var questionnaireBlob = new Blob([json], { type: "application/json;charset=utf-8" });
        saveAs(questionnaireBlob, exportObject.projectIdentifier + " current state exported at " + exportObject.timestamp + ".json");
    }
    function exportProjectCurrentStateWithSurveyResults() {
        exportProjectCurrentState(true);
    }
    exports.exportProjectCurrentStateWithSurveyResults = exportProjectCurrentStateWithSurveyResults;
    function exportProjectCurrentStateWithoutSurveyResults() {
        exportProjectCurrentState(false);
    }
    exports.exportProjectCurrentStateWithoutSurveyResults = exportProjectCurrentStateWithoutSurveyResults;
    function importProjectCurrentState() {
        var project = Globals.project();
        if (!confirm("Import current project state?\n(This should ideally only be done with a new empty project.)"))
            return;
        console.log("importProjectCurrentState");
        chooseProjectFileToImport(function (contents) {
            // console.log("contents", contents);
            var importObject = JSON.parse(contents);
            // importObject.messages.forEach((message) => {
            //    // if (message._topicIdentifier === "surveyResults")
            //    console.log("message", message._topicIdentifier);
            //});
            // TODO: Similar to what is in csvImportExport -- could any duplication be refactored out?
            if (importObject.exportType !== currentProjectStateExportType) {
                alert('Wrong export file type; expected exportType of "' + currentProjectStateExportType + '" but found: "' + importObject.exportType + '"');
                return;
            }
            if (importObject.exportFormat > currentProjectStateExportFormat) {
                if (!confirm("The file has an export format of: " + importObject.exportFormat + " which is later than this application's of: " + allMessagesExportFormat + "\nTry importing anyway (not recommended)?")) {
                    return;
                }
            }
            var progressModel = dialogSupport.openProgressDialog("Importing current project state...", "Progress importing current project state", "Cancel", dialogCancelled);
            function dialogCancelled(dialogConfiguration, hideDialogMethod) {
                progressModel.cancelled = true;
                hideDialogMethod();
            }
            var messagesToSend = [];
            // Prepare triples for adding
            var aKeys = Object.keys(importObject.projectCurrentState);
            // console.log("aKeys", aKeys);
            for (var aKeyIndex = 0; aKeyIndex < aKeys.length; aKeyIndex++) {
                var aKey = aKeys[aKeyIndex];
                var aKeyObject = JSON.parse(aKey);
                var aObject = importObject.projectCurrentState[aKey];
                // console.log("aKey", aKey);
                // console.log("aObject", aObject);
                // Rewrite project references in triples
                if (aKeyObject === importObject.projectIdentifier) {
                    aKeyObject = project.projectIdentifier;
                }
                var bKeys = Object.keys(aObject);
                // console.log("bKeys", bKeys);
                for (var bKeyIndex = 0; bKeyIndex < bKeys.length; bKeyIndex++) {
                    var bKey = bKeys[bKeyIndex];
                    var bKeyObject = JSON.parse(bKey);
                    var cValue = aObject[bKey];
                    messagesToSend.push([aKeyObject, bKeyObject, cValue]);
                }
            }
            // Prepare activeQuestionnaires for adding
            if (importObject.activeQuestionnaires) {
                var questionnaireMessage = project.pointrelClient.createChangeMessage("questionnaires", "questionnairesMessage", importObject.activeQuestionnaires, null);
                messagesToSend.push(questionnaireMessage);
            }
            // Prepare surveyResults for adding
            if (importObject.storyCollections) {
                for (var storyCollectionName in importObject.storyCollections) {
                    var surveyResults = importObject.storyCollections[storyCollectionName];
                    surveyResults.forEach(function (surveyResult) {
                        //var questionnaireMessage = project.pointrelClient.createChangeMessage("questionnaires", "questionnairesMessage", importObject.activeQuestionnaires, null);
                        var surveyResultMessage = surveyStorage.makeSurveyResultMessage(project.pointrelClient, project.projectIdentifier, storyCollectionName, surveyResult);
                        messagesToSend.push(surveyResultMessage);
                    });
                }
            }
            var messagesSentCount = 0;
            // console.log("messagesToSend", messagesToSend);
            function sendNextMessage() {
                // console.log("sendNextMessage", messageIndexToSend);
                if (progressModel.cancelled) {
                    alert("Cancelled after adding " + messagesSentCount + " project triples");
                }
                else if (messagesSentCount >= messagesToSend.length) {
                    alert("Done importing project triples");
                    progressModel.hideDialogMethod();
                    progressModel.redraw();
                }
                else {
                    var message = messagesToSend[messagesSentCount++];
                    var triple = null;
                    if (Array.isArray(message)) {
                        triple = message;
                    }
                    // TODO: Translate
                    progressModel.progressText = "Sending " + messagesSentCount + " of " + messagesToSend.length + " triples";
                    progressModel.redraw();
                    setTimeout(function () {
                        if (triple) {
                            project.tripleStore.addTriple(triple[0], triple[1], triple[2], sendNextMessage);
                        }
                        else {
                            project.pointrelClient.sendMessage(message, sendNextMessage);
                        }
                    }, 0);
                }
            }
            // Start sending project messages
            sendNextMessage();
        });
    }
    exports.importProjectCurrentState = importProjectCurrentState;
});

define('js/buttonActions',["require", "exports", "./panelBuilder/browser", "./csvImportExport", "./panelBuilder/dialogSupport", "./navigationPane", "./pageDisplayer", "./questionnaireGeneration", "./surveyBuilderMithril", "./surveyCollection", "./surveyStorage", "./panelBuilder/translate", "./panelBuilder/toaster", "./printing", "./projectImportExport", "./applicationWidgets/ClusteringDiagram"], function (require, exports, browser, csvImportExport, dialogSupport, navigationPane, pageDisplayer, questionnaireGeneration, surveyBuilder, surveyCollection, surveyStorage, translate, toaster, printing, projectImportExport, ClusteringDiagram) {
    "use strict";
    var project;
    var clientState;
    // Call this to set up the project or other needed data
    function initialize(theProject, theClientState) {
        project = theProject;
        clientState = theClientState;
    }
    exports.initialize = initialize;
    function helpButtonClicked() {
        var pageSpecification = navigationPane.getCurrentPageSpecification();
        // console.log("helpButtonClicked", pageSpecification);
        if (!pageSpecification) {
            console.log("no pageSpecification for current page");
            return;
        }
        var helpURL = 'help/' + pageSpecification.section + "/help_" + pageSpecification.id + '.html';
        // console.log("opening help url", helpURL);
        browser.launchApplication(helpURL, 'help');
    }
    exports.helpButtonClicked = helpButtonClicked;
    // Caller should call wizard.forward() on successful save to see the last page, and provide a retry message otherwise
    // Caller may also want to call (the returned) surveyDialog.hide() to close the window, or let the user do it.
    function openMithrilSurveyDialog(questionnaire, callback, previewModeTitleText) {
        // console.log("openSurveyDialog questionnaire", questionnaire);
        if (previewModeTitleText === void 0) { previewModeTitleText = null; }
        var surveyDiv = document.createElement("div");
        var surveyViewFunction = surveyBuilder.buildSurveyForm(null, questionnaire, callback, { previewMode: !!previewModeTitleText, ignoreTitleChange: true });
        var dialogConfiguration = {
            dialogModel: null,
            dialogTitle: "Take Survey" + (previewModeTitleText || ""),
            dialogStyle: undefined,
            dialogConstructionFunction: surveyViewFunction,
            dialogOKButtonLabel: "Close",
            dialogOKCallback: function (dialogConfiguration, hideDialogMethod) { hideDialogMethod(); }
        };
        return dialogSupport.openDialog(dialogConfiguration);
    }
    function openSurveyDialog() {
        // console.log("openSurveyDialog");
        var storyCollectionName = clientState.storyCollectionName();
        if (!storyCollectionName) {
            // TODO: translate
            alert("Please select a story collection first.");
            return null;
        }
        var questionnaire = surveyCollection.getQuestionnaireForStoryCollection(storyCollectionName, true);
        if (!questionnaire)
            return;
        var surveyDialog = openMithrilSurveyDialog(questionnaire, finished);
        function finished(status, surveyResult, wizardPane) {
            console.log("surveyResult", status, surveyResult);
            if (status === "submitted") {
                surveyStorage.storeSurveyResult(project.pointrelClient, project.projectIdentifier, storyCollectionName, surveyResult, wizardPane);
            }
        }
    }
    ///////// Button functions
    function copyStoryFormURL() {
        alert("Story form URL is: " + "http://localhost:8080/survey.html");
    }
    exports.copyStoryFormURL = copyStoryFormURL;
    function guiOpenSection(model, fieldSpecification, value) {
        var section = fieldSpecification.displayConfiguration.section;
        // console.log("guiOpenSection", section, fieldSpecification);
        // Don't queue an extra redraw as one is already queued since this code get called by a button press
        var isRedrawAlreadyQueued = true;
        pageDisplayer.showPage(section, false, isRedrawAlreadyQueued);
        // document.body.scrollTop = 0;
        // document.documentElement.scrollTop = 0;
        window.scrollTo(0, 0);
    }
    exports.guiOpenSection = guiOpenSection;
    function copyDraftPNIQuestionVersionsIntoAnswers_Basic() {
        var finalQuestionIDs = [
            "project_pniQuestions_goal_final",
            "project_pniQuestions_relationships_final",
            "project_pniQuestions_focus_final",
            "project_pniQuestions_range_final",
            "project_pniQuestions_scope_final",
            "project_pniQuestions_emphasis_final"
        ];
        var copiedAnswersCount = 0;
        for (var index in finalQuestionIDs) {
            var finalQuestionID = finalQuestionIDs[index];
            var draftQuestionID = finalQuestionID.replace("_final", "_draft");
            // console.log("finalQuestionID/draftQuestionID", finalQuestionID, draftQuestionID);
            var finalValue = project.tripleStore.queryLatestC(project.projectIdentifier, finalQuestionID);
            if (!finalValue) {
                var draftValue = project.tripleStore.queryLatestC(project.projectIdentifier, draftQuestionID);
                if (draftValue) {
                    project.tripleStore.addTriple(project.projectIdentifier, finalQuestionID, draftValue);
                    copiedAnswersCount++;
                }
            }
        }
        return copiedAnswersCount;
    }
    function copyDraftPNIQuestionVersionsIntoAnswers() {
        var copiedAnswersCount = copyDraftPNIQuestionVersionsIntoAnswers_Basic();
        var template = translate("#copyDraftPNIQuestion_template", "Copied {{copiedAnswersCount}} answers.\n\n(Note that blank draft answers are not copied, and non-blank final answers are not replaced.)");
        var message = template.replace("{{copiedAnswersCount}}", copiedAnswersCount);
        alert(message);
    }
    exports.copyDraftPNIQuestionVersionsIntoAnswers = copyDraftPNIQuestionVersionsIntoAnswers;
    function logoutButtonClicked() {
        // TODO: Warn if have any read-only changes that would be lost
        if (confirm("Logout?")) {
            var isWordPressAJAX = !!window["ajaxurl"];
            if (isWordPressAJAX) {
                window.location.href = window.location.href.split("wp-content")[0] + "wp-login.php?action=logout";
            }
            else {
                window.location.href = "/logout";
            }
        }
    }
    exports.logoutButtonClicked = logoutButtonClicked;
    function loginButtonClicked() {
        // TODO: Warn if have any read-only changes that would be lost
        if (confirm("Login?")) {
            var isWordPressAJAX = !!window["ajaxurl"];
            if (isWordPressAJAX) {
                window.location.href = window.location.href.split("wp-content")[0] + "wp-login.php?action=login";
            }
            else {
                window.location.href = "/login";
            }
        }
    }
    exports.loginButtonClicked = loginButtonClicked;
    /*
    function previewQuestionForm(model, fieldSpecification) {
        console.log("previewQuestionForm", model);
        var questionnaire = questionnaireGeneration.buildQuestionnaireFromTemplate(project, model);
        
        var surveyDialog = openMithrilSurveyDialog(questionnaire, finished, true);
        
        function finished(status, surveyResult, wizardPane) {
            console.log("surveyResult", status, surveyResult);
            if (wizardPane) wizardPane.forward();
        }
    }
    */
    function previewQuestionForm(model, fieldSpecification) {
        // console.log("previewQuestionForm", model);
        var questionnaire = questionnaireGeneration.buildQuestionnaireFromTemplate(model);
        window["narraFirma_previewQuestionnaire"] = questionnaire;
        var w = window.open("survey.html#preview=" + (new Date().toISOString()), "_blank");
    }
    exports.previewQuestionForm = previewQuestionForm;
    function copyInterpretationsToClusteringDiagram() {
        var shortName = clientState.catalysisReportName();
        // console.log("copyInterpretationsToClusteringDiagram", shortName);
        if (!shortName) {
            alert("Please pick a catalysis report to work with.");
            return;
        }
        var catalysisReportIdentifier = project.findCatalysisReport(shortName);
        if (!catalysisReportIdentifier) {
            alert("Problem finding catalysisReportIdentifier");
            return;
        }
        // Collect all interpretations
        var allInterpretations = [];
        var observationSetIdentifier = project.tripleStore.queryLatestC(catalysisReportIdentifier, "catalysisReport_observations");
        // console.log("observationSetIdentifier", observationSetIdentifier);
        if (!observationSetIdentifier) {
            alert("No observations have been made yet in the Pattern Browser");
            return;
        }
        var observations = project.tripleStore.queryAllLatestBCForA(observationSetIdentifier);
        // console.log("observations", observations);
        for (var key in observations) {
            var observationIdentifier = observations[key];
            // console.log("observationIdentifier", key, observationIdentifier);
            var interpretationsSetIdentifier = project.tripleStore.queryLatestC(observationIdentifier, "observationInterpretations");
            // console.log("interpretationsSetIdentifier", key, observationIdentifier, interpretationsSetIdentifier);
            if (interpretationsSetIdentifier) {
                var interpretations = project.tripleStore.getListForSetIdentifier(interpretationsSetIdentifier);
                // console.log("interpretations", interpretations);
                for (var i = 0; i < interpretations.length; i++) {
                    var interpretationIdentifier = interpretations[i];
                    // "interpretation_name", "interpretation_text"
                    var interpretationName = project.tripleStore.queryLatestC(interpretationIdentifier, "interpretation_name");
                    var interpretationText = project.tripleStore.queryLatestC(interpretationIdentifier, "interpretation_text");
                    // console.log("interpretationIdentifier", interpretationIdentifier, interpretationName, interpretationText);
                    allInterpretations.push({
                        "type": "Interpretation",
                        id: interpretationIdentifier,
                        name: interpretationName,
                        text: interpretationText
                    });
                }
            }
        }
        if (allInterpretations.length === 0) {
            alert("No interpretations have been found for this catalysis report");
        }
        // console.log("allInterpretations", allInterpretations);
        if (!confirm("Copy intepretations for this catalysys report into clustering diagram?"))
            return;
        var clusteringDiagram = project.tripleStore.queryLatestC(catalysisReportIdentifier, "interpretationsClusteringDiagram");
        // console.log("clusteringDiagram before", clusteringDiagram);
        if (!clusteringDiagram) {
            clusteringDiagram = ClusteringDiagram.newDiagramModel();
        }
        var existingItemNames = {};
        clusteringDiagram.items.forEach(function (item) {
            existingItemNames[item.name] = true;
        });
        var addedItemCount = 0;
        var shiftPerItem = 3;
        allInterpretations.forEach(function (interpretation) {
            if (!existingItemNames[interpretation.name]) {
                addedItemCount++;
                ClusteringDiagram.addNewItemToDiagram(clusteringDiagram, "item", interpretation.name, interpretation.text);
            }
        });
        // console.log("clusteringDiagram after", clusteringDiagram);
        project.tripleStore.addTriple(catalysisReportIdentifier, "interpretationsClusteringDiagram", clusteringDiagram);
        toaster.toast("Added " + addedItemCount + " interpretations");
    }
    exports.copyInterpretationsToClusteringDiagram = copyInterpretationsToClusteringDiagram;
    function setQuestionnaireForStoryCollection(storyCollectionIdentifier) {
        // console.log("setQuestionnaireForStoryCollection", storyCollectionIdentifier);
        if (!storyCollectionIdentifier)
            return false;
        var questionnaireName = project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_questionnaireIdentifier");
        var questionnaire = questionnaireGeneration.buildQuestionnaire(questionnaireName);
        if (!questionnaire)
            return false;
        project.tripleStore.addTriple(storyCollectionIdentifier, "questionnaire", questionnaire);
        return true;
    }
    exports.setQuestionnaireForStoryCollection = setQuestionnaireForStoryCollection;
    function updateQuestionnaireForStoryCollection(storyCollectionIdentifier) {
        // console.log("updateQuestionnaireForStoryCollection", storyCollectionIdentifier);
        if (!storyCollectionIdentifier) {
            alert("Problem: No storyCollectionIdentifier");
            return;
        }
        var storyCollectionName = project.tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_shortName");
        if (!storyCollectionName) {
            alert("Problem: No storyCollectionName");
            return;
        }
        // TODO: Translate
        var confirmResult = confirm('Update story form for story collection "' + storyCollectionName + '"?"\n(Updating is not recommended once data collection has begun.)');
        if (!confirmResult)
            return;
        var updateResult = setQuestionnaireForStoryCollection(storyCollectionIdentifier);
        if (!updateResult) {
            alert("Problem: No questionnaire could be created");
            return;
        }
        toaster.toast("Updated story form");
        return;
    }
    exports.updateQuestionnaireForStoryCollection = updateQuestionnaireForStoryCollection;
    function isNamedItemInDiagram(diagram, name, itemType) {
        if (itemType === void 0) { itemType = null; }
        // Array.some returns true or false depending on whether there is soem item that tests true 
        return diagram.items.some(function (item) {
            if (!itemType || item.type === itemType) {
                if (item.name === name) {
                    return true;
                }
            }
            return false;
        });
    }
    function copyClusteringDiagramElements(fromDiagramField, fromType, toDiagramField, toType) {
        // console.log("copyClusteringDagramElements", fromDiagramField, fromType, toDiagramField, toType);
        var fromDiagram = project.getFieldValue(fromDiagramField);
        // console.log("fromDiagram", fromDiagram);
        if (!fromDiagram || !fromDiagram.items.length)
            return;
        var toDiagram = project.getFieldValue(toDiagramField) || ClusteringDiagram.newDiagramModel();
        // console.log("toDiagram", toDiagram);
        var addedItemCount = 0;
        fromDiagram.items.forEach(function (item) {
            if (item.type === fromType) {
                if (!isNamedItemInDiagram(toDiagram, item.name, toType)) {
                    ClusteringDiagram.addNewItemToDiagram(toDiagram, toType, item.name, item.notes);
                    addedItemCount++;
                }
            }
        });
        if (addedItemCount) {
            toaster.toast("Updating diagram");
            project.setFieldValue(toDiagramField, toDiagram);
        }
        else {
            toaster.toast("No changes were needed to diagram");
        }
    }
    function copyPlanningStoriesToClusteringDiagram(model) {
        // console.log("copyPlanningStoriesToClusteringDiagram", model);
        var list = project.getListForField("project_projectStoriesList");
        // console.log("copyPlanningStoriesToClusteringDiagram", list);
        var toDiagramField = "project_storyElements_answersClusteringDiagram";
        var toDiagram = project.getFieldValue(toDiagramField) || ClusteringDiagram.newDiagramModel();
        // console.log("toDiagram", toDiagram);
        var addedItemCount = 0;
        list.forEach(function (projectStoryIdentifier) {
            var projectStory = project.tripleStore.makeObject(projectStoryIdentifier);
            // console.log("projectStory", projectStory);
            var storyName = projectStory.projectStory_name;
            var storyText = projectStory.projectStory_text;
            if (!isNamedItemInDiagram(toDiagram, storyName, "cluster")) {
                ClusteringDiagram.addNewItemToDiagram(toDiagram, "cluster", storyName, storyText);
                addedItemCount++;
            }
        });
        if (addedItemCount) {
            toaster.toast("Updating diagram");
            project.setFieldValue(toDiagramField, toDiagram);
        }
        else {
            toaster.toast("No changes were needed to diagram");
        }
    }
    exports.copyPlanningStoriesToClusteringDiagram = copyPlanningStoriesToClusteringDiagram;
    function copyAnswersToClusteringDiagram(model) {
        // console.log("copyAnswersToClusteringDiagram", model);
        copyClusteringDiagramElements("project_storyElements_answersClusteringDiagram", "item", "project_storyElements_answerClustersClusteringDiagram", "item");
    }
    exports.copyAnswersToClusteringDiagram = copyAnswersToClusteringDiagram;
    function copyAnswerClustersToClusteringDiagram(model) {
        // console.log("copyAnswerClustersToClusteringDiagram", model);
        copyClusteringDiagramElements("project_storyElements_answerClustersClusteringDiagram", "cluster", "project_storyElements_attributesClusteringDiagram", "cluster");
    }
    exports.copyAnswerClustersToClusteringDiagram = copyAnswerClustersToClusteringDiagram;
    function copyAttributesToClusteringDiagram(model) {
        // console.log("copyAttributesToClusteringDiagram", model);
        copyClusteringDiagramElements("project_storyElements_attributesClusteringDiagram", "item", "project_storyElements_attributeClustersClusteringDiagram", "item");
    }
    exports.copyAttributesToClusteringDiagram = copyAttributesToClusteringDiagram;
    exports.enterSurveyResult = openSurveyDialog;
    exports.toggleWebActivationOfSurvey = surveyCollection.toggleWebActivationOfSurvey;
    exports.storyCollectionStop = surveyCollection.storyCollectionStop;
    exports.importCSVQuestionnaire = csvImportExport.importCSVQuestionnaire;
    exports.importCSVStories = csvImportExport.importCSVStories;
    exports.exportQuestionnaire = csvImportExport.exportQuestionnaire;
    exports.exportStoryCollection = csvImportExport.exportStoryCollection;
    exports.exportEntireProject = projectImportExport.exportEntireProject;
    exports.importEntireProject = projectImportExport.importEntireProject;
    exports.exportProjectCurrentStateWithSurveyResults = projectImportExport.exportProjectCurrentStateWithSurveyResults;
    exports.exportProjectCurrentStateWithoutSurveyResults = projectImportExport.exportProjectCurrentStateWithoutSurveyResults;
    exports.importProjectCurrentState = projectImportExport.importProjectCurrentState;
    exports.printStoryForm = printing.printStoryForm;
    exports.printStoryCards = printing.printStoryCards;
    exports.printCatalysisReport = printing.printCatalysisReport;
    exports.exportPresentationOutline = printing.exportPresentationOutline;
    exports.exportCollectionSessionAgenda = printing.exportCollectionSessionAgenda;
    exports.printSensemakingSessionAgenda = printing.printSensemakingSessionAgenda;
});

define('js/applicationWidgets/add_catalysisReportQuestionChooser',["require", "exports", "mithril", "../panelBuilder/valuePathResolver", "../Globals"], function (require, exports, m, valuePathResolver, Globals) {
    "use strict";
    function add_catalysisReportQuestionChooser(panelBuilder, model, fieldSpecification) {
        // console.log("add_catalysisReportQuestionChooser", model, fieldSpecification);
        var project = Globals.project();
        var catalysisReportIdentifier = Globals.clientState().catalysisReportIdentifier();
        if (!catalysisReportIdentifier)
            return m("div", "Please select a catalysis report");
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var allStories = project.storiesForCatalysisReport(catalysisReportIdentifier);
        var allStoryQuestions = project.collectAllStoryQuestions();
        var allParticipantQuestions = project.collectAllParticipantQuestions();
        var allAnnotationQuestions = project.collectAllAnnotationQuestions();
        function isChecked(shortName, value) {
            if (value === void 0) { value = undefined; }
            var map = storageFunction() || {};
            if (value === undefined) {
                return !!map[shortName];
            }
            map[shortName] = !!value;
            storageFunction(map);
        }
        /*
        function countResponses(id) {
            var count = 0;
            allStories.forEach((story) => {
                var value = story.fieldValue(id);
                if (value !== undefined && value !== null && value !== {} && value !== "") count++;
            });
            return count;
        }
        */
        function increment(theObject, fieldName) {
            var count = theObject[fieldName] || 0;
            count++;
            theObject[fieldName] = count;
        }
        function bin(value) {
            var bin = Math.floor(value / 10);
            var high = bin * 10 + 9;
            if (bin >= 9) {
                bin = 9;
                high = 100;
            }
            var low = bin * 10;
            return "" + low + " - " + high;
        }
        function countAnswers(id, questionType) {
            var answerCounts = {};
            var answeredQuestionsCount = 0;
            var naCount = 0;
            allStories.forEach(function (story) {
                var value = story.fieldValue(id);
                if (value !== undefined && value !== null && value !== {} && value !== "") {
                    answeredQuestionsCount++;
                    if (questionType === "slider") {
                        // Bin the sliders
                        increment(answerCounts, bin(value));
                    }
                    else if (typeof value === "string" || typeof value === "number") {
                        increment(answerCounts, value);
                    }
                    else {
                        for (var key in value) {
                            if (value[key]) {
                                increment(answerCounts, key);
                            }
                        }
                    }
                }
                else {
                    naCount++;
                }
            });
            if (naCount)
                answerCounts["{N/A}"] = naCount;
            var sortedAnswerCounts = {};
            Object.keys(answerCounts).sort().forEach(function (key) {
                sortedAnswerCounts[key] = answerCounts[key];
            });
            return {
                answeredQuestionsCount: answeredQuestionsCount,
                answerCounts: sortedAnswerCounts
            };
        }
        function buildQuestionCheckbox(shortName, questionType, questionCategory) {
            var id = questionCategory + shortName;
            if (questionType === "textarea" || (questionCategory !== "A_" && questionType === "text"))
                return [];
            var counts = countAnswers(id, questionType);
            var answersHover = id + " has " + counts.answeredQuestionsCount + " answers:\n" + JSON.stringify(counts.answerCounts, null, 2);
            return m("div", { title: answersHover }, [
                m("input[type=checkbox]", { id: id, checked: isChecked(id), onchange: function (event) { isChecked(id, event.target.checked); } }),
                m("label", { "for": id }, shortName),
                m("br")
            ]);
        }
        function selectAll() {
            var map = {};
            allStoryQuestions.forEach(function (question) {
                map["S_" + question.storyQuestion_shortName] = true;
            });
            allParticipantQuestions.forEach(function (question) {
                map["P_" + question.participantQuestion_shortName] = true;
            });
            allAnnotationQuestions.forEach(function (question) {
                map["A_" + question.annotationQuestion_shortName] = true;
            });
            storageFunction(map);
        }
        function clearAll() {
            storageFunction({});
        }
        // TODO: Translate
        return m("div", [
            prompt,
            m("button", { onclick: selectAll }, "Select all"),
            m("button", { onclick: clearAll }, "Clear all"),
            m("br"),
            m("div", ["Total number of stories: " + allStories.length]),
            m("div", [
                m("br"),
                "Story questions:",
                m("br"),
                allStoryQuestions.map(function (question) {
                    return buildQuestionCheckbox(question.storyQuestion_shortName, question.storyQuestion_type, "S_");
                }),
                allStoryQuestions.length ? [] : "[No questions]",
                m("br"),
                "Participant questions:",
                m("br"),
                allParticipantQuestions.map(function (question) {
                    return buildQuestionCheckbox(question.participantQuestion_shortName, question.participantQuestion_type, "P_");
                }),
                allParticipantQuestions.length ? [] : "[No questions]",
                m("br"),
                "Annotation questions:",
                m("br"),
                allAnnotationQuestions.map(function (question) {
                    return buildQuestionCheckbox(question.annotationQuestion_shortName, question.annotationQuestion_type, "A_");
                }),
                allAnnotationQuestions.length ? [] : m("div", "[No questions]")
            ])
        ]);
    }
    return add_catalysisReportQuestionChooser;
});

define('js/applicationWidgets/add_clusteringDiagram',["require", "exports", "./ClusteringDiagram", "mithril", "../panelBuilder/valuePathResolver"], function (require, exports, ClusteringDiagram, m, valuePathResolver) {
    "use strict";
    function add_clusteringDiagram(panelBuilder, model, fieldSpecification) {
        // clustering diagram using a list of 2D objects
        // console.log("add_clusteringDiagram", model, fieldSpecification);
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var storageFunction = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        var clusteringDiagram = m.component(ClusteringDiagram, { key: fieldSpecification.id, storageFunction: storageFunction, autosave: true });
        // TODO: Who should be responsible for updating this data? Is redraw called or is that bypassed as an html component?
        return m("div", [
            prompt,
            clusteringDiagram
        ]);
    }
    return add_clusteringDiagram;
});

define('js/applicationWidgets/add_dashboardSectionStatusDisplay',["require", "exports", "../panelBuilder/translate", "mithril", "../Globals"], function (require, exports, translate, m, Globals) {
    "use strict";
    // TODO: translate
    function stepPlural(count) {
        if (count === 1)
            return "step";
        return "steps";
    }
    function add_dashboardSectionStatusDisplay(panelBuilder, model, fieldSpecification) {
        var sectionName = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt);
        // TODO: Kludge of using field id to determine what section this refers to
        var pageID = fieldSpecification.id.replace("project_launchSection_", "page_");
        var childPageIDs;
        // This collection could be null during testing
        var panelSpecificationCollection = panelBuilder.panelSpecificationCollection;
        if (!panelSpecificationCollection) {
            var errorMessage = "ERROR: panelBuilder.panelSpecificationCollection is null";
            console.log("ERROR", errorMessage);
            return m("div", { "class": "errorMessage" }, errorMessage);
        }
        childPageIDs = panelSpecificationCollection.getChildPageIDListForHeaderID(pageID);
        // console.log("child pages", pageID, childPageIDs);
        if (!childPageIDs)
            childPageIDs = [];
        var pageStatus = {
            "completely finished": 0,
            "partially done": 0,
            "intentionally skipped": 0,
            "null": 0,
            "undefined": 0
        };
        for (var childPageIndex = 0; childPageIndex < childPageIDs.length; childPageIndex++) {
            var childPageID = childPageIDs[childPageIndex];
            var statusViewID = childPageID + "_pageStatus";
            // console.log("statusViewID", fieldSpecification.id, statusViewID);
            // TODO: Fix if different sections get split up
            var status = Globals.project().tripleStore.queryLatestC(model, statusViewID);
            var count = pageStatus["" + status] || 0;
            count++;
            pageStatus["" + status] = count;
        }
        var pageCount = 0;
        for (var key in pageStatus) {
            pageCount += pageStatus[key];
        }
        var unfinishedPageCount = pageStatus["undefined"] + pageStatus["null"] + pageStatus["partially done"];
        var finishedPageCount = pageStatus["completely finished"] + pageStatus["intentionally skipped"];
        var percentDone = 0;
        if (pageCount)
            percentDone = Math.round(100 * finishedPageCount / pageCount);
        // TODO: No longer need to calculate statusText? Probably should rmeove this...
        // TODO: Translate
        var statusText = " -- All " + pageCount + " steps complete (100%)";
        if (unfinishedPageCount) {
            statusText = "" + finishedPageCount + " " + stepPlural(finishedPageCount) + " of " + pageCount + " complete (" + percentDone + "%)";
        }
        if (pageCount === 0)
            statusText = "";
        // console.log("statusText for pageStatus", statusText, pageStatus);
        // if (fieldSpecification.displayClass) options.class = fieldSpecification.displayClass;
        // if (fieldSpecification.displayIconClass) options.iconClass = fieldSpecification.displayIconClass;
        var callback = panelBuilder.buttonClicked.bind(panelBuilder, model, fieldSpecification);
        var options = {
            onclick: callback,
            "class": "narrafirma-dashboardStatusButton"
        };
        var button = m("button", options, sectionName);
        // TODO: Improve the naming of displayPreventBreak, maybe by using displayConfiguration somehow, perhaps by changing the meaning of that field to something else
        return [button, m("br")];
        // return [button, statusText];
        // TODO: Need to rethinking what this does for changes elsewhere to page status storage to reminders
        //statusText = "";
        //var htmlText = '<span class="narrafirma-dashboardSectionStatusDisplayCompletion">' + statusText + '</span><br>';
        //panelBuilder.addHTML(contentPane, htmlText);
    }
    return add_dashboardSectionStatusDisplay;
});

define('js/applicationWidgets/add_dashboardStoryCollectionStatusDisplay',["require", "exports", "../surveyCollection", "mithril", "../Globals"], function (require, exports, surveyCollection, m, Globals) {
    "use strict";
    function add_dashboardStoryCollectionStatusDisplay(panelBuilder, model, fieldSpecification) {
        var tripleStore = Globals.project().tripleStore;
        var storyCollectionsIdentifiers = Globals.project().getListForField("project_storyCollections");
        if (!storyCollectionsIdentifiers || !storyCollectionsIdentifiers.length) {
            // TODO: Translate
            return m("div", ["No story collections defined"]);
        }
        var storyCollections = storyCollectionsIdentifiers.map(function (storyCollectionIdentifier) {
            var shortName = tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_shortName");
            var allStoriesInStoryCollection = surveyCollection.getStoriesForStoryCollection(shortName);
            var storyCount = allStoriesInStoryCollection.length;
            var activeOnWeb = tripleStore.queryLatestC(storyCollectionIdentifier, "storyCollection_activeOnWeb");
            if (activeOnWeb) {
                console.log("active on web: ", shortName, storyCollectionIdentifier);
            }
            var surveyURL = activeOnWeb ? surveyCollection.urlForSurvey(storyCollectionIdentifier) : "";
            return {
                id: storyCollectionIdentifier,
                shortName: shortName,
                storyCount: storyCount,
                activeOnWeb: activeOnWeb,
                surveyURL: surveyURL
            };
        });
        storyCollections.sort(function (a, b) {
            var aName = a.shortName || "";
            var bName = b.shortName || "";
            return aName.localeCompare(bName);
        });
        return m("div.narrafirma-dashboard-story-collection-status", [
            m("p", "Story collections:"),
            m("table", m("tr", [m("th", "Name"), m("th", "#"), m("th", "Active?")]), storyCollections.map(function (storyCollection) {
                var surveyActive = storyCollection.activeOnWeb ? m("a", { href: storyCollection.surveyURL, target: "_blank" }, "active") : "";
                return m("tr", [
                    m("td", storyCollection.shortName),
                    m("td", { style: "text-align: right;" }, storyCollection.storyCount),
                    m("td", surveyActive),
                ]);
            }))
        ]);
    }
    return add_dashboardStoryCollectionStatusDisplay;
});

define('js/applicationWidgets/GraphBrowser',["require", "exports", "./charting", "../questionnaireGeneration", "../surveyCollection", "../panelBuilder/valuePathResolver", "../Project", "mithril"], function (require, exports, charting, questionnaireGeneration, surveyCollection, valuePathResolver, Project, m) {
    "use strict";
    function questionForID(questions, id) {
        if (!id)
            return null;
        for (var index in questions) {
            var question = questions[index];
            if (question.id === id)
                return question;
        }
        console.log("ERROR: question not found for id", id, questions);
        return null;
    }
    var GraphBrowser = (function () {
        function GraphBrowser(args) {
            this.xAxisSelectValue = null;
            this.yAxisSelectValue = null;
            this.questions = [];
            this.choices = [];
            this.storyCollectionIdentifier = null;
            this.selectedStories = [];
            this.graphHolder = {
                graphResultsPane: charting.createGraphResultsPane("narrafirma-graph-results-pane"),
                chartPanes: [],
                allStories: [],
                currentGraph: null,
                currentSelectionExtentPercentages: null,
                minimumStoryCountRequiredForTest: Project.defaultMinimumStoryCountRequiredForTest
            };
        }
        GraphBrowser.controller = function (args) {
            // console.log("Making GraphBrowser: ", args);
            return new GraphBrowser(args);
        };
        GraphBrowser.view = function (controller, args) {
            // console.log("GraphBrowser view called");
            return controller.calculateView(args);
        };
        // TODO: Translate
        // TODO: Track new incoming stories
        GraphBrowser.prototype.calculateView = function (args) {
            // console.log("GraphBrowser view called", this);
            var _this = this;
            // Handling of caching of questions and stories
            var storyCollectionIdentifier = valuePathResolver.newValuePathForFieldSpecification(args.model, args.fieldSpecification)();
            if (storyCollectionIdentifier !== this.storyCollectionIdentifier) {
                // TODO: Maybe need to handle tracking if list changed so can keep sorted list?
                this.storyCollectionIdentifier = storyCollectionIdentifier;
                // console.log("storyCollectionIdentifier changed", this.storyCollectionIdentifier);
                this.currentStoryCollectionChanged(this.storyCollectionIdentifier);
            }
            var parts;
            if (!this.storyCollectionIdentifier) {
                parts = [m("div", "Please select a story collection to view")];
            }
            else {
                parts = [
                    m("select.graphBrowserSelect", { onchange: function (event) { _this.xAxisSelectValue = event.target.value; _this.updateGraph(); } }, this.calculateOptionsForChoices(this.xAxisSelectValue)),
                    " versus ",
                    m("select.graphBrowserSelect", { onchange: function (event) { _this.yAxisSelectValue = event.target.value; _this.updateGraph(); } }, this.calculateOptionsForChoices(this.yAxisSelectValue)),
                    m("br"),
                    m("div", { config: this.insertGraphResultsPaneConfig.bind(this) }),
                    m("div.narrafirma-graphbrowser-heading", "Selected stories (" + this.selectedStories.length + ")"),
                    this.selectedStories.map(function (story) {
                        // console.log("story", story);
                        return m("div", [
                            m("b", story.storyName()),
                            m("br"),
                            m("blockquote", story.storyText())
                        ]);
                    })
                ];
            }
            // TODO: Need to set class
            return m("div", parts);
            /*
            // TODO: Should provide copy of item?
            var panelBuilder: PanelBuilder = args.panelBuilder;
            // Possible recursion if the panels contain a table
            
            var theClass = "narrafirma-griditempanel-viewing";
            if (args.mode === "edit") {
                theClass = "narrafirma-griditempanel-editing";
            }
            return m("div", {"class": theClass}, panelBuilder.buildPanel(args.grid.itemPanelSpecification, args.item));
            */
        };
        GraphBrowser.prototype.insertGraphResultsPaneConfig = function (element, isInitialized, context) {
            if (!isInitialized) {
                element.appendChild(this.graphHolder.graphResultsPane);
            }
        };
        GraphBrowser.prototype.storiesSelected = function (selectedStories) {
            // TODO: Finish
            // console.log("Stories selected", selectedStories);
            this.selectedStories = selectedStories;
        };
        GraphBrowser.prototype.calculateOptionsForChoices = function (currentValue) {
            var options = this.choices.map(function (option) {
                var optionOptions = { value: option.value, selected: undefined };
                if (currentValue === option.value)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.label);
            });
            var hasNoSelection = (currentValue === null || currentValue === undefined || currentValue === "") || undefined;
            options.unshift(m("option", { value: "", selected: hasNoSelection }, "--- select ---"));
            return options;
        };
        GraphBrowser.prototype.currentStoryCollectionChanged = function (storyCollectionIdentifier) {
            this.storyCollectionIdentifier = storyCollectionIdentifier;
            // Update selects for new question choices
            this.questions = questionnaireGeneration.collectAllQuestions();
            // console.log("----------- questions", this.questions);
            this.choices = surveyCollection.optionsForAllQuestions(this.questions, "excludeTextQuestions");
            // update all stories for the specific collection and update graph
            this.loadLatestStories();
        };
        GraphBrowser.prototype.loadLatestStories = function () {
            // console.log("loadLatestStories", this);
            this.graphHolder.allStories = surveyCollection.getStoriesForStoryCollection(this.storyCollectionIdentifier);
            // console.log("allStories", this.graphHolder.allStories);
            this.updateGraph();
        };
        GraphBrowser.prototype.updateGraph = function () {
            // console.log("updateGraph", this);
            var xAxisQuestionID = this.xAxisSelectValue;
            var yAxisQuestionID = this.yAxisSelectValue;
            // Remove old graph(s)
            while (this.graphHolder.chartPanes.length) {
                var chartPane = this.graphHolder.chartPanes.pop();
                this.graphHolder.graphResultsPane.removeChild(chartPane);
            }
            // Need to remove the float end node, if any        
            while (this.graphHolder.graphResultsPane.firstChild) {
                this.graphHolder.graphResultsPane.removeChild(this.graphHolder.graphResultsPane.firstChild);
            }
            this.selectedStories = [];
            // TODO: Translated or improve checking or provide alternate handling if only one selected
            if (!xAxisQuestionID && !yAxisQuestionID)
                return; // alert("Please select a question for one or both graph axes");
            var xAxisQuestion = questionForID(this.questions, xAxisQuestionID);
            var yAxisQuestion = questionForID(this.questions, yAxisQuestionID);
            // Ensure xAxisQuestion is always defined
            if (!xAxisQuestion) {
                xAxisQuestion = yAxisQuestion;
                yAxisQuestion = null;
            }
            // console.log("x y axis values", xAxisQuestion, yAxisQuestion);
            if (!xAxisQuestion)
                return;
            var xType = "choice";
            var yType = null;
            if (xAxisQuestion.displayType === "slider") {
                xType = "scale";
            }
            if (yAxisQuestion) {
                if (yAxisQuestion.displayType === "slider") {
                    yType = "scale";
                }
                else {
                    yType = "choice";
                }
            }
            // console.log("types x y", xType, yType);
            if (xType === "choice" && yType === null) {
                // console.log("plot choice: Bar graph");
                // console.log("barGraph", xAxisQuestion);
                charting.d3BarChart(this.graphHolder, xAxisQuestion, this.storiesSelected.bind(this));
            }
            else if (xType === "choice" && yType === "choice") {
                // console.log("plot choice: Contingency table");
                charting.d3ContingencyTable(this.graphHolder, xAxisQuestion, yAxisQuestion, this.storiesSelected.bind(this));
            }
            else if (xType === "choice" && yType === "scale") {
                // console.log("plot choice: Multiple histograms");
                charting.multipleHistograms(this.graphHolder, xAxisQuestion, yAxisQuestion, this.storiesSelected.bind(this));
            }
            else if (xType === "scale" && yType === null) {
                // console.log("plot choice: Histogram");
                charting.d3HistogramChart(this.graphHolder, xAxisQuestion, null, null, this.storiesSelected.bind(this));
            }
            else if (xType === "scale" && yType === "choice") {
                // console.log("plot choice: Multiple histograms");
                charting.multipleHistograms(this.graphHolder, yAxisQuestion, xAxisQuestion, this.storiesSelected.bind(this));
            }
            else if (xType === "scale" && yType === "scale") {
                // console.log("plot choice: Scatter plot");
                charting.d3ScatterPlot(this.graphHolder, xAxisQuestion, yAxisQuestion, this.storiesSelected.bind(this));
            }
            else {
                console.log("ERROR: Unexpected graph type");
                alert("ERROR: Unexpected graph type");
                return;
            }
        };
        return GraphBrowser;
    })();
    return GraphBrowser;
});

define('js/applicationWidgets/add_graphBrowser',["require", "exports", "mithril", "./GraphBrowser"], function (require, exports, m, GraphBrowser) {
    "use strict";
    function add_graphBrowser(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var graphBrowser = m.component(GraphBrowser, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification });
        // insertGraphBrowser(panelBuilder, model, fieldSpecification);
        return m("div", [
            prompt,
            graphBrowser
        ]);
    }
    return add_graphBrowser;
});

define('js/applicationWidgets/add_questionAnswer',["require", "exports", "../panelBuilder/translate", "mithril", "../sanitizeHTML", "../panelBuilder/valuePathResolver"], function (require, exports, translate, m, sanitizeHTML, valuePathResolver) {
    "use strict";
    function div_for_value(value) {
        if (value === undefined || value === null)
            value = "";
        return '<div class="narrafirma-question-type-questionAnswer">' + value + '</div>';
    }
    /* TODO: This is only really needed for translation which is not fully worked out, but maybe OK enough without it?
    function calculate_questionAnswer(panelBuilder: PanelBuilder, model, referencedQuestionID) {
        // console.log("calculate_questionAnswer", panelBuilder, model, referencedQuestionID);
        var value = panelBuilder.project.tripleStore.getLastestC(model, referencedQuestionID);
        if (value === undefined) {
            console.log("ERROR: missing question: ", referencedQuestionID);
            // throw new Error("ERROR: missing question: " + referencedQuestionID);
            value = null;
        }
        
        // if (value === null) value = translate("#question_not_yet_answered|(Not yet answered)");
        if (value === null) value = "";
            
        // This collection could be null during testing
        var panelSpecificationCollection = panelBuilder.panelSpecificationCollection;
        if (!panelSpecificationCollection) {
            var errorMessage = "ERROR: panelBuilder.panelSpecificationCollection is null";
            console.log("ERROR", errorMessage);
            return errorMessage;
        }
        
        var fieldSpecification = panelSpecificationCollection.getFieldSpecificationForFieldID(referencedQuestionID);
        if (fieldSpecification) {
            if (fieldSpecification.displayType === "select" ||  fieldSpecification.displayType === "checkboxes" || fieldSpecification.displayType === "radiobuttons") {
                // TODO: This may not translate correctly for checkboxes; may need to be translated individually
                // console.log("trying to translate select", value);
                // TODO: Possible issue here with incorrect translation if values leading "#" and then have a pipe bar in them
                value = translate(value, value);
            }
        } else {
            console.log("calculate_questionAnswer: missing fieldSpecification definition for: ", referencedQuestionID);
        }
        
        // console.log("calculate_questionAnswer value", value);
        return div_for_value(value);
    }
    */
    // TODO: This will not work when questions are on other pages with newer system
    function add_questionAnswer(panelBuilder, model, fieldSpecification) {
        // console.log("add_questionAnswer", fieldSpecification);
        var referencedQuestionID = fieldSpecification.displayConfiguration;
        if (!referencedQuestionID)
            throw new Error("missing referencedQuestionID for field: " + fieldSpecification.id + " all: " + JSON.stringify(fieldSpecification));
        var calculate = function () {
            var valueProperty = valuePathResolver.newValuePath(model, referencedQuestionID);
            var value = valueProperty();
            if (value === undefined || value === null)
                value = "";
            if (fieldSpecification.displayTransformValue)
                value = fieldSpecification.displayTransformValue(value, model, fieldSpecification, panelBuilder);
            return value;
        };
        // var label = panelBuilder._add_calculatedText(panelBuilder, fieldSpecification, function() {return div_for_value(calculate());});
        // TODO: Recalculating next two variables wheres they are also calculated in _add_calculatedText
        var baseText = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt);
        // var updateInfo = {"id": fieldSpecification.id, "label": label, "baseText": baseText, "calculate": calculate};
        // TODO: Who should track this data with Mithril? This component? Or should redraw be called automatically (or manually) on data change?
        //var watcher = panelBuilder.project.watchFieldValue(referencedQuestionID, function(triple, message) {
        //    panelBuilder.updateLabelUsingCalculation(updateInfo);
        //});
        // Klugde to get the contentPane to free the watcher by calling remove when it is destroyed
        // This would not work if the content pane continued to exist when replacing this component
        // contentPane.own(watcher);
        // TODO: Fix styling
        return m("div", { "class": "questionExternal narrafirma-question-type-questionAnswer" }, [
            sanitizeHTML.generateSanitizedHTMLForMithril(fieldSpecification.displayPrompt),
            m("div[class=narrafirma-questionAnswer]", calculate())
        ]);
    }
    return add_questionAnswer;
});

define('js/applicationWidgets/add_questionsTable',["require", "exports", "mithril"], function (require, exports, m) {
    "use strict";
    function add_questionsTable(panelBuilder, model, fieldSpecification) {
        return m("div", "add_questionsTable UNFINISHED");
        // TODO: Fix for Mithril
        /*
        var questionContentPane = panelBuilder.createQuestionContentPaneWithPrompt(fieldSpecification);
        
        var label = panelBuilder.newContentPane({
            // content: translate(id + "::prompt", fieldSpecification.displayPrompt)
            content: "<b>UNFINISHED add_questionsTable: " + fieldSpecification.id + "</b>"
        });
        label.placeAt(questionContentPane);
        return label;
        */
    }
    return add_questionsTable;
});

define('js/applicationWidgets/add_quizScoreResult',["require", "exports", "../panelBuilder/translate", "mithril", "../sanitizeHTML", "../Globals"], function (require, exports, translate, m, sanitizeHTML, Globals) {
    "use strict";
    function calculate_quizScoreResult(panelSpecificationCollection, modelFunction, dependsOn) {
        // console.log("quiz score result", dependsOn);
        if (!panelSpecificationCollection)
            return "ERROR in calculate_quizScoreResult: panelSpecificationCollection is not set";
        var total = 0;
        for (var dependsOnIndex = 0; dependsOnIndex < dependsOn.length; dependsOnIndex++) {
            var questionID = dependsOn[dependsOnIndex];
            var questionAnswer = modelFunction(questionID);
            // console.log("questionAnswer", questionAnswer, questionID);
            var answerWeight = 0;
            var index = 0;
            if (questionAnswer) {
                // console.log("questionAnswer", questionAnswer);
                var choices = panelSpecificationCollection.getFieldSpecificationForFieldID(questionID).valueOptions;
                index = choices.indexOf(questionAnswer);
                if (index === choices.length - 1) {
                    answerWeight = 0;
                }
                else {
                    answerWeight = index;
                }
                // console.log("answerWeight", answerWeight);
                if (answerWeight < 0)
                    answerWeight = 0;
                total += answerWeight;
            }
        }
        var possibleTotal = dependsOn.length * 3;
        var percent = Math.round(100 * total / possibleTotal);
        var template = translate("#calculate_quizScoreResult_template", "{{total}} of {{possibleTotal}} ({{percent}}%)");
        var response = template.replace("{{total}}", total).replace("{{possibleTotal}}", possibleTotal).replace("{{percent}}", "" + percent);
        //return "<b>" + response + "</b>";
        return response;
    }
    function add_quizScoreResult(panelBuilder, model, fieldSpecification) {
        var dependsOn = fieldSpecification.displayConfiguration;
        var modelFunction = Globals.project().tripleStore.makeModelFunction(model);
        var calculateResult = calculate_quizScoreResult(panelBuilder.panelSpecificationCollection, modelFunction, dependsOn);
        var baseText = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt);
        var labelText = panelBuilder.substituteCalculatedResultInBaseText(baseText, calculateResult);
        return m("div", { "class": "questionExternal narrafirma-question-type-quizScoreResult" }, sanitizeHTML.generateSanitizedHTMLForMithril(labelText));
    }
    // Make this function available for report generation
    // TODO: Should be a better way to do this
    add_quizScoreResult["calculate_quizScoreResult"] = calculate_quizScoreResult;
    return add_quizScoreResult;
});

define('js/RecommendationsParser',["require", "exports"], function (require, exports) {
    "use strict";
    // Process Recommendations CSV file 
    // File should have category header line to define categories with "# SECTION" to define sections and blank items between sections
    // Each row should have a header (# SECTION) or item with entries for every regular column with a blank line between sections
    /* Example:
    "",    "#Q1", "a1", "a2", "", "#Q2", "a1", "a2"
    "#C1",    "",   "",   "", "",    "",   "",   ""
    "op1",    "",  "1",  "2", "",    "",  "2",  "1"
    "op2",    "",  "3",  "4", "",    "",  "4",  "3"
       "",    "",   "",   "", "",    "",   "",   ""
    "#C2",    "",   "",   "", "",    "",   "",   ""
    "op1",    "",  "1",  "4", "",    "",  "3",   "1"
    "op2",    "",  "3",  "2", "",    "",  "4",   "1"
    */
    /* The JSON output looks like:
    {
      "Q1": {
        "op1": {
          "C1": {
            "Ven1": "1",
            "Ven2": "2"
          },
          "C2": {
            "Way1": "2",
            "Way2": "1"
          }
        },
        "op2": {
          "C1": {
            "Ven1": "3",
            "Ven2": "4"
          },
          "C2": {
            "Way1": "4",
            "Way2": "3"
          }
        }
      },
      "Q2": {
        "op1": {
          "C1": {
            "Ven1": "1",
            "Ven2": "4"
          },
          "C2": {
            "Way1": "3",
            "Way2": "1"
          }
        },
        "op2": {
          "C1": {
            "Ven1": "3",
            "Ven2": "2"
          },
          "C2": {
            "Way1": "4",
            "Way2": "1"
          }
        }
      }
    }
    */
    function startsWith(str, prefix) {
        return str.lastIndexOf(prefix, 0) === 0;
    }
    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    var RecommendationsParser = (function () {
        function RecommendationsParser(csvText) {
            this.matrix = [];
            this.matrixColumnCount = 0;
            this.matrixRowCount = 0;
            this.categories = null;
            this.questions = null;
            this.recommendations = null;
            this.parse(csvText);
        }
        RecommendationsParser.prototype.getMatrixValue = function (row, column) {
            if (row > this.matrixRowCount)
                return null;
            if (column > this.matrixColumnCount)
                return null;
            var line = this.matrix[row];
            // console.log("test1", column, line.length, line);
            if (column > line.length)
                return "";
            return line[column];
        };
        RecommendationsParser.prototype.loadMatrixFromCSVText = function (csvText) {
            // Load matrix
            this.matrix = [];
            this.matrixColumnCount = 0;
            this.matrixRowCount = 0;
            var lines = csvText.split("\r");
            // console.log(JSON.stringify(lines));
            for (var lineIndex in lines) {
                var line = lines[lineIndex];
                // console.log("line:", line.length, line.substring(0, 80), "...");
                // TODO: Will not handle embedded commas
                var splitLine = line.split(",");
                var lineItems = [];
                for (var index = 0; index < splitLine.length; index++) {
                    var item = splitLine[index].trim();
                    if (startsWith(item, '"') && endsWith(item, '"')) {
                        // console.log("trimming item '%s'", item);
                        item = item.substring(1, item.length - 1);
                        // Replace escaped double quotes
                        item = item.replace(/\"\"/, '"');
                    }
                    lineItems.push(item);
                }
                this.matrix.push(lineItems);
            }
            this.matrixRowCount = this.matrix.length;
            if (this.matrixRowCount > 0)
                this.matrixColumnCount = this.matrix[0].length;
            // console.log("matrixColumnCount %s, matrixRowCount %s", this.matrixColumnCount, this.matrixRowCount);
            // console.log("matrix", JSON.stringify(matrix, null, 2));
            // console.log("test retrieval 5,5", this.getMatrixValue(5, 5));
            // console.log("test retrieval 6,3", this.getMatrixValue(6, 6));
        };
        RecommendationsParser.prototype.addRecommendation = function (recommendations, columnCategory, columnField, rowCategory, rowField, item) {
            var question = recommendations[columnCategory];
            if (!question) {
                question = {};
                recommendations[columnCategory] = question;
            }
            var option = question[columnField];
            if (!option) {
                option = {};
                question[columnField] = option;
            }
            var category = option[rowCategory];
            if (!category) {
                category = {};
                option[rowCategory] = category;
            }
            category[rowField] = item;
        };
        RecommendationsParser.prototype.processRecommendationsMatrix = function () {
            var header = this.matrix[0];
            var columnCategory = null;
            var columnField = null;
            var rowCategory = null;
            var rowField = null;
            var recommendations = {};
            for (var lineIndex = 1; lineIndex < this.matrixRowCount; lineIndex++) {
                var line = this.matrix[lineIndex];
                rowField = this.getMatrixValue(lineIndex, 0).trim();
                if (rowField === "")
                    continue;
                if (startsWith(rowField, "#")) {
                    rowCategory = rowField.substring(1).trim();
                    if (rowCategory === "collectionSessions #sensemakingSessions")
                        rowCategory = "sessions";
                    rowField = null;
                    continue;
                }
                for (var columnIndex = 1; columnIndex < this.matrixColumnCount; columnIndex++) {
                    columnField = header[columnIndex].trim();
                    if (columnField === "")
                        continue;
                    if (startsWith(columnField, "#")) {
                        columnCategory = columnField.substring(1).trim();
                        columnField = null;
                        continue;
                    }
                    var item = this.getMatrixValue(lineIndex, columnIndex).trim();
                    this.addRecommendation(recommendations, columnCategory, columnField, rowCategory, rowField, item);
                }
            }
            return recommendations;
        };
        RecommendationsParser.prototype.buildCategories = function () {
            var result = {};
            var rowCategory = null;
            var rowField = null;
            for (var lineIndex = 1; lineIndex < this.matrixRowCount; lineIndex++) {
                var line = this.matrix[lineIndex];
                rowField = this.getMatrixValue(lineIndex, 0).trim();
                if (rowField === "")
                    continue;
                // console.log("rowField", rowField);
                if (startsWith(rowField, "#")) {
                    rowCategory = rowField.substring(1).trim();
                    if (rowCategory === "collectionSessions #sensemakingSessions")
                        rowCategory = "sessions";
                    rowField = null;
                    result[rowCategory] = [];
                    continue;
                }
                // console.log("pushing", "::", rowCategory, "::", rowField);
                result[rowCategory].push(rowField);
            }
            return result;
        };
        RecommendationsParser.prototype.buildQuestions = function () {
            var result = {};
            var columnCategory = null;
            var columnField = null;
            for (var columnIndex = 1; columnIndex < this.matrixColumnCount; columnIndex++) {
                columnField = this.getMatrixValue(0, columnIndex).trim();
                // console.log("columnField", columnField);
                if (columnField === "")
                    continue;
                if (startsWith(columnField, "#")) {
                    columnCategory = columnField.substring(1).trim();
                    columnField = null;
                    result[columnCategory] = [];
                    continue;
                }
                result[columnCategory].push(columnField);
            }
            return result;
        };
        RecommendationsParser.prototype.parse = function (csvText) {
            // console.log("Parsing recommendations", csvText);
            this.loadMatrixFromCSVText(csvText);
            this.categories = this.buildCategories();
            this.questions = this.buildQuestions();
            this.recommendations = this.processRecommendationsMatrix();
        };
        RecommendationsParser.recommendations = function () {
            // Lazy parsing of recommendaitons
            if (!RecommendationsParser.recommendationsObject) {
                var recommendationsText = window["narraFirma_recommendationsText"];
                RecommendationsParser.recommendationsObject = new RecommendationsParser(recommendationsText);
            }
            return RecommendationsParser.recommendationsObject;
        };
        RecommendationsParser.recommendationsIntervention = function () {
            // Lazy parsing of recommendaitons
            if (!RecommendationsParser.recommendationsInterventionObject) {
                var recommendationsInterventionText = window["narraFirma_recommendationsInterventionText"];
                RecommendationsParser.recommendationsInterventionObject = new RecommendationsParser(recommendationsInterventionText);
            }
            return RecommendationsParser.recommendationsInterventionObject;
        };
        return RecommendationsParser;
    })();
    return RecommendationsParser;
});

define('js/applicationWidgets/add_recommendationTable',["require", "exports", "../panelBuilder/dialogSupport", "../RecommendationsParser", "../panelBuilder/translate", "mithril", "../Globals"], function (require, exports, dialogSupport, RecommendationsParser, translate, m, Globals) {
    "use strict";
    function add_recommendationTable(panelBuilder, model, fieldSpecification) {
        var dialogConfiguration = {
            fieldSpecification: fieldSpecification,
            dialogModel: model,
            dialogTitle: "#title_recommendationsTable|Recommendations table",
            dialogStyle: "wide",
            dialogConstructionFunction: build_recommendationTable.bind(null, panelBuilder),
            dialogOKButtonLabel: "Close"
        };
        return dialogSupport.addButtonThatLaunchesDialog(fieldSpecification, dialogConfiguration);
    }
    function tagForRecommendationValue(recommendation) {
        if (recommendation === "no") {
            return "recommendationNo";
        }
        else if (recommendation === "maybe") {
            return "recommendationLow";
        }
        else if (recommendation === "good") {
            return "recommendationMedium";
        }
        else if (recommendation === "excellent") {
            return "recommendationHigh";
        }
        console.log("ERROR: Unexpected recommendation value", recommendation);
        return "";
    }
    function makeTableForParticipantGroup(categoryName, project, participantGroupIdentifier) {
        var recommendationsObject;
        if (categoryName === "interventions") {
            recommendationsObject = RecommendationsParser.recommendationsIntervention();
        }
        else {
            recommendationsObject = RecommendationsParser.recommendations();
        }
        // recommendations -> Question -> Answer -> Category -> Option
        // console.log("recommendationsObject", recommendationsObject);
        var optionsForCategory = recommendationsObject.categories[categoryName];
        if (!optionsForCategory) {
            console.log("ERROR: No data for recommendationTable category: ", categoryName);
            optionsForCategory = [];
        }
        // console.log("recommendations.questions", recommendationsObject.questions);
        var table = m("table.recommendationsTable", 
        // Do the header
        m("tr", [[
                m("th.wwsRecommendationsTable-valueCell", { colspan: 4, align: "right" }, m("i", "Question")),
                m("th.wwsRecommendationsTable-valueCell", { colspan: 2, align: "right" }, m("i", "Your answer"))
            ], optionsForCategory.map(function (headerFieldName) {
                return m("th.wwsRecommendationsTable-valueCell", m("i", { colspan: 1, align: "right" }, headerFieldName));
            })]), 
        // Now do one data row for each question considered in the recommendation
        // TODO: Maybe keys should be sorted somehow?
        Object.keys(recommendationsObject.questions).map(function (questionName) {
            // TODO: Possible should improve this translation default, maybe by retrieving fieldSpecification for question and getting displayPrompt?
            var questionText = translate(questionName + "::shortName", questionName);
            var yourAnswer = project.tripleStore.queryLatestC(participantGroupIdentifier, questionName);
            if (yourAnswer === undefined)
                yourAnswer = project.getFieldValue(questionName);
            if (yourAnswer === undefined)
                yourAnswer = "";
            // console.log("questionName yourAnswer", questionName, yourAnswer);
            // Don't put rows where there is no answer
            if (!yourAnswer)
                return [];
            // Drill down into the recommentations if they exists for questioName, yourAnswer, and categoryName
            var recommendationsForAnswer = recommendationsObject.recommendations[questionName];
            if (recommendationsForAnswer)
                recommendationsForAnswer = recommendationsForAnswer[yourAnswer];
            if (recommendationsForAnswer)
                recommendationsForAnswer = recommendationsForAnswer[categoryName];
            return m("tr", [[
                    m("th.wwsRecommendationsTable-valueCell", { colspan: 4, align: "right" }, questionText),
                    m("th.wwsRecommendationsTable-valueCell", { colspan: 2, align: "right" }, yourAnswer)
                ], optionsForCategory.map(function (optionName, index) {
                    var recommendationForOption = "???";
                    if (recommendationsForAnswer) {
                        recommendationForOption = recommendationsForAnswer[optionName];
                    }
                    else {
                        console.log("Missing recommendations for", questionName, yourAnswer);
                    }
                    if (!recommendationForOption) {
                        if (categoryName === "interventions") {
                            recommendationForOption = "maybe";
                        }
                        else {
                            recommendationForOption = "good";
                        }
                    }
                    if (recommendationForOption === "very good")
                        recommendationForOption = "excellent";
                    // TODO: Translate recommendation name 
                    var theClass = tagForRecommendationValue(recommendationForOption);
                    return m("td.wwsRecommendationsTable-labelCell", { colspan: 1, align: "right", "class": theClass }, recommendationForOption);
                })]);
        }));
        return table;
    }
    function build_recommendationTable(panelBuilder, dialogConfiguration, hideDialogCallback) {
        var model = dialogConfiguration.dialogModel;
        var fieldSpecification = dialogConfiguration.fieldSpecification;
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var categoryName = fieldSpecification.displayConfiguration;
        // console.log("add_recommendationTable category", categoryName);
        // var recommendationsForTopic = recommendationsObject.recommendations[categoryName];
        var participantGroups;
        var participantGroupNameFieldIdentifier;
        if (categoryName === "interventions") {
            participantGroups = Globals.project().getListForField("project_outcomesList");
            participantGroupNameFieldIdentifier = "outcomes_group";
            // TODO: Translate
            if (!participantGroups || !participantGroups.length)
                return m("div", "Please enter a project outcome first to get recommendations.");
        }
        else {
            participantGroups = Globals.project().getListForField("project_participantGroupsList");
            participantGroupNameFieldIdentifier = "participantGroup_name";
            // TODO: Translate
            if (!participantGroups || !participantGroups.length)
                return m("div", "Please enter a participant group first to get recommendations.");
        }
        // TODO: Set class on div
        return m("div", { "class": "narrafirma-recommendations-table " + categoryName }, [
            prompt,
            participantGroups.map(function (participantGroupIdentifier) {
                var participantGroupName = Globals.project().tripleStore.queryLatestC(participantGroupIdentifier, participantGroupNameFieldIdentifier);
                return m("div", [
                    m("b", participantGroupName),
                    m("br"),
                    m("br"),
                    makeTableForParticipantGroup(categoryName, Globals.project(), participantGroupIdentifier),
                    m("br"),
                    m("br")
                ]);
            })
        ]);
    }
    return add_recommendationTable;
});

define('js/applicationWidgets/add_report',["require", "exports", "mithril"], function (require, exports, m) {
    "use strict";
    function add_report(panelBuilder, model, fieldSpecification) {
        return m("div", "add_report UNFINISHED");
        // TODO: Fix for Mithril
        /*
        var headerPageID = "page_" + fieldSpecification.displayConfiguration;
        var calculate = reportGeneration.calculate_report.bind(null, panelBuilder.panelSpecificationCollection, model, headerPageID);
        // TODO: Fix when refactor
        return panelBuilder._add_calculatedText(panelBuilder, fieldSpecification, calculate);
        */
    }
    return add_report;
});

define('js/applicationWidgets/add_storiesList',["require", "exports", "mithril", "../Globals"], function (require, exports, m, Globals) {
    "use strict";
    function add_storiesList(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var tripleStore = Globals.project().tripleStore;
        // TODO: Generalize this so it can handle more complex value paths than just a project field name
        var storyIdentifierList = Globals.project().getListForField(fieldSpecification.valuePath);
        var storyNameField = "projectStory_name";
        var storyTextField = "projectStory_text";
        storyIdentifierList.sort(function (a, b) {
            var aName = tripleStore.queryLatestC(a, storyNameField) || "";
            var bName = tripleStore.queryLatestC(b, storyNameField) || "";
            return aName.localeCompare(bName);
        });
        return m("div.narrafirma-stories-list", [
            prompt,
            // m("div.narrafirma-stories-list-title", "Project stories:"),
            //m("br"),
            m("table", [
                m("tr", [m("th", "Story name"), m("th", "Story text")]),
                storyIdentifierList.map(function (storyIdentifier) {
                    // console.log("storyIdentifier", storyIdentifier);
                    return [
                        m("tr"),
                        [m("td", tripleStore.queryLatestC(storyIdentifier, storyNameField)),
                            m("td", tripleStore.queryLatestC(storyIdentifier, storyTextField))]
                    ];
                })
            ])
        ]);
    }
    return add_storiesList;
});

define('js/applicationWidgets/StoryBrowser',["require", "exports", "../storyCardDisplay", "../questionnaireGeneration", "../surveyCollection", "../panelBuilder/valuePathResolver", "mithril", "../panelBuilder/GridWithItemPanel"], function (require, exports, storyCardDisplay, questionnaireGeneration, surveyCollection, valuePathResolver, m, GridWithItemPanel) {
    "use strict";
    // story browser support
    // TODO: Need to update answer counts in filters if change value in story that affectes selected filter question
    // TODO: Translate
    var unansweredIndicator = "{Unanswered}";
    function isMatch(story, questionChoice, selectedAnswerChoices) {
        // console.log("isMatch", questionChoice, selectedAnswerChoices);
        if (!questionChoice)
            return true;
        var questionAnswer = story.fieldValue(questionChoice.id);
        if (questionAnswer === undefined || questionAnswer === null || questionAnswer === "") {
            questionAnswer = unansweredIndicator;
        }
        else if (typeof questionAnswer === "object") {
            // checkboxes
            // console.log("checkboxes", questionAnswer);
            for (var key in questionAnswer) {
                if (selectedAnswerChoices[key] && questionAnswer[key])
                    return true;
            }
            return false;
        }
        questionAnswer = "" + questionAnswer;
        // console.log("questionAnswer", questionAnswer);
        return !!selectedAnswerChoices[questionAnswer];
    }
    function optionsFromQuestion(question, stories) {
        // console.log("*** optionsFromQuestion", question, stories);
        // TODO: Translate text for options, at least booleans?
        var options = [];
        if (!question)
            return options;
        // Compute how many of each answer -- assumes typically less than 200-1000 stories
        var totals = {};
        stories.forEach(function (story) {
            // console.log("optionsFromQuestion item", item, question.id, item[question.id]);
            var choice = story.fieldValue(question.id);
            if (choice === undefined || choice === null || choice === "") {
                // Do not include "0" as unanswered
                // console.log("&&&& Undefined or empty choice", choice);
                choice = unansweredIndicator;
            }
            var oldValue;
            if (question.displayType === "checkboxes") {
                for (var key in choice) {
                    oldValue = totals[key];
                    if (!oldValue)
                        oldValue = 0;
                    if (choice[key])
                        totals[key] = oldValue + 1;
                }
            }
            else {
                oldValue = totals[choice];
                if (!oldValue)
                    oldValue = 0;
                totals[choice] = oldValue + 1;
            }
        });
        var count;
        if (question.displayType === "select") {
            // console.log("select", question, question.valueOptions);
            question.valueOptions.forEach(function (each) {
                // console.log("option", question.id, each);
                count = totals[each];
                if (!count)
                    count = 0;
                options.push({ label: each + " (" + count + ")", value: each });
            });
        }
        else if (question.displayType === "radiobuttons") {
            // console.log("radiobuttons", question, question.valueOptions);
            question.valueOptions.forEach(function (each) {
                // console.log("option", question.id, each);
                count = totals[each];
                if (!count)
                    count = 0;
                options.push({ label: each + " (" + count + ")", value: each });
            });
        }
        else if (question.displayType === "checkboxes") {
            // console.log("checkboxes", question, question.valueOptions);
            question.valueOptions.forEach(function (each) {
                // console.log("option", question.id, each);
                count = totals[each];
                if (!count)
                    count = 0;
                options.push({ label: each + " (" + count + ")", value: each });
            });
        }
        else if (question.displayType === "slider") {
            // console.log("slider", question, question.displayConfiguration);
            for (var sliderTick = 0; sliderTick <= 100; sliderTick++) {
                count = totals[sliderTick];
                if (!count)
                    count = 0;
                var sliderTickText = "" + sliderTick;
                /*
                if (sliderTickText.length < 2) {
                    sliderTickText = "0" + sliderTickText;
                }
                if (sliderTickText.length < 3) {
                    sliderTickText = "0" + sliderTickText;
                }
                */
                options.push({ label: sliderTickText + " (" + count + ")", value: sliderTick });
            }
        }
        else if (question.displayType === "boolean") {
            // console.log("boolean", question);
            // TODO; Not sure this will really be right with true/false as booleans instead of strings
            ["true", "false"].forEach(function (each) {
                // console.log("option", id, each);
                count = totals[each];
                if (!count)
                    count = 0;
                options.push({ label: each + " (" + count + ")", value: each });
            });
        }
        else if (question.displayType === "checkbox") {
            // console.log("checkbox", question);
            // TODO; Not sure this will really be right with true/false as checkbox instead of strings
            [true, false].forEach(function (each) {
                // console.log("option", id, each);
                count = totals["" + each];
                if (!count)
                    count = 0;
                options.push({ label: each + " (" + count + ")", value: each });
            });
        }
        else if (question.displayType === "text") {
            for (var eachTotal in totals) {
                if (totals.hasOwnProperty(eachTotal)) {
                    count = totals[eachTotal];
                    if (!count)
                        count = 0;
                    options.push({ label: eachTotal + " (" + count + ")", value: eachTotal });
                }
            }
        }
        else {
            console.log("ERROR: question type not supported: ", question.displayType, question);
            options.push({ label: "*ALL*" + " (" + stories.length + ")", value: "*ALL*" });
        }
        // TODO: Maybe should not add the unanswered indicator if zero?
        // Always add the unanswered indicator if not checkboxes or checkbox
        if (question.displayType !== "checkbox" && question.displayType !== "checkboxes") {
            count = totals[unansweredIndicator];
            if (!count)
                count = 0;
            options.push({ label: unansweredIndicator + " (" + count + ")", value: unansweredIndicator });
        }
        /*
        // Sort options by their name -- only if not slider numbers which are already ordered
        if (question.displayType !== "slider") {
            options.sort(function(a, b) {
                if (a.label.toLowerCase() < b.label.toLowerCase()) return -1;
                if (a.label.toLowerCase() > b.label.toLowerCase()) return 1;
                return 0;
            });
        }
        */
        return options;
    }
    function getSelectedOptions(select) {
        var selectedOptions = {};
        // select.selectedOptions is probably not implemented widely enough, so use this looping code instead over all options
        for (var i = 0; i < select.options.length; i++) {
            var option = select.options[i];
            if (option.selected) {
                selectedOptions[option.value] = option;
            }
        }
        return selectedOptions;
    }
    var Filter = (function () {
        function Filter(args) {
            this.name = null;
            this.storyBrowser = null;
            this.selectedQuestion = null;
            this.answerOptionsForSelectedQuestion = [];
            this.selectedAnswers = {};
            this.storyBrowser = args.storyBrowser;
            this.name = args.name;
        }
        Filter.controller = function (args) {
            // console.log("Making Filter: ", args.name);
            return new Filter(args);
        };
        Filter.view = function (controller, args) {
            // console.log("Filter view called");
            return controller.calculateView();
        };
        Filter.prototype.calculateView = function () {
            var _this = this;
            // console.log("calculateView this", this);
            var choices = this.storyBrowser.choices || [];
            // console.log("^^^^^^^^^^^^ filter choices", choices);
            var selectOptions = choices.map(function (option) {
                var optionOptions = { value: option.value, selected: undefined };
                if (_this.selectedQuestion === option.value)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.label);
            });
            var isNoSelection = (this.selectedQuestion === null) || undefined;
            selectOptions.unshift(m("option", { value: "", selected: isNoSelection }, "--- no filter ---"));
            var multiselectOptions = this.answerOptionsForSelectedQuestion.map(function (option) {
                var optionOptions = { value: option.value, selected: undefined };
                if (_this.selectedAnswers[option.value])
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.label);
            });
            var isClearButtonDisabled = (this.selectedQuestion === null) || undefined;
            return m("div.filter", [
                this.name,
                m("br"),
                m("select", { onchange: this.filterPaneQuestionChoiceChanged.bind(this) }, selectOptions),
                m("button", { disabled: isClearButtonDisabled, onclick: this.clearFilterPane.bind(this) }, "Clear"),
                m("br"),
                m("select", { onchange: this.filterPaneAnswerChoiceChanged.bind(this), multiple: "multiple" }, multiselectOptions)
            ]);
        };
        Filter.prototype.filterPaneQuestionChoiceChanged = function (event) {
            var question = getQuestionDataForSelection(this.storyBrowser.questions, event);
            this.selectedQuestion = question;
            this.answerOptionsForSelectedQuestion = optionsFromQuestion(this.selectedQuestion, this.storyBrowser.allStories);
            this.selectedAnswers = {};
            this.storyBrowser.setStoryListForCurrentFilters();
        };
        Filter.prototype.filterPaneAnswerChoiceChanged = function (event) {
            this.selectedAnswers = getSelectedOptions(event.target);
            this.storyBrowser.setStoryListForCurrentFilters();
        };
        Filter.prototype.resetChoices = function () {
            this.selectedQuestion = null;
            this.answerOptionsForSelectedQuestion = [];
            this.selectedAnswers = {};
        };
        Filter.prototype.clearFilterPane = function () {
            this.resetChoices();
            this.storyBrowser.setStoryListForCurrentFilters();
        };
        return Filter;
    })();
    function getQuestionDataForSelection(questions, event) {
        var newValue = event.target.value;
        var question = null;
        for (var index = 0; index < questions.length; index++) {
            var questionToCheck = questions[index];
            if (questionToCheck.id === newValue) {
                question = questionToCheck;
                break;
            }
        }
        //console.log("filterPaneQuestionChoiceChanged", question);
        if (!question && newValue)
            console.log("could not find question for id", newValue);
        return question;
    }
    var StoryBrowser = (function () {
        function StoryBrowser(args) {
            this.storyCollectionIdentifier = null;
            this.questions = [];
            this.choices = [];
            this.allStories = [];
            this.filteredStories = [];
            this.itemPanelSpecification = { id: "temporary", modelClass: "Story", panelFields: [] };
            this.gridFieldSpecification = null;
            this.grid = null;
            this.gridFieldSpecification = {
                id: "stories",
                displayConfiguration: {
                    itemPanelSpecification: this.itemPanelSpecification,
                    gridConfiguration: {
                        idProperty: "storyID",
                        columnsToDisplay: ["storyName", "storyText", "ignore"],
                        viewButton: true,
                        editButton: true,
                        navigationButtons: true
                    }
                }
            };
            this.filter1 = new Filter({ key: "First filter", name: "First filter", storyBrowser: this });
            this.filter2 = new Filter({ key: "Second filter", name: "Second filter", storyBrowser: this });
            this.grid = new GridWithItemPanel({ panelBuilder: args.panelBuilder, model: this, fieldSpecification: this.gridFieldSpecification });
        }
        StoryBrowser.controller = function (args) {
            // console.log("Making StoryBrowser: ", args.name);
            return new StoryBrowser(args);
        };
        StoryBrowser.view = function (controller, args) {
            // console.log("StoryBrowser view called");
            return controller.calculateView(args);
        };
        StoryBrowser.prototype.calculateView = function (args) {
            // console.log("StoryBrowser view");
            var panelBuilder = args.panelBuilder;
            // Handling of caching of questions and stories
            var storyCollectionIdentifier = valuePathResolver.newValuePathForFieldSpecification(args.model, args.fieldSpecification)();
            if (storyCollectionIdentifier !== this.storyCollectionIdentifier) {
                // TODO: Maybe need to handle tracking if list changed so can keep sorted list?
                this.storyCollectionIdentifier = storyCollectionIdentifier;
                // console.log("storyCollectionIdentifier changed", this.storyCollectionIdentifier);
                this.currentStoryCollectionChanged(this.storyCollectionIdentifier);
                // What to do about resetting the filters?
                this.filter1.resetChoices();
                this.filter2.resetChoices();
                // Need to update grid for change
                this.gridFieldSpecification.displayConfiguration.itemPanelSpecification = this.itemPanelSpecification;
                this.filteredStories = this.allStories;
                this.grid.updateDisplayConfigurationAndData(this.gridFieldSpecification.displayConfiguration);
            }
            var promptText = panelBuilder.addAllowedHTMLToPrompt(args.fieldSpecification.displayPrompt) + " (" + this.allStories.length + ")";
            var prompt = m("span", { "class": "questionPrompt" }, promptText);
            var parts;
            if (!this.storyCollectionIdentifier) {
                parts = [m("div", "Please select a story collection to view")];
            }
            else {
                var filter = m("table.filterTable", m("tr", [
                    m("td", this.filter1.calculateView()),
                    m("td", this.filter2.calculateView())
                ]));
                // TODO: Translation
                var filteredCountText = m("div.narrafirma-story-browser-filtered-stories-count", "Filtered stories (" + this.filteredStories.length + ")");
                parts = [prompt, filter, filteredCountText, this.grid.calculateView()];
            }
            return m("div", { "class": "questionExternal narrafirma-question-type-questionAnswer" }, parts);
        };
        // Not using m.prop for stories property as it makes debugging harder?
        StoryBrowser.prototype.stories = function () {
            return this.filteredStories;
        };
        StoryBrowser.prototype.currentStoryCollectionChanged = function (storyCollectionIdentifier) {
            // console.log("currentStoryCollectionChanged", this, storyCollectionIdentifier);
            // Update filters
            this.questions = questionnaireGeneration.collectAllQuestions("putAnnotationQuestionsUpFront");
            this.choices = surveyCollection.optionsForAllQuestions(this.questions);
            // update all stories for the specific collection
            this.allStories = surveyCollection.getStoriesForStoryCollection(storyCollectionIdentifier, true);
            this.itemPanelSpecification = this.makeItemPanelSpecificationForQuestions(this.questions);
            this.itemPanelSpecification.panelFields.push({
                id: "ignore",
                valueType: "string",
                displayType: "text",
                displayName: "Ignore",
                displayPrompt: "Reason to ignore story (enter any text here to leave this story out of all graphs and reports)",
                displayClass: "narrafirma-ignore-story"
            });
            /*
            // TODO: What to do about current selection in filter widgets?
            
            // Update item panel in grid
            this.storyList.changeItemPanelSpecification(itemPanelSpecification);
            
            this.loadLatestStories(allStories);
            
            // TODO: Should close up open grid view
            */
        };
        StoryBrowser.prototype.buildStoryDisplayPanel = function (panelBuilder, storyModel) {
            var storyDisplay;
            if (panelBuilder.readOnly) {
                storyDisplay = storyCardDisplay.generateStoryCardContent(storyModel, { "location": "storyBrowser" });
            }
            else {
                storyDisplay = panelBuilder.buildFields(this.questions, storyModel);
            }
            return storyDisplay;
        };
        StoryBrowser.prototype.makeItemPanelSpecificationForQuestions = function (questions) {
            // TODO: add more participant and survey info, like timestamps and participant ID
            var itemPanelSpecification = {
                id: "storyBrowserQuestions",
                modelClass: "Story",
                panelFields: questions,
                buildPanel: this.buildStoryDisplayPanel.bind(this)
            };
            return itemPanelSpecification;
        };
        StoryBrowser.prototype.getFilteredStoryList = function () {
            // console.log("filter pressed", storyBrowserInstance);
            var question1Choice = this.filter1.selectedQuestion;
            var answers1Choices = this.filter1.selectedAnswers;
            // console.log("question1", question1Choice, "answers1", answers1Choices);
            var question2Choice = this.filter2.selectedQuestion;
            var answers2Choices = this.filter2.selectedAnswers;
            // console.log("question2", question2Choice, "answers2", answers2Choices);  
            var filterFunction = function (item) {
                var match1 = isMatch(item, question1Choice, answers1Choices);
                var match2 = isMatch(item, question2Choice, answers2Choices);
                return match1 && match2;
            };
            var filteredResults = this.allStories.filter(filterFunction);
            return filteredResults;
        };
        StoryBrowser.prototype.setStoryListForCurrentFilters = function () {
            var filteredResults = this.getFilteredStoryList();
            // console.log("Filtered results", filteredResults);
            this.filteredStories = filteredResults;
            this.grid.updateData();
            // console.log("finished setting list with filtered results", filteredResults);
        };
        return StoryBrowser;
    })();
    return StoryBrowser;
});

define('js/applicationWidgets/add_storyBrowser',["require", "exports", "mithril", "./StoryBrowser"], function (require, exports, m, StoryBrowser) {
    "use strict";
    function add_storyBrowser(panelBuilder, model, fieldSpecification) {
        return m.component(StoryBrowser, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification });
    }
    return add_storyBrowser;
});

define('js/templates/templates',["require", "exports"], function (require, exports) {
    "use strict";
    // TODO: Fix mixed tabs and spaces and remove part of next line which disables indent check
    /* tslint:disable:max-line-length indent */
    // TODO: Note everything has a shortName; id currently being used in those cases; do we really need both id and shortName?
    var templates = [
        {
            "id": "elicitationQuestions",
            "name": "Elicitation questions",
            "questions": [
                {
                    "id": "topic_timeWhenYouFelt",
                    "shortName": "When you felt",
                    "text": "Was there ever a time when you felt _____? What happened then?",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "topic_everThought",
                    "shortName": "Ever thought",
                    "text": "Have you ever thought ____? What happened that made you think that?",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "topic_causedAChange",
                    "shortName": "Caused a change",
                    "text": "Was there ever a change in your ___ about ___? What happened that caused the change?",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "topic_doingSomethingBecauseYouFelt",
                    "shortName": "Doing something because you felt",
                    "text": "Can you remember ever ____ because you felt ___? What happened that made you feel that way?",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "topic_aTimeWhenYouSomethingBecauseOf",
                    "shortName": "A time when you something because of",
                    "text": "Think of a time when you ____ because of ____.",
                    "category": "Topic",
                    "type": "label"
                },
                {
                    "id": "time_whatHappenedFirstTime",
                    "shortName": "What happened first time",
                    "text": "What happened the (first, last, most recent) time you ____?",
                    "category": "Point in time (specific)",
                    "type": "label"
                },
                {
                    "id": "time_aboutYourSomething",
                    "shortName": "About your something",
                    "text": "Tell me about your ___. What happened during it?",
                    "category": "Point in time (specific)",
                    "type": "label"
                },
                {
                    "id": "time_whatJustHappened",
                    "shortName": "What just happened",
                    "text": "What just happened? Can you tell us about it?",
                    "category": "Point in time (specific)",
                    "type": "label"
                },
                {
                    "id": "time_mostMemorable",
                    "shortName": "Most memorable",
                    "text": "What was the most memorable ___ during ____?",
                    "category": "Point in time (memorable)",
                    "type": "label"
                },
                {
                    "id": "time_standsOutInMemory",
                    "shortName": "Stands out in memory",
                    "text": "Was there a time during ___ that stands out in your memory?",
                    "category": "Point in time (memorable)",
                    "type": "label"
                },
                {
                    "id": "time_momentWasMostSomething",
                    "shortName": "Moment was most something",
                    "text": "What moment during ___ was most ____ to you? What happened in that moment?",
                    "category": "Point in time (memorable)",
                    "type": "label"
                },
                {
                    "id": "time_happenedThatMadeYouFeel",
                    "shortName": "Happened that made you feel",
                    "text": "During ____, did anything happen that made you feel ___? What was it that happened?",
                    "category": "Point in time (emotion)",
                    "type": "label"
                },
                {
                    "id": "time_mostSomethingHour",
                    "shortName": "Most something hour",
                    "text": "What has been your (most, least) ___ hour as a ____?",
                    "category": "Point in time (emotion)",
                    "type": "label"
                },
                {
                    "id": "time_whenYouFelt",
                    "shortName": "When you felt",
                    "text": "Was there ever a time during ____ when you felt ___? What happened that made you feel that way?",
                    "category": "Point in time (emotion)",
                    "type": "label"
                },
                {
                    "id": "time_feltTopicWas",
                    "shortName": "Felt topic was",
                    "text": "Was there ever a moment when you felt that (a project topic) was ___?",
                    "category": "Point in time (topic)",
                    "type": "label"
                },
                {
                    "id": "time_foundYourselfMost",
                    "shortName": "Found yourself most",
                    "text": "At what point during ____ did you find yourself the most (project topic)?",
                    "category": "Point in time (topic)",
                    "type": "label"
                },
                {
                    "id": "time_emotionWasInState",
                    "shortName": "Emotion was in state",
                    "text": "Recall for us a moment when (an emotion) was (in a state) during ____.",
                    "category": "Point in time (topic)",
                    "type": "label"
                },
                {
                    "id": "event_standsOut",
                    "shortName": "Stands out",
                    "text": "What event most stands out in your mind during ____?",
                    "category": "Event (memorable)",
                    "type": "label"
                },
                {
                    "id": "event_willRemember",
                    "shortName": "Will remember",
                    "text": "Did anything happen (today, this week, etc) that you will remember for a long time?",
                    "category": "Event (memorable)",
                    "type": "label"
                },
                {
                    "id": "event_importantToYou",
                    "shortName": "Important to you",
                    "text": "Can you describe an incident in the past (day, week, etc) that is important to you?",
                    "category": "Event (memorable)",
                    "type": "label"
                },
                {
                    "id": "event_causedToFeel",
                    "shortName": "Caused to feel",
                    "text": "Did any particular event or incident cause you to feel ___ during ____?",
                    "category": "Event (emotion)",
                    "type": "label"
                },
                {
                    "id": "event_feltSomething",
                    "shortName": "Felt something",
                    "text": "Tell me about a time when you felt ____. What happened?",
                    "category": "Event (emotion)",
                    "type": "label"
                },
                {
                    "id": "event_feltSomethingWasSomething",
                    "shortName": "Felt something was something",
                    "text": "Can you recall a situation when you felt that ____ was _____?",
                    "category": "Event (emotion)",
                    "type": "label"
                },
                {
                    "id": "event_proverb",
                    "shortName": "Proverb",
                    "text": "When you consider the (motto, saying, proverb) ____, was there a moment during ____ when you felt that this (motto, saying, proverb) was especially ____?",
                    "category": "Event (topic)",
                    "type": "label"
                },
                {
                    "id": "event_situationInWhich",
                    "shortName": "Situation in which",
                    "text": "Could you tell us about a situation in which ___ was ____?",
                    "category": "Event (topic)",
                    "type": "label"
                },
                {
                    "id": "event_madeYouThink",
                    "shortName": "Made you think",
                    "text": "Did you ever experience anything that made you think ____? What happened?",
                    "category": "Event (topic)",
                    "type": "label"
                },
                {
                    "id": "extreme_highOrLowPoint",
                    "shortName": "High or low point",
                    "text": "Can you recall the (highlight, lowest point) of ___?",
                    "category": "Extreme (in general)",
                    "type": "label"
                },
                {
                    "id": "extreme_bestOrWorstThing",
                    "shortName": "Best or worst thing",
                    "text": "What was the (best, worst) thing that ever happened during ____?",
                    "category": "Extreme (in general)",
                    "type": "label"
                },
                {
                    "id": "extreme_bestOrWorstMoment",
                    "shortName": "Best or worst moment",
                    "text": "What was the (best, worst) moment of ____?",
                    "category": "Extreme (in general)",
                    "type": "label"
                },
                {
                    "id": "extreme_feltTheMost",
                    "shortName": "Felt the most",
                    "text": "During ____, when did you feel the most ___? What happened that made you feel that way?",
                    "category": "Extreme (emotion)",
                    "type": "label"
                },
                {
                    "id": "extreme_saidToYourself",
                    "shortName": "Said to yourself",
                    "text": "During ____, did you ever say to yourself, \"This the ____ moment in this ____?\" What happened during that moment?",
                    "category": "Extreme (emotion)",
                    "type": "label"
                },
                {
                    "id": "extreme_highOrLowLevel",
                    "shortName": "High or low level",
                    "text": "What was the (highest, lowest) level of ____ you felt during ____? What happened when you felt that?",
                    "category": "Extreme (emotion)",
                    "type": "label"
                },
                {
                    "id": "extreme_thinkBackOver",
                    "shortName": "Think back over",
                    "text": "Think back over ___. When was ___ the most ____? What happened then?",
                    "category": "Extreme (topic)",
                    "type": "label"
                },
                {
                    "id": "extreme_neverSeenSuch",
                    "shortName": "Never seen such",
                    "text": "Did you ever think, \"I've never seen such ___\"? What happened that made you think that?",
                    "category": "Extreme (topic)",
                    "type": "label"
                },
                {
                    "id": "extreme_momentYouCanRecall",
                    "shortName": "Moment you can recall",
                    "text": "As you look back on ____, what is the ____ moment you can recall with respect to ____? What happened during that moment?",
                    "category": "Extreme (topic)",
                    "type": "label"
                },
                {
                    "id": "surprise_timeWhenSurprised",
                    "shortName": "Time when surprised",
                    "text": "Can you remember a time when you were surprised at how ____?",
                    "category": "Surprise",
                    "type": "label"
                },
                {
                    "id": "surprise_somethingSurprisedYou",
                    "shortName": "Something surprised you",
                    "text": "As you remember ____, can you think of a time when ___ surprised you?",
                    "category": "Surprise",
                    "type": "label"
                },
                {
                    "id": "surprise_aSurprisingSomething",
                    "shortName": "A surprising something",
                    "text": "Can you tell us about a surprising ____ during ____?",
                    "category": "Surprise",
                    "type": "label"
                },
                {
                    "id": "change_momentOfChange",
                    "shortName": "Moment of change",
                    "text": "Was there ever a moment during ___ when ___ changed? What happened?",
                    "category": "Change",
                    "type": "label"
                },
                {
                    "id": "change_feelAChange",
                    "shortName": "Feel a change",
                    "text": "Did you ever feel a change in ____? What caused you to feel that a change was taking place?",
                    "category": "Change",
                    "type": "label"
                },
                {
                    "id": "change_turningPoint",
                    "shortName": "Turning point",
                    "text": "Looking back over ____, can you pick out a turning point in ____? What happened during that turning point?",
                    "category": "Change",
                    "type": "label"
                },
                {
                    "id": "person_whenMetPerson",
                    "shortName": "When met person",
                    "text": "What was it like the ____ time you met ___? What happened?",
                    "category": "Person",
                    "type": "label"
                },
                {
                    "id": "person_timeYouDidSomethingWithPerson",
                    "shortName": "Time you did something with person",
                    "text": "Can you tell us about the ___ when you ___ with ___?",
                    "category": "Person",
                    "type": "label"
                },
                {
                    "id": "person_bestExplains",
                    "shortName": "Best explains",
                    "text": "What experience with ____ best explains ____?",
                    "category": "Person",
                    "type": "label"
                },
                {
                    "id": "group_joinedOrLeft",
                    "shortName": "Joined or left",
                    "text": "Do you remember the ___ when you (joined, left, did something with) ___? What happened during that ___?",
                    "category": "Group",
                    "type": "label"
                },
                {
                    "id": "group_decisionTo",
                    "shortName": "Decision to",
                    "text": "Can you remember making the decision to ___ with ____? What were you thinking about at the time?",
                    "category": "Group",
                    "type": "label"
                },
                {
                    "id": "group_standsOut",
                    "shortName": "Stands out",
                    "text": "Recall a ___ with ___ that stands out in your memory.",
                    "category": "Group",
                    "type": "label"
                },
                {
                    "id": "place_didSomethingAt",
                    "shortName": "Did something at",
                    "text": "Do you remember the ___ time you ___ at ___? What happened?",
                    "category": "Place",
                    "type": "label"
                },
                {
                    "id": "place_rememberHappening",
                    "shortName": "Remember happening",
                    "text": "When you (arrived at, left, did something at) ____, what do you remember happening?",
                    "category": "Place",
                    "type": "label"
                },
                {
                    "id": "place_madeYouThink",
                    "shortName": "Made you think",
                    "text": "Did anything ever happen at ___ that made you think: that's what this place is like? What was it?",
                    "category": "Place",
                    "type": "label"
                },
                {
                    "id": "object_momentSpringsToMind",
                    "shortName": "Moment springs to mind",
                    "text": "When you look at this ___, what moment springs to mind?",
                    "category": "Object",
                    "type": "label"
                },
                {
                    "id": "object_whatWereYouThinking",
                    "shortName": "What were you thinking",
                    "text": "When you first saw ____, what were you thinking? What happened during that encounter?",
                    "category": "Object",
                    "type": "label"
                },
                {
                    "id": "object_especiallySomethingMoments",
                    "shortName": "Especially something moments",
                    "text": "Can you recall any especially _____ moments (using, holding, etc) this ____?",
                    "category": "Object",
                    "type": "label"
                },
                {
                    "id": "scenario_aboutTo",
                    "shortName": "About to",
                    "text": "If someone told you that they were about to ___, what story about your experiences with ___ would you tell them?",
                    "category": "Fictional scenario",
                    "type": "label"
                },
                {
                    "id": "scenario_someoneTellsYou",
                    "shortName": "Someone tells you",
                    "text": "Say someone tells you that ___. Say you want to ___. What would you tell them about your experiences with ___ to ___ them?",
                    "category": "Fictional scenario",
                    "type": "label"
                },
                {
                    "id": "scenario_yearsInThe",
                    "shortName": "Years in the",
                    "text": "If you found yourself suddenly ____ years in the ___, what would you tell people about your experiences with ____ that would help them understand?",
                    "category": "Fictional scenario",
                    "type": "label"
                }
            ]
        },
        {
            "id": "storyQuestions",
            "name": "Story questions",
            "questions": [
                {
                    "id": "howFeel",
                    "text": "How do you feel about this story?",
                    "shortName": "Feel about",
                    "category": "Value",
                    "type": "select",
                    "options": "happy;sad;angry;relieved;enthused;indifferent;not sure"
                },
                {
                    "id": "emotionalIntensity",
                    "text": "How would you rate the emotional intensity of this story?",
                    "shortName": "Emotional intensity",
                    "category": "Value",
                    "type": "slider",
                    "options": "strongly negative;strongly positive"
                },
                {
                    "id": "howMemorable",
                    "text": "How long do you think you will remember this story?",
                    "shortName": "How memorable",
                    "category": "Value",
                    "type": "slider",
                    "options": "I've already forgotten it;I'll remember it all my life"
                },
                {
                    "id": "howImportantToMe",
                    "text": "How important is this story to you? How much does it matter?",
                    "shortName": "How important to me",
                    "category": "Value",
                    "type": "slider",
                    "options": "trivial;huge"
                },
                {
                    "id": "howImportantToOthers",
                    "text": "How important do you think this story is to (other people, another group) in (the community or organization)? How much does it matter to them?",
                    "shortName": "How important to others",
                    "category": "Value",
                    "type": "slider",
                    "options": "trivial;huge"
                },
                {
                    "id": "desiredImportanceToOthers",
                    "text": "How important would you like this story to be to (other people, another group) in (the community or organization)? How much do you want it to matter to them?",
                    "shortName": "Desired importance to others",
                    "category": "Value",
                    "type": "slider",
                    "options": "trivial;huge"
                },
                {
                    "id": "howLongAgo",
                    "text": "How long ago did the events in this story take place?",
                    "shortName": "How long ago",
                    "category": "Setting",
                    "type": "slider",
                    "options": "ten years;it just happened"
                },
                {
                    "id": "duringHistory",
                    "text": "At what point during the history of your interaction with (the topic) did the events in this story happen?",
                    "shortName": "When during history",
                    "category": "Setting",
                    "type": "select",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "whereTookPlace",
                    "text": "Where did the events of this story take place?",
                    "shortName": "Where took place",
                    "category": "Setting",
                    "type": "select",
                    "options": "fill in your own relevant choices; choice 2; choice 3; not sure"
                },
                {
                    "id": "timePeriod",
                    "text": "Over what period of time did the events in this story take place?",
                    "shortName": "Time period",
                    "category": "Setting",
                    "type": "slider",
                    "options": "moments;decades"
                },
                {
                    "id": "whatChanged",
                    "text": "What changed in this story?",
                    "shortName": "What changed",
                    "category": "Change",
                    "type": "select",
                    "options": "fill in your own relevant choices; choice 2; choice 3; not sure"
                },
                {
                    "id": "whatDidNotChange",
                    "text": "What did not change in this story?",
                    "shortName": "What did not change",
                    "category": "Change",
                    "type": "select",
                    "options": "fill in your own relevant choices;choice 2; choice 3;not sure"
                },
                {
                    "id": "whoWasAffectedByChanges",
                    "text": "Who was affected by the changes in this story?",
                    "shortName": "Who was affected by changes",
                    "category": "Change",
                    "type": "select",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "whoWasUnaffectedByChanges",
                    "text": "Who was unaffected by the changes in this story?",
                    "shortName": "Who was unaffected by changes",
                    "category": "Change",
                    "type": "select",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "storyHoldsTogether",
                    "text": "How well would you say this story holds together? If it were a machine, how well would it work?",
                    "shortName": "Story holds together",
                    "category": "Evaluation",
                    "type": "slider",
                    "options": "horribly;perfectly"
                },
                {
                    "id": "storyHasHoles",
                    "text": "Is there anything missing from this story? Does it have any holes in it?",
                    "shortName": "Story has holes",
                    "category": "Evaluation",
                    "type": "slider",
                    "options": "nothing is missing;there are large gaps in the story"
                },
                {
                    "id": "storyRingsTrue",
                    "text": "Does this story ring true? Does it match with other stories you know about?",
                    "shortName": "Story rings true",
                    "category": "Evaluation",
                    "type": "slider",
                    "options": "it connects perfectly with all other experience;something about it doesn't seem right"
                },
                {
                    "id": "elementsConflictHowMuch",
                    "text": "How much conflict do you see in this story?",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsConflictDescribe",
                    "text": "Describe any conflicts you see in this story.",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsCooperationHowMuch",
                    "text": "How much cooperation do you see in this story?",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsCooperationDescribe",
                    "text": "Describe any cooperation you see in this story.",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsDangerHowMuch",
                    "text": "How much danger do you see in this story?",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsDangerDescribe",
                    "text": "Describe any dangers you see in this story.",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsOpportunityHowMuch",
                    "text": "How much opportunity do you see in this story?",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "elementsOpportunityDescribe",
                    "text": "Describe any opportunities you see in this story.",
                    "category": "Elements",
                    "type": "textarea"
                },
                {
                    "id": "whyTold",
                    "text": "Why was this story told?",
                    "shortName": "Why told",
                    "category": "Origin",
                    "type": "select",
                    "options": "to educate;to explain;to inform;to persuade;to reminisce;to complain;to entertain;not sure"
                },
                {
                    "id": "whereCameFrom",
                    "text": "Where did this story come from?",
                    "shortName": "Where came from",
                    "category": "Origin",
                    "type": "select",
                    "options": "it happened to me;it happened to someone I know;it happened to someone I don't know;I heard about it;it's a rumor;it's made up;not sure"
                },
                {
                    "id": "howTrue",
                    "text": "How factually true is this story?",
                    "shortName": "How true",
                    "category": "Origin",
                    "type": "slider",
                    "options": "it happened just as it was told;it's totally made up"
                },
                {
                    "id": "whyStoryChosen",
                    "text": "Why do you think this particular story was chosen to be told just when it was?",
                    "shortName": "Why story chosen",
                    "category": "Origin",
                    "type": "select",
                    "options": "it seemed to fit;it followed another story;it needed to be told;the teller wanted to tell it;it seemed helpful;not sure"
                },
                {
                    "id": "commonOrRare",
                    "text": "Based on what you know of (the community or organization or topic), do you consider the events described in this story to be common or rare?",
                    "shortName": "Common or rare",
                    "category": "Community",
                    "type": "slider",
                    "options": "happens to everyone;happens to one in a million"
                },
                {
                    "id": "scopeInvolved",
                    "text": "What scope of (the community or organization) is involved in this story?",
                    "shortName": "Scope involved",
                    "category": "Community",
                    "type": "slider",
                    "options": "one person;everyone"
                },
                {
                    "id": "rolesInvolved",
                    "text": "Which of these roles were involved in this story?",
                    "shortName": "Roles involved",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "groupsInvolved",
                    "text": "Which groups of people were involved in this story?",
                    "shortName": "Groups involved",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices; choice 2; choice 3;not sure"
                },
                {
                    "id": "strengthOfImpactIfHeard",
                    "text": "If this story was more widely heard, how strong would its impact be on (the community or organization)?",
                    "shortName": "Strength of impact if heard",
                    "category": "Community",
                    "type": "slider",
                    "options": "no impact;it would change everything"
                },
                {
                    "id": "impactIfHeard",
                    "text": "If this story was more widely heard, what impact would that have on (the community or organization)?",
                    "shortName": "Impact if heard",
                    "category": "Community",
                    "type": "textarea",
                    "options": ""
                },
                {
                    "id": "groupsNeedToHearStory",
                    "text": "Which of these groups particularly need to hear this story?",
                    "shortName": "Groups need to hear story",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "groupsHaveNotHeardStory",
                    "text": "Which of these groups is not likely to have ever heard this type of story before?",
                    "shortName": "Groups have never heard story",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "groupsWillNotHearStory",
                    "text": "In which of these groups will people refuse to hear this story?",
                    "shortName": "Groups will not hear story",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "groupsWillGetNewEnergy",
                    "text": "To which of these groups will this story give new energy to solve problems?",
                    "shortName": "Groups will get new energy",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "groupsWillLoseEnergy",
                    "text": "For which of these groups will this story drain their energy?",
                    "shortName": "Groups will lose energy",
                    "category": "Community",
                    "type": "checkboxes",
                    "options": "fill in your own relevant choices;choice 2;choice 3;not sure"
                },
                {
                    "id": "storySaysAbout",
                    "text": "What does this story say to you about (rules, cooperation, trust, power, etc)?",
                    "shortName": "Story says about",
                    "category": "Community",
                    "type": "textarea",
                    "options": ""
                },
                {
                    "id": "storySaysToOthersAbout",
                    "text": "What do you think this story says to (other people, another group) about (rules, cooperation, trust, power, etc)?",
                    "shortName": "Story says to others about",
                    "category": null,
                    "type": "textarea",
                    "options": ""
                },
                {
                    "id": "otherViewsOnValue",
                    "text": "Do you think (other people, another group) in (the community or organization) would say that this story turned out well?",
                    "shortName": "Other views on value",
                    "category": "Other views",
                    "type": "slider",
                    "options": "they would say it turned out horribly;they would say it turned out perfectly"
                },
                {
                    "id": "otherViewsOnCommonality",
                    "text": "Do you think (other people, another group) in (the community or organization) would say the events in this story were common?",
                    "shortName": "Other views on commonality",
                    "category": "Other views",
                    "type": "slider",
                    "options": "they would say it was common;they would say it was rare"
                },
                {
                    "id": "otherViewsOnWhyTold",
                    "text": "Why do you think (other people, another group) in (the community or organization) would say this story was told?",
                    "shortName": "Other views on why told",
                    "category": "Other views",
                    "type": "select",
                    "options": "to educate;to explain;to inform;to persuade;to reminisce;to complain;to entertain;not sure"
                },
                {
                    "id": "otherViewsOnMemorability",
                    "text": "How long do you think (other people, another group) in (the community or organization) would remember this story?",
                    "shortName": "Other views on memorability",
                    "category": "Other views",
                    "type": "slider",
                    "options": "they would have forgotten it already;they would remember it all of their lives"
                },
                {
                    "id": "feelingsAboutOtherViewsOnValue",
                    "text": "Would you like (other people, another group) in (the community or organization) to say that this story turned out well?",
                    "shortName": "Feelings about other views on value",
                    "category": "Feelings about other views",
                    "type": "slider",
                    "options": "I would like them to say that it turned out horribly;I would like them to say that it turned out perfectly"
                },
                {
                    "id": "feelingsAboutOtherViewsOnCommonality",
                    "text": "Would you like (other people, another group) in (the community or organization) to say that the events in this story were common?",
                    "shortName": "Feelings about other views on commonality",
                    "category": "Feelings about other views",
                    "type": "slider",
                    "options": "I would like them to say it was common;I would like them to say it was rare"
                },
                {
                    "id": "feelingsAboutOtherViewsOnWhyTold",
                    "text": "What would you like (other people, another group) in (the community or organization) to say about why this story was told?",
                    "shortName": "Feelings about other views on why told",
                    "category": "Feelings about other views",
                    "type": "select",
                    "options": "to educate;to explain;to inform;to persuade;to reminisce;to complain;to entertain;not sure"
                },
                {
                    "id": "feelingsAboutOtherViewsOnMemorability",
                    "text": "How long would you like (other people, another group) in (the community or organization) to remember this story?",
                    "shortName": "Feelings about other views on memorability",
                    "category": "Feelings about other views",
                    "type": "slider",
                    "options": "I would like them have forgotten it already;I would like them to remember it all of their lives"
                },
                {
                    "id": "topicWouldYouSay",
                    "text": "Would you say that the people in this story ____?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicFeltAbout",
                    "text": "What do you think the people in this story felt about ____?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicMoreOrLess",
                    "text": "Did this story make you feel more or less ___ about ___?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicSayToYou",
                    "text": "What does this story say to you about ____?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicChangeHowYouSee",
                    "text": "Does this story change how you see ___? If so, how?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "topicChooseAStory",
                    "text": "If you were to choose a story to tell about ____, would you choose this one? Why or why not?",
                    "category": "Project topics",
                    "type": "textarea"
                },
                {
                    "id": "mainCharacter",
                    "text": "Who (or what) was the main character in this story? Who was it about?",
                    "shortName": "Main character",
                    "category": "Main character",
                    "type": "select",
                    "options": "fill in your own relevant choices;choice 2 choice 3;not sure"
                },
                {
                    "id": "endedWell",
                    "text": "From the perspective of this story's main character, would you say the story ended well or badly?",
                    "shortName": "Ended well",
                    "category": "Main character",
                    "type": "slider",
                    "options": "horribly;perfectly"
                },
                {
                    "id": "wantOrNeed",
                    "text": "In this story, what did the main character want or need?",
                    "shortName": "Want or need",
                    "category": "Main character",
                    "type": "select",
                    "options": "resources;help;support;information;respect;trust;not sure"
                },
                {
                    "id": "strengthOfWant",
                    "text": "How much did the story's main character want or need what they wanted or needed?",
                    "shortName": "Strength of want",
                    "category": "Main character",
                    "type": "slider",
                    "options": "not at all;too much"
                },
                {
                    "id": "gotWhatWanted",
                    "text": "Did the story's main character get what they wanted or needed?",
                    "shortName": "Got what wanted",
                    "category": "Main character",
                    "type": "slider",
                    "options": "nothing at all;too much"
                },
                {
                    "id": "whoHelped",
                    "text": "Who or what helped the story's main character get what they wanted or needed?",
                    "shortName": "Helped",
                    "category": "Main character",
                    "type": "select",
                    "options": "fill in your own relevant choices;choice 2 choice 3;not;not sure"
                },
                {
                    "id": "amountOfHelp",
                    "text": "How much help did the main character get?",
                    "shortName": "Amount of help",
                    "category": "Main character",
                    "type": "slider",
                    "options": "none;more than they needed"
                },
                {
                    "id": "whoHindered",
                    "text": "Who or what hindered the story's main character in getting what they wanted or needed?",
                    "shortName": "Hindered",
                    "category": "Main character",
                    "type": "select",
                    "options": "fill in your own relevant choices;choice 2 choice 3;not;not sure"
                },
                {
                    "id": "amountOfHindrance",
                    "text": "How much hindrance did the main character face in getting what they needed?",
                    "shortName": "Amount of hindrance",
                    "category": "Main character",
                    "type": "slider",
                    "options": "none;a crushing amount"
                },
                {
                    "id": "thingsThatWouldHaveHelped",
                    "text": "Which of these things, if they had been available to the main character of the story, would have helped them to get what they wanted or needed?",
                    "shortName": "Would have helped",
                    "category": "Main character",
                    "type": "select",
                    "options": "fill in your own relevant choices;not sure"
                }
            ]
        },
        {
            "id": "participantQuestions",
            "name": "Participant questions",
            "questions": [
                {
                    "id": "ageRange",
                    "text": "Which age range do you fall into?",
                    "shortName": "Age",
                    "category": null,
                    "type": "select",
                    "options": "<25;25-34;35-44;45-64;65-74;75+"
                },
                {
                    "id": "gender",
                    "text": "What is your gender?",
                    "category": null,
                    "type": "select",
                    "options": "male;female"
                },
                {
                    "id": "rentOrOwn",
                    "text": "Do you rent or own your home?",
                    "shortName": "Rent or own",
                    "category": null,
                    "type": "select",
                    "options": "rent;own"
                },
                {
                    "id": "incomeLevel",
                    "text": "What is your income level?",
                    "category": null,
                    "type": "select",
                    "options": "put in your own levels here"
                },
                {
                    "id": "educationLevel",
                    "text": "How much education have you completed?",
                    "category": null,
                    "type": "select",
                    "options": "high school;college;post-graduate;trade;other"
                },
                {
                    "id": "maritalStatus",
                    "text": "What is your marital status?",
                    "category": null,
                    "type": "select",
                    "options": "single;married;widowed;divorced;other"
                },
                {
                    "id": "children",
                    "text": "How many children do you have?",
                    "category": null,
                    "type": "select",
                    "options": "none;1;2;3;4;5;6;7;8;9;10"
                },
                {
                    "id": "profession",
                    "text": "What is your profession?",
                    "category": null,
                    "type": "select",
                    "options": "put in your own choices here"
                },
                {
                    "id": "location",
                    "text": "Where do you live?",
                    "category": null,
                    "type": "select",
                    "options": "put in your own choices here"
                },
                {
                    "id": "position",
                    "text": "What is your position?",
                    "category": null,
                    "type": "select",
                    "options": "put in your own choices here"
                },
                {
                    "id": "ethnicBackground",
                    "text": "What is your ethnic background?",
                    "category": null,
                    "type": "select",
                    "options": "put in your own choices here"
                },
                {
                    "id": "opennessToExperience",
                    "text": "Do you like trying new things?",
                    "category": null,
                    "type": "slider",
                    "options": "I like things to stay the same;if it's new I'm for it"
                },
                {
                    "id": "selfDisciplined",
                    "text": "Would you call yourself self-disciplined?",
                    "category": null,
                    "type": "slider",
                    "options": "I always do exactly what I should;I have no control over myself"
                },
                {
                    "id": "introvertOrExtravert",
                    "text": "Are you more of an extravert or an introvert?",
                    "category": null,
                    "type": "slider",
                    "options": "introverted;extraverted"
                },
                {
                    "id": "agreeableness",
                    "text": "How do you feel about other people?",
                    "category": null,
                    "type": "slider",
                    "options": "heaven is other people;hell is other people"
                },
                {
                    "id": "neuroticism",
                    "text": "How much do you worry?",
                    "category": null,
                    "type": "slider",
                    "options": "constantly;me? never"
                },
                {
                    "id": "sensingVsIntuition",
                    "text": "Do you prefer to think of abstract, \"big picture\" ideas, or do you like concrete, practical applications?",
                    "category": null,
                    "type": "slider",
                    "options": "I like the big picture;give me concrete details"
                },
                {
                    "id": "thinkingVsFeeling",
                    "text": "Does logic or emotion have more impact on your decisions?",
                    "category": null,
                    "type": "slider",
                    "options": "logic and reason only;my values and feelings are my guide"
                },
                {
                    "id": "judgingVsPerceiving",
                    "text": "How do you feel about rules?",
                    "category": null,
                    "type": "slider",
                    "options": "rules keep life working;rules are for breaking"
                }
            ]
        },
        {
            "id": "storyCollectionActivities",
            "name": "Story Collection Activities",
            "questions": [
                {
                    "id": "twoTrueStoriesAndATallTale",
                    "shortName": "Two true stories and a tall tale",
                    "type": "ice-breaker",
                    "plan": "Ask people to break into small groups, and one by one, tell two true stories about themselves and one made-up fiction. Others in the group must guess which of the stories is fiction.",
                    "optionalParts": "Afterwards, have groups tell their favorite stories (true or fictional) to the larger group.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "quickInterviews",
                    "shortName": "Quick interviews",
                    "type": "ice-breaker",
                    "plan": "Divide into groups of three. Interview each other using one simple question, like \"When have you felt proud?\"",
                    "optionalParts": "Afterwards, have groups summarize the stories they heard to the larger group",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "commonExperiences",
                    "shortName": "Common experiences",
                    "type": "ice-breaker",
                    "plan": "In small groups, find one experience everyone has had in common. If people know each other, the experience has to be surprising.",
                    "optionalParts": "Afterwards, have groups tell about their shared experience.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "haveYouEver",
                    "shortName": "Have you ever...",
                    "type": "ice-breaker",
                    "plan": "People say whether they've had experiences on a printed list. Each group is challenged to come up with some surprises about the experiences people have had.",
                    "optionalParts": "Afterwards, have groups explain what surprised them about their experiences.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "thatRemindsMeOf",
                    "shortName": "That reminds me of...",
                    "type": "ice-breaker",
                    "plan": "Each group gets a copy of a newspaper or magazine. Each member must come up with some experience they are reminded of by the paper. The group compares their experiences.",
                    "optionalParts": "Afterwards, have groups explain what surprised them about their experiences.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "twentyQuestions",
                    "shortName": "Twenty questions",
                    "type": "ice-breaker",
                    "plan": "In small groups, each person should think of an experience they've had. The others try to guess what happened by asking twenty questions.",
                    "optionalParts": "Afterwards, have groups explain what surprised them about their experiences.",
                    "duration": "Ten to fifteen minutes",
                    "recording": "Not necessary",
                    "materials": "None needed",
                    "spaces": "Places for people to sit in small groups",
                    "facilitation": "None after the setup"
                },
                {
                    "id": "sharingStoriesNoTask",
                    "shortName": "Sharing stories",
                    "type": "sharing stories (no task)",
                    "plan": "Ask people in small groups to simply and naturally share stories about a topic.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "respondToQuestions",
                    "shortName": "Respond to questions",
                    "type": "sharing stories (simple task)",
                    "plan": "Give people (in small groups) a set of 3-5 questions related to the topic." +
                        "Ask them to one by one choose a question they want to answer and tell a story about it" +
                        "to the group. Ask them to try to cover all of the questions between them.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "bothSides",
                    "shortName": "Both sides",
                    "type": "sharing stories (simple task)",
                    "plan": "Give people (in small groups) a set of 3-4 statements related to the topic." +
                        "The statements should be summaries of \"what happens,\" like \"People in our community " +
                        "take care of each other.\" Ask people to tell stories that describe experiences on both sides of each " +
                        "statement. The challenge for the group is to provide balancing examples for each statement.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "simpleRanking",
                    "shortName": "Simple ranking",
                    "type": "sharing stories (simple task)",
                    "plan": "Ask people in small groups to share stories, either with just a named topic," +
                        "or with a list of 3-5 questions about the topic. As people tell stories, ask them to " +
                        "name each story and write the name on a sticky note. Have people arrange the sticky notes " +
                        "along some axis they have defined. It can be anything that has meaning to the group, such as " +
                        "how much impact the story would have if it were widely known, or how positive or negative " +
                        "the story is, or when it happened, or whether it turned out well. Stories should not be ranked by quality." +
                        "Ask people to fill in empty spaces along their axis, if they can.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "remindings",
                    "shortName": "Remindings",
                    "type": "sharing stories (simple task)",
                    "plan": "Ask people in small groups to share stories, either with just a named topic," +
                        "or with a list of 3-5 questions about the topic. After the first story is told, ask people " +
                        "to respond with another story the first story reminds them of. When people run out of " +
                        "remindings, they can return to the list. The challenge to the group is to create chains " +
                        "of reminding.",
                    "optionalParts": "If people like the idea, you can have groups compete over how long their " +
                        "reminding chains grow.",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "words",
                    "shortName": "Words",
                    "type": "sharing stories (simple task)",
                    "plan": "Give small groups cards with words important to the project written on them." +
                        "Mix together words that bring to mind things like behaviors (helpful, deceitful), situations " +
                        "(conflict, cooperation), values (fairness, equality), and concrete places or objects " +
                        "familiar to people (the town square, the factory floor)." +
                        "Ask people to shuffle the cards, then deal out cards so that each person gets a random " +
                        "selection. Ask people to remember and tell about things that have happened that their " +
                        "cards remind them of. Other group members can also tell stories those stories remind " +
                        "them of.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Tape recorders; question sheets.",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch people to make sure they are giving their stories names and paying attention to the question sheets. Make sure people are speaking into the recorders."
                },
                {
                    "id": "twiceToldStories",
                    "shortName": "Twice-told stories",
                    "type": "twice-told stories exercise",
                    "plan": "1. (5 min) Introduction. Ask people to form groups of three to four people. Turn on audio recorders. " +
                        "2. (5 min) Criteria. Each small group should choose a criterion by which they will choose a story they " +
                        "will tell to the larger group afterward." +
                        "3. (25 min) Exchange. Small groups exchange stories. As they do this they name the stories, " +
                        "say the names on the recording, and note them down on their forms. " +
                        "4. (5 min) Question forms. Each person fills out a question form for each story they told. " +
                        "5. (15 min) Retelling. One person from each small group retells their chosen story " +
                        "to the whole session. " +
                        "6. (5 min) Discussion. Wrap-up and general discussion of all stories told and the topic.",
                    "optionalParts": "Ask people to fill out question sheets about the stories they heard as well as those " +
                        "they told.",
                    "duration": "One hour",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "None required",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch to make sure people are paying attention to the exercise (choosing stories to retell), " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "twiceToldStoriesShort",
                    "shortName": "Twice-told stories (short version)",
                    "type": "twice-told stories exercise",
                    "plan": "1. (5 min) Introduction and criteria. Ask people to form groups of three to four people. Turn on audio recorders. " +
                        "Also, each small group should choose a criterion by which they will choose a story they " +
                        "will tell to the larger group afterward." +
                        "2. (20 min) Exchange. Small groups exchange stories. As they do this they name the stories, " +
                        "say the names on the recording, and note them down on their forms. " +
                        "3. (5 min) Question forms. Each person fills out a question form for each story they told. " +
                        "4. (10 min) Retelling. One person from each small group retells their chosen story " +
                        "to the whole session. " +
                        "5. (5 min) Discussion. Wrap-up and general discussion of all stories told and the topic.",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "None required",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch to make sure people are paying attention to the exercise (choosing stories to retell), " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "timeline",
                    "shortName": "Timeline",
                    "type": "timeline exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Turn on audio recorders. " +
                        "2. (5 min) Topic and dates. Ask each group to agree on a topic their timeline will explore. " +
                        "Ask each group to choose starting and ending dates for their timeline " +
                        "and mark these dates with sticky notes. " +
                        "3. (10 min) Start and end. Ask each group to tell at least three stories that describe the end of the timeline. They should " +
                        "write a brief title for each story and build a cluster of these notes at the end of the timeline. " +
                        "Have them do the same for the start of the timeline. " +
                        "They should also write the story titles on their question answering sheets. " +
                        "4. (40 min) Filling in. Have each group work backwards through time, telling stories along the way. " +
                        "Also ask people to mark turning points, or times when things changed in significant ways, on their timeline. " +
                        "5. (10 min) Question forms. Ask everyone to fill out question forms for every story they told. " +
                        "6. (10 min). Visiting. Ask everyone to walk around the room looking over all of the timelines created. " +
                        "7. (10 min). Discussion. Bring everyone together into a discussion of all the timelines.",
                    "optionalParts": "People can create utopian and dystopian timelines, working backward from perfect or " +
                        "horrible ending states, linking to the factual timeline at some point. (See WWS for details.)",
                    "duration": "90 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Sticky notes; spaces to work on (tables, walls, floor)",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders don't pick up too much background noise).",
                    "facilitation": "Watch out for people going into too much detail; people leaving large blank spaces " +
                        "(perhaps in times they don't want to think about); and people listing facts without telling stories."
                },
                {
                    "id": "timelineShort",
                    "shortName": "Timeline (short version)",
                    "type": "timeline exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Turn on audio recorders. " +
                        "2. (5 min) Topics and dates. Ask each group to agree on a topic their timeline will explore. " +
                        "Ask each group to choose starting and ending dates for their timeline " +
                        "and mark these dates with sticky notes. " +
                        "3. (5 min) Start and end. Ask each group to tell at least three stories that describe the end of the timeline. They should " +
                        "write a brief title for each story and build a cluster of these notes at the end of the timeline. " +
                        "Have them do the same for the start of the timeline. " +
                        "They should also write the story titles on their question answering sheets. " +
                        "4. (20 min) Filling in. Have each group work backwards through time, telling stories along the way. " +
                        "Also ask people to mark turning points, or times when things changed in significant ways, on their timeline. " +
                        "5. (5 min) Question forms. Ask everyone to fill out question forms for every story they told. " +
                        "6. (5 min). Visiting. Ask everyone to walk around the room looking over all of the timelines created.",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders " +
                        "don't pick up too much background noise); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for people going into too much detail; people leaving large blank spaces " +
                        "(perhaps in times they don't want to think about); and people listing facts without telling stories."
                },
                {
                    "id": "landscape",
                    "shortName": "Landscape",
                    "type": "landscape exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Turn on audio recorders. " +
                        "2. (5-15 min) Dimensions and corners. Ask each group to mark each axis of the space using dimensions you have chosen. " +
                        "Ask people to label each corner point with descriptions of how the two dimensions come together " +
                        "at that corner." +
                        "3. (40 min) Filling in. Having defined their space, each group will now fill it up with stories. " +
                        "4. (10 min) Features. After groups have populated their spaces, ask them to mark out features of the landscape. " +
                        "5. (10 min) Question forms. Now ask people to pause in their building and answer questions about each story they told. " +
                        "6. (10 min) Visiting. Ask everyone to walk around the room looking over all of the landscapes created and " +
                        "talking about the experiences described there. " +
                        "7. (10 min). Discussion. Bring everyone together into a discussion of all the landscapes.",
                    "optionalParts": "Consider a third dimension; consider multiple perspectives; " +
                        "ask people to create their own dimensions (see WWS for details).",
                    "duration": "90 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders " +
                        "don't pick up too much background noise); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for confusion about the dimensions (and have some on hand in case the first " +
                        "set doesn't resonate); people leaving some spaces empty; people drawing category boxes " +
                        "in the space; people listing dry facts just to cover up the space."
                },
                {
                    "id": "landscapeShort",
                    "shortName": "Landscape (short version)",
                    "type": "landscape exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Turn on audio recorders. " +
                        "2. (5 min) Dimensions and corners. Ask each group to mark each axis of the space using dimensions you have chosen. " +
                        "Ask people to label each corner point with descriptions of how the two dimensions come together " +
                        "at that corner." +
                        "3. (20 min) Filling in. Having defined their space, each group will now fill it up with stories. " +
                        "4. (5 min) Features. After groups have populated their spaces, ask them to mark out features of the landscape. " +
                        "5. (5 min) Question forms. Now ask people to pause in their building and answer questions about each story they told. " +
                        "6. (5 min) Visiting. Ask everyone to walk around the room looking over all of the landscapes created and " +
                        "talking about the experiences described there.",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "Record all stories; ask people to give their stories names; give them question sheets to fill out.",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so tape recorders " +
                        "don't pick up too much background noise); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for confusion about the dimensions (and have some on hand in case the first " +
                        "set doesn't resonate); people leaving some spaces empty; people drawing category boxes " +
                        "in the space; people listing dry facts just to cover up the space."
                }
            ]
        },
        {
            "id": "sensemakingActivities",
            "name": "Sensemaking Activities",
            "questions": [
                {
                    "id": "encounterStories",
                    "shortName": "Encounter stories",
                    "type": "encountering stories (no task)",
                    "plan": "Give each small group some stories to consider. If the stories are printed, " +
                        "ask them to read the stories, either quietly or aloud. If the stories are in audio or video form, " +
                        "ask them to listen to or watch the stories together.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "simpleRanking",
                    "shortName": "Simple ranking",
                    "type": "encountering stories (simple task)",
                    "plan": "Ask each small group to draw a line across a large sheet of paper, or simply use " +
                        "sticky notes to mark the start and end of a line across the table. " +
                        "Give each small group some stories to consider. As they read or listen to each story, " +
                        "ask them to place it somewhere along the line. When they have gone through all the stories, " +
                        "ask them to talk about the pattern they have created with their placements. ",
                    "optionalParts": "If particular groups finish early, ask them to create a second line, " +
                        "then move their stories from one line to the other. Then ask them to consider " +
                        "what they learned from the repositioning of the stories.",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories; a surface (wall, table, or floor) to place stories on; paper and/or sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "bothSides",
                    "shortName": "Both sides",
                    "type": "encountering stories (simple task)",
                    "plan": "Give each group some stories to consider. Ask them to try to find groups of stories " +
                        "in which the same question is answered differently. " +
                        "Example questions might be \"How does a citizen behave?\" and \"What is education?\" " +
                        "Ask people to write these questions " +
                        "on sticky notes and surround them with the stories that answer them differently. " +
                        "If a story stands alone, people should still write a question it answers. " +
                        "If two stories answer the same question in the same way, they can be stacked together. " +
                        "When all of the stories have been considered, people can stand back and look over " +
                        "the patterns they have created.",
                    "optionalParts": "None",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories; a surface (wall, table, or floor) to place stories on; sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "remindings",
                    "shortName": "Remindings",
                    "type": "encountering stories (simple task)",
                    "plan": "Give each small group some stories to consider. As they encounter each story, " +
                        "ask them to think of any other stories it reminds them of. When they find such a " +
                        "reminding pair, have them place the two stories next to each other, with a sticky note " +
                        "between them explaining what links the two stories. It might be something simple, like " +
                        "that they are both about fathers, or something complex, like that in both stories trust " +
                        "is lacking. When the group has worked their way through all of their stories, ask them " +
                        "to stand back and look at the pattern they have created.",
                    "optionalParts": "After creating their remindings pattern, people can talk about why some stories " +
                        "are not connected to any others. What do the unrelated stories have in common?",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories; a surface (wall, table, or floor) to place stories on; sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "resonance",
                    "shortName": "Resonance",
                    "type": "encountering stories (simple task)",
                    "plan": "Give each small group some stories to consider. As they encounter eacy story, " +
                        "ask each person to choose some number of stories (perhaps three, five, or seven) they will take " +
                        "special care to represent in later exercises during the session. They should choose " +
                        "stories that resonate with their own experiences; stories they want to make sure are " +
                        "well represented in what is considered; stories whose voices they want to amplify. When the group " +
                        "has worked their way through all the stories, ask them to talk about the stories they " +
                        "(each) chose and why they chose them.",
                    "optionalParts": "If there is time, people can also talk about the stories nobody chose, " +
                        "and why nobody felt those stories resonated with them, and what that might mean.",
                    "duration": "Ten to thirty minutes",
                    "recording": "None required",
                    "materials": "Printed, audio, or video stories; a surface (wall, table, or floor) to place stories on; sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the stories, " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "twiceToldStories",
                    "shortName": "Twice-told stories",
                    "type": "twice-told stories exercise",
                    "plan": "1. (5 min) Introduction. Ask people to form groups of two to four people. " +
                        "2. (5 min) Criteria. Each small group should choose a criterion by which they will choose a story they " +
                        "will tell to the larger group afterward." +
                        "3. (5 min) Critique. Groups present their criteria to the room for critique. " +
                        "4. (20 min) Encounter. Small groups read or listen to stories. As they do this, they choose which story " +
                        "they will retell to the larger group. " +
                        "5. (20 min) Retelling. One person from each small group retells their chosen story " +
                        "to the whole session. " +
                        "6. (5 min) Discussion. Wrap-up and general discussion of all stories told and the topic.",
                    "optionalParts": "None",
                    "duration": "One hour",
                    "recording": "None required",
                    "materials": "None required",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the exercise (choosing stories to retell), " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "twiceToldStoriesShort",
                    "shortName": "Twice-told stories (short version)",
                    "type": "twice-told stories exercise",
                    "plan": "1. (5 min) Introduction and criteria. Ask people to form groups of two to four people. " +
                        "Also, each small group should choose a criterion by which they will choose a story they " +
                        "will tell to the larger group afterward." +
                        "2. (20 min) Encounter. Small groups read or listen to stories. As they do this, they choose which story " +
                        "they will retell to the larger group. " +
                        "3. (15 min) Retelling. One person from each small group retells their chosen story " +
                        "to the whole session. " +
                        "4. (5 min) Discussion. Wrap-up and general discussion of all stories told and the topic.",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "None required",
                    "materials": "None required",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap).",
                    "facilitation": "Watch to make sure people are paying attention to the exercise (choosing stories to retell), " +
                        "but keep your distance so people can speak freely."
                },
                {
                    "id": "timeline",
                    "shortName": "Timeline",
                    "type": "timeline exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. " +
                        "2. (5 min) Topics and dates. Ask each group to agree on a topic their timeline will explore. " +
                        "Ask each group to choose starting and ending dates for their timeline " +
                        "and mark these dates with sticky notes. " +
                        "3. (10 min) Start and end. Ask each group to choose at least three stories that describe the end of the timeline. They should " +
                        "write the title of each story on a sticky note, and build a cluster of these notes at the end of the timeline. " +
                        "They should do the same for the timeline start." +
                        "4. (25 min) Filling in. Have each group work backwards through time, adding stories (from those they have been given) to the timeline along the way. " +
                        "5. (5 min) Turning points. Ask groups to mark turning points, or times when things changed in significant ways, on their timeline. " +
                        "6. (10 min). Review. Ask each group to review their timeline, looking for interesting or useful features. " +
                        "7. (10 min). Visiting. Ask everyone to walk around the room looking over all of the timelines created. " +
                        "8. (10 min). Finishing. Ask each group to finish their timeline, taking into consideration things visitors said about it. " +
                        "9. (10 min). Discussion. Bring everyone together into a discussion of all the timelines.",
                    "optionalParts": "Use whole stories instead of story titles; use vertical space to annotate stories; " +
                        "distinuguish multiple perspectives; mark multiple types of turning point; etc. (See WWS for details.)",
                    "duration": "90 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for people paying more attention to when things happened than to " +
                        "what that might mean. Especially when they are finding turning points and looking for larger " +
                        "patterns, eople should be negotiating meaning, " +
                        "not just mapping events."
                },
                {
                    "id": "timelineShort",
                    "shortName": "Timeline (short version)",
                    "type": "timeline exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. " +
                        "2. (5 min) Topics and dates. Ask each group to agree on a topic their timeline will explore. " +
                        "Ask each group to choose starting and ending dates for their timeline " +
                        "and mark these dates with sticky notes. " +
                        "3. (5 min) Start and end. Ask each group to choose at least three stories that describe the end of the timeline. They should " +
                        "write the title of each story on a sticky note, and build a cluster of these notes at the end of the timeline. " +
                        "They should do the same for the timeline start." +
                        "4. (20 min) Filling in. Have each group work backwards through time, adding stories (from those they have been given) to the timeline along the way. " +
                        "5. (5 min) Turning points. Ask groups to mark turning points, or times when things changed in significant ways, on their timeline. " +
                        "5. (10 min). Visiting. Ask everyone to walk around the room looking over all of the timelines created. ",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for people paying more attention to when things happened than to " +
                        "what that might mean. Especially when they are finding turning points and looking for larger " +
                        "patterns, eople should be negotiating meaning, " +
                        "not just mapping events."
                },
                {
                    "id": "landscape",
                    "shortName": "Landscape",
                    "type": "landscape exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. " +
                        "2. (5 min) Dimensions and corners. Ask each group to mark each axis of the space using dimensions you have chosen. " +
                        "Ask people to label each corner point with descriptions of how the two dimensions come together " +
                        "at that corner." +
                        "3. (40 min) Filling in. Having defined their space, each group will now fill it up with the stories they were given. " +
                        "4. (25 min) Features. After groups have populated their spaces, ask them to mark out features of the landscape. " +
                        "5. (15 min) Review. Ask each group to work together on the story their landscape tells and what discoveries they find in it. " +
                        "6. (10 min) Visiting. Ask everyone to walk around the room looking over all of the landscapes created and " +
                        "talking about the experiences described there. " +
                        "7. (10 min) Finishing. Groups should add a legend explaining all annotations to their landscape as well as a summary of its major features. " +
                        "8. (10 min). Discussion. Bring everyone together into a discussion of all the landscapes.",
                    "optionalParts": "Consider a third dimension; consider multiple perspectives; " +
                        "ask people to create their own dimensions (see WWS for details).",
                    "duration": "two hours",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for categorization; too-precise or too-sloppy placement; " +
                        "hesitation; dimensions that don't fit the stories (have extras on hand)."
                },
                {
                    "id": "landscapeShort",
                    "shortName": "Landscape (short version)",
                    "type": "landscape exercise (short version)",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. " +
                        "2. (5 min) Dimensions and corners. Ask each group to mark each axis of the space using dimensions you have chosen. " +
                        "Ask people to label each corner point with descriptions of how the two dimensions come together " +
                        "at that corner." +
                        "3. (20 min) Filling in. Having defined their space, each group will now fill it up with the stories they were given. " +
                        "4. (10 min) Features. After groups have populated their spaces, ask them to mark out features of the landscape. " +
                        "5. (5 min) Visiting. Ask everyone to walk around the room looking over all of the landscapes created and " +
                        "talking about the experiences described there. ",
                    "optionalParts": "None",
                    "duration": "45 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for categorization; too-precise or too-sloppy placement; " +
                        "hesitation; dimensions that don't fit the stories (have extras on hand)."
                },
                {
                    "id": "storyElements",
                    "shortName": "Story elements",
                    "type": "story elements exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Explain the question " +
                        "people will be asking about stories (like 'What is going on in this story?'). Split into small " +
                        "groups of three or four people each. " +
                        "2. (20 min) Filling in. Each group should consider the stories they were given and " +
                        "answer the question (you told them about in the introduction) about it a few times. " +
                        "They should write the answers on sticky notes." +
                        "3. (15 min) Clustering. Ask each group to put away the stories and consider only the answers. " +
                        "On a large blank space, groups should place similar items together, like with like, until " +
                        "groups form. " +
                        "4. (10 min) Describing clusters. Groups should list two to four good and bad attributes " +
                        "about each cluster. " +
                        "5. (10 min) Second clustering. Ask groups to cluster the attributes (all of them together, " +
                        "regardless of which cluster they came from) in exactly the same way in which they clustered " +
                        "the original answers. " +
                        "6. (10 min) Review. Ask each group to talk together about what they have discovered. " +
                        "7. (5 min) Visiting. Ask everyone to walk around the room looking over all of the story elements that have been created. " +
                        "8. (5 min) Finishing. Groups should create a summary that describes, in their own words, what each story element means " +
                        "to them and what they have learned from it. " +
                        "9. (10 min) Discussion. Bring everyone together into a discussion of all the story elements.",
                    "optionalParts": "xxx",
                    "duration": "90 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for categorization (remind people that clustering is open-ended); " +
                        "weak response; bad story element names (e.g., proper nouns)."
                },
                {
                    "id": "storyElementsShort",
                    "shortName": "Story elements (short version)",
                    "type": "story elements exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Explain the question " +
                        "people will be asking about stories (like 'What is going on in this story?'). Split into small " +
                        "groups of three or four people each. " +
                        "2. (20 min) Filling in. Each group should consider the stories they were given and " +
                        "answer the question (you told them about in the introduction) about it a few times. " +
                        "They should write the answers on sticky notes." +
                        "3. (15 min) Clustering. Ask each group to put away the stories and consider only the answers. " +
                        "On a large blank space, groups should place similar items together, like with like, until " +
                        "groups form. " +
                        "4. (10 min) Describing clusters. Groups should list two to four good and bad attributes " +
                        "about each cluster. " +
                        "5. (5 min) Second clustering. Ask groups to cluster the attributes (all of them together, " +
                        "regardless of which cluster they came from) in exactly the same way in which they clustered " +
                        "the original answers. " +
                        "to them and what they have learned from it. " +
                        "6. (5 min) Discussion. Bring everyone together into a discussion of all the story elements.",
                    "optionalParts": "Use more than one element type; create association trails; find exemplar stories; " +
                        "compare story elements to published models (see WWS for details).",
                    "duration": "one hour",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "Places for people to sit in small groups (with enough space between so conversations and/or " +
                        "listening to recordings don't overlap); spaces to work on (tables, walls, floor)",
                    "facilitation": "Watch out for categorization (remind people that clustering is open-ended); " +
                        "weak response; bad story element names (e.g., proper nouns)."
                },
                {
                    "id": "compositeStories",
                    "shortName": "Composite stories",
                    "type": "composite stories exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Make sure you have at least three groups in total. " +
                        "2. (5 min) Choosing a message. Each group should agree on a message they want their constructed story to deliver. " +
                        "3. (20 min) Filling in the template. Introduce a story template. Groups should place stories into spaces on the " +
                        "template where they seem to fit and support the overall message. " +
                        "4. (20 min) Forming the story. In this step the focus of each group should move from assembling " +
                        "stories to creating one new fictional story inspired by the assembled stories. " +
                        "5. (10 min) First telling. Now each storyteller should visit another group, tell their group’s story, " +
                        "and listen to feedback. " +
                        "6. (15 min) Preparation for second telling. Storytellers should report on how the storytelling went, " +
                        "then the group should go back and improve on their story in preparation for a second telling. " +
                        "7. (10 min) Second telling. Now the same storytellers should proceed to another group " +
                        "(not the one they told the story to the first time) and tell the story again. Again they " +
                        "should gather feedback. " +
                        "8. (15 min) Finishing. Again the groups should improve their stories. If desired, " +
                        "they should record the story now. " +
                        "9. (10 min) Group discussion. Now that each story has been told, retold, and possibly recorded, " +
                        "it is time for groups to discuss what they have learned by building the story. " +
                        "10. (10 min) Discussion. Now bring everyone in the room into one large discussion about all the stories and the entire process.",
                    "optionalParts": "Add more up-front story choices (topic, genre, subtext, etc); " +
                        "tell the story three times; use repetition and recursion to make the story more complex; " +
                        "have two people play out the story; etc. (See WWS for details.)",
                    "duration": "two hours",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "None required, though people might like to place their sticky notes onto a space to prepare their story",
                    "facilitation": "Watch out for people not understanding the template (have others on hand); " +
                        "people not liking the idea of making things up; people going through the process " +
                        "mechanically; people paying too much attention to story quality."
                },
                {
                    "id": "compositeStoriesShort",
                    "shortName": "Composite stories (short version)",
                    "type": "composite stories exercise",
                    "plan": "1. (5 min) Introduction. Explain the exercise and its purpose. Split into small " +
                        "groups of three or four people each. Make sure you have at least three groups in total. " +
                        "Also, each group should agree on a message they want their constructed story to deliver. " +
                        "2. (20 min) Filling in the template. Introduce a story template. Groups should place stories into spaces on the " +
                        "template where they seem to fit and support the overall message. " +
                        "3 (20 min) Forming the story. In this step the focus of each group should move from assembling " +
                        "stories to creating one new fictional story inspired by the assembled stories. " +
                        "4. (5 min) First telling. Now each storyteller should visit another group, tell their group’s story, " +
                        "and listen to feedback. " +
                        "5. (10 min) Preparation for second telling. Storytellers should report on how the storytelling went, " +
                        "then the group should go back and improve on their story in preparation for a second telling. " +
                        "6. (5 min) Second telling. Now the same storytellers should proceed to another group " +
                        "(not the one they told the story to the first time) and tell the story again. Again they " +
                        "should gather feedback. " +
                        "7. (10 min) Finishing. Again the groups should improve their stories. If desired, " +
                        "they should record the story now. " +
                        "8. (5 min) Group discussion. Now that each story has been told, retold, and possibly recorded, " +
                        "it is time for groups to discuss what they have learned by building the story. " +
                        "9. (10 min) Discussion. Now bring everyone in the room into one large discussion about all the stories and the entire process.",
                    "optionalParts": "None",
                    "duration": "90 minutes",
                    "recording": "None required",
                    "materials": "Sticky notes",
                    "spaces": "None required, though people might like to place their sticky notes onto a space to prepare their story",
                    "facilitation": "Watch out for people not understanding the template (have others on hand); " +
                        "people not liking the idea of making things up; people going through the process " +
                        "mechanically; people paying too much attention to story quality."
                }
            ]
        }
    ];
    function convertSemicolonsToNewlinesForOptions(section) {
        var questions = section.questions;
        for (var questionIndex in questions) {
            var question = questions[questionIndex];
            if (question.options) {
                question.options = question.options.replace(/;/g, "\n");
            }
        }
        return section;
    }
    exports.elicitationQuestions = convertSemicolonsToNewlinesForOptions(templates[0]);
    exports.storyQuestions = convertSemicolonsToNewlinesForOptions(templates[1]);
    exports.participantQuestions = convertSemicolonsToNewlinesForOptions(templates[2]);
    exports.storyCollectionActivities = convertSemicolonsToNewlinesForOptions(templates[3]);
    exports.sensemakingActivities = convertSemicolonsToNewlinesForOptions(templates[4]);
});

define('js/applicationWidgets/add_templateList',["require", "exports", "../panelBuilder/dialogSupport", "../templates/templates", "../panelBuilder/GridWithItemPanel", "mithril", "../Globals"], function (require, exports, dialogSupport, templates, GridWithItemPanel, m, Globals) {
    "use strict";
    function add_templateList(panelBuilder, model, fieldSpecification) {
        var dialogConfiguration = {
            dialogModel: model,
            dialogTitle: "#title_chooseATemplate|Choose a template",
            dialogStyle: undefined,
            dialogConstructionFunction: makeTemplateListChooser.bind(null, panelBuilder),
            dialogOKButtonLabel: "Cancel",
            fieldSpecification: fieldSpecification
        };
        return dialogSupport.addButtonThatLaunchesDialog(fieldSpecification, dialogConfiguration);
    }
    var add_templateList_elicitationQuestions = [
        { id: "category", valueType: "string", displayType: "text" },
        { id: "text", valueType: "string", displayType: "textarea" }
    ];
    var add_templateList_storyOrParticipantQuestions = [
        { id: "category", valueType: "string", displayType: "text" },
        { id: "text", valueType: "string", displayType: "textarea" },
        { id: "type", valueType: "string", displayType: "text" },
        { id: "options", valueType: "string", displayType: "textarea" }
    ];
    var add_templateList_activityQuestions = [
        { id: "shortName", valueType: "string", displayType: "text" },
        { id: "type", valueType: "string", displayType: "text" },
        { id: "duration", valueType: "string", displayType: "text" },
        { id: "plan", valueType: "string", displayType: "textarea" }
    ];
    function useButtonClicked(panelBuilder, templateListChoice, model, hideDialogCallback, gridWithItemPanel) {
        // console.log("useButtonClicked", gridWithItemPanel);
        var selectedTemplate = gridWithItemPanel.getSelectedItem();
        // console.log("grid selectedTemplate", selectedTemplate);
        var storeValueInModel = Globals.project().tripleStore.makeModelFunction(model);
        if (selectedTemplate) {
            // TODO: not sure whether to confirm?
            // TODO: Translate
            dialogSupport.confirm("Copy selected template '" + selectedTemplate.shortName + "' into question definition?", function () {
                var uniqueName = selectedTemplate.shortName || selectedTemplate.id || "";
                if (templateListChoice === "elicitationQuestions") {
                    storeValueInModel("elicitingQuestion_text", selectedTemplate.text || "");
                    storeValueInModel("elicitingQuestion_shortName", uniqueName);
                    // TODO: No data for type, and would need to copy over settings for checkboxes if such data existed
                    // modelFunction("storyQuestion_type", selectedTemplate.text);
                    storeValueInModel("elicitingQuestion_type", {});
                }
                else if (templateListChoice === "storyQuestions") {
                    storeValueInModel("storyQuestion_text", selectedTemplate.text || "");
                    storeValueInModel("storyQuestion_type", selectedTemplate.type || "");
                    storeValueInModel("storyQuestion_shortName", uniqueName);
                    storeValueInModel("storyQuestion_options", selectedTemplate.options || "");
                }
                else if (templateListChoice === "participantQuestions") {
                    storeValueInModel("participantQuestion_text", selectedTemplate.text || "");
                    storeValueInModel("participantQuestion_type", selectedTemplate.type || "");
                    storeValueInModel("participantQuestion_shortName", uniqueName);
                    storeValueInModel("participantQuestion_options", selectedTemplate.options || "");
                }
                else if (templateListChoice === "storyCollectionActivities") {
                    storeValueInModel("collectionSessionActivity_name", uniqueName);
                    storeValueInModel("collectionSessionActivity_type", selectedTemplate.type || "");
                    storeValueInModel("collectionSessionActivity_plan", selectedTemplate.plan || "");
                    storeValueInModel("collectionSessionActivity_optionalParts", selectedTemplate.optionalParts || "");
                    storeValueInModel("collectionSessionActivity_duration", selectedTemplate.duration || "");
                    storeValueInModel("collectionSessionActivity_recording", selectedTemplate.recording || "");
                    storeValueInModel("collectionSessionActivity_materials", selectedTemplate.materials || "");
                    storeValueInModel("collectionSessionActivity_spaces", selectedTemplate.spaces || "");
                    storeValueInModel("collectionSessionActivity_facilitation", selectedTemplate.facilitation || "");
                }
                else if (templateListChoice === "sensemakingActivities") {
                    storeValueInModel("sensemakingSessionPlan_activity_name", uniqueName);
                    storeValueInModel("sensemakingSessionPlan_activity_type", selectedTemplate.type || "");
                    storeValueInModel("sensemakingSessionPlan_activity_plan", selectedTemplate.plan || "");
                    storeValueInModel("sensemakingSessionPlan_activity_optionalParts", selectedTemplate.optionalParts || "");
                    storeValueInModel("sensemakingSessionPlan_activity_duration", selectedTemplate.duration || "");
                    storeValueInModel("sensemakingSessionPlan_activity_recording", selectedTemplate.recording || "");
                    storeValueInModel("sensemakingSessionPlan_activity_materials", selectedTemplate.materials || "");
                    storeValueInModel("sensemakingSessionPlan_activity_spaces", selectedTemplate.spaces || "");
                    storeValueInModel("sensemakingSessionPlan_activity_facilitation", selectedTemplate.facilitation || "");
                }
                else {
                    var message = "ERROR: unsupported template type:" + templateListChoice;
                    console.log(message);
                    alert(message);
                }
                // console.log("about to call hideDialogCallback");
                hideDialogCallback();
            });
        }
        else {
            // TODO: Translate
            alert("No template was selected");
        }
    }
    function makeTemplateListChooser(panelBuilder, dialogConfiguration, hideDialogCallback) {
        var fieldSpecification = dialogConfiguration.fieldSpecification;
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        // TODO: questionContentPane.set("style", "min-height: 400px; min-width: 600px; max-width: 900px");
        var templateListChoice = fieldSpecification.displayConfiguration;
        // console.log("templateListChoice", templateListChoice);
        var templateCollection = templates[templateListChoice];
        // console.log("templateCollection", templateCollection);
        var templateQuestions;
        if (templateCollection) {
            templateQuestions = templateCollection.questions;
        }
        else {
            console.log("No templates defined yet for templateListChoice", templateListChoice);
            // alert("Unsupported templateListChoice: " + templateListChoice);
            templateQuestions = [];
        }
        var pageQuestions;
        if (templateListChoice === "elicitationQuestions") {
            pageQuestions = add_templateList_elicitationQuestions;
        }
        else if (templateListChoice === "storyQuestions" || templateListChoice === "participantQuestions") {
            pageQuestions = add_templateList_storyOrParticipantQuestions;
        }
        else if (templateListChoice === "storyCollectionActivities" || templateListChoice === "sensemakingActivities") {
            pageQuestions = add_templateList_activityQuestions;
        }
        else {
            var message = "ERROR: unsupported template type:" + templateListChoice;
            console.log(message);
            alert(message);
            pageQuestions = [];
        }
        function buildPanel(builder, model) {
            return builder.buildFields(pageQuestions, model);
        }
        var itemPanelSpecification = {
            id: "panel_template",
            modelClass: "Template",
            displayType: "panel",
            isHeader: false,
            panelFields: pageQuestions,
            buildPanel: buildPanel
        };
        var customButtonDefinition = {
            id: "useTemplate",
            customButtonLabel: "#button_UseTemplate|Use template",
            callback: useButtonClicked.bind(null, panelBuilder, templateListChoice, dialogConfiguration.dialogModel, hideDialogCallback)
        };
        var model = { templates: templateQuestions };
        var gridFieldSpecification = {
            id: "templates",
            displayConfiguration: {
                itemPanelSpecification: itemPanelSpecification,
                gridConfiguration: {
                    idProperty: "id",
                    columnsToDisplay: false,
                    // viewButton: true,
                    customButton: customButtonDefinition,
                    navigationButtons: true
                }
            }
        };
        // TODO: Set class on div
        return m("div", [
            prompt,
            m.component(GridWithItemPanel, { key: fieldSpecification.id + "_templatesListChooser", panelBuilder: panelBuilder, fieldSpecification: gridFieldSpecification, model: model })
        ]);
    }
    return add_templateList;
});

define('js/applicationWidgets/add_patternExplorer',["require", "exports", "mithril", "./PatternExplorer"], function (require, exports, m, PatternExplorer) {
    "use strict";
    function add_patternExplorer(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        var patternBrowser = m.component(PatternExplorer, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification });
        return m("div", [
            prompt,
            patternBrowser
        ]);
    }
    return add_patternExplorer;
});

define('js/applicationWidgets/loadAllApplicationWidgets',["require", "exports", "./add_catalysisReportQuestionChooser", "./add_clusteringDiagram", "./add_dashboardSectionStatusDisplay", "./add_dashboardStoryCollectionStatusDisplay", "./add_graphBrowser", "./add_questionAnswer", "./add_questionsTable", "./add_quizScoreResult", "./add_recommendationTable", "./add_report", "./add_storiesList", "./add_storyBrowser", "./add_templateList", "./add_patternExplorer"], function (require, exports, add_catalysisReportQuestionChooser, add_clusteringDiagram, add_dashboardSectionStatusDisplay, add_dashboardStoryCollectionStatusDisplay, add_graphBrowser, add_questionAnswer, add_questionsTable, add_quizScoreResult, add_recommendationTable, add_report, add_storiesList, add_storyBrowser, add_templateList, add_patternExplorer) {
    "use strict";
    function loadAllApplicationWidgets(PanelBuilder) {
        // plugins
        PanelBuilder.addPlugin("catalysisReportQuestionChooser", add_catalysisReportQuestionChooser);
        PanelBuilder.addPlugin("clusteringDiagram", add_clusteringDiagram);
        PanelBuilder.addPlugin("dashboardSectionStatusDisplay", add_dashboardSectionStatusDisplay);
        PanelBuilder.addPlugin("dashboardStoryCollectionStatusDisplay", add_dashboardStoryCollectionStatusDisplay);
        PanelBuilder.addPlugin("graphBrowser", add_graphBrowser);
        PanelBuilder.addPlugin("questionAnswer", add_questionAnswer);
        PanelBuilder.addPlugin("questionsTable", add_questionsTable);
        PanelBuilder.addPlugin("quizScoreResult", add_quizScoreResult);
        PanelBuilder.addPlugin("recommendationTable", add_recommendationTable);
        PanelBuilder.addPlugin("report", add_report);
        PanelBuilder.addPlugin("storiesList", add_storiesList);
        PanelBuilder.addPlugin("storyBrowser", add_storyBrowser);
        PanelBuilder.addPlugin("templateList", add_templateList);
        PanelBuilder.addPlugin("patternExplorer", add_patternExplorer);
    }
    return loadAllApplicationWidgets;
});

define('js/panelBuilder/loadAllPanelSpecifications',["require", "exports"], function (require, exports) {
    "use strict";
    // Setup all the panels from TypeScript files specified in navigationSections array
    // see navigation.ts for an example of the format
    // The "panels" are child panels used by grids and similar widgets on the page (including recursively)
    /*
     [
         {
            "section": "planning",
            "sectionName": "Planning",
            "pages": [
                "page_planning",
                 "page_participantGroups",
                 ...
            ],
            "panels": [
                "panel_addParticipantGroup",
                ...
            ]
         }, ...
     ]
     */
    function loadAllPanelSpecifications(panelSpecificationCollection, navigationSections, loadingBase, callback) {
        // console.log("loadAllPanelSpecifications", loadingBase, navigationSections);
        var panelMetadata = [];
        var navigationModules = navigationSections["navigationModules"];
        var panelSpecification;
        for (var sectionIndex = 0; sectionIndex < navigationSections.length; sectionIndex++) {
            var sectionInfo = navigationSections[sectionIndex];
            for (var pageIndex = 0; pageIndex < sectionInfo.pages.length; pageIndex++) {
                var pageID = sectionInfo.pages[pageIndex];
                panelSpecification = navigationModules[pageID];
                if (panelSpecification.id !== pageID) {
                    console.log("pageID mismatch; expected:", pageID, panelSpecification);
                    throw new Error("pageID does not match id in file for pae: " + pageID);
                }
                panelSpecification.section = sectionInfo.section;
                panelSpecification.isHeader = pageIndex === 0 || false;
                panelSpecification.displayType = "page";
                panelSpecificationCollection.addPanelSpecification(panelSpecification);
            }
            if (sectionInfo.panels) {
                for (var extraPanelIndex = 0; extraPanelIndex < sectionInfo.panels.length; extraPanelIndex++) {
                    var extraPanelID = sectionInfo.panels[extraPanelIndex];
                    panelSpecification = navigationModules[extraPanelID];
                    if (panelSpecification.id !== extraPanelID) {
                        console.log("panelID mismatch; expected:", extraPanelID, panelSpecification);
                        throw new Error("panelID does not match id in file for panel: " + extraPanelID);
                    }
                    panelSpecification.section = sectionInfo.section;
                    panelSpecification.isHeader = pageIndex === 0 || false;
                    panelSpecification.displayType = "panel";
                    panelSpecificationCollection.addPanelSpecification(panelSpecification);
                }
            }
        }
        // TODO: Legacy: Used to be asynchronous require, but now page and panel modules are loaded at startup
        callback();
    }
    return loadAllPanelSpecifications;
});

define('js/panelBuilder/standardWidgets',["require", "exports", "mithril", "./valuePathResolver", "./translate", "../Globals", "lodash", "../sanitizeHTML"], function (require, exports, m, valuePathResolver, translate, Globals, _, sanitizeHTML) {
    "use strict";
    function getIdForText(text) {
        return text;
    }
    function optionsForSelect(panelBuilder, model, fieldSpecification, currentValue, addNoSelectionOption) {
        var specifiedChoices = fieldSpecification.valueOptions;
        var choices = specifiedChoices;
        if (_.isString(specifiedChoices)) {
            choices = valuePathResolver.newValuePath(model, specifiedChoices)();
            if (_.isString(choices)) {
                // Build choices by making items using tripelStore set
                var choiceItems = [];
                var choiceSet = Globals.project().tripleStore.getListForSetIdentifier(choices);
                for (var i = 0; i < choiceSet.length; i++) {
                    var choiceIdentifier = choiceSet[i];
                    var item = Globals.project().tripleStore.makeObject(choiceIdentifier, true);
                    choiceItems.push(item);
                }
                choices = choiceItems;
            }
        }
        if (!choices) {
            console.log("No choices or options defined for select", fieldSpecification.id);
            return [];
        }
        var isValueInChoices = false;
        var options = [];
        // '-- select --'
        if (addNoSelectionOption)
            options.push({ name: translate("#selection_has_not_been_made|(no selection)"), value: "", selected: !currentValue });
        choices.forEach(function (each) {
            var label;
            var value;
            var selected;
            // console.log("choice", id, each);
            if (_.isString(each)) {
                label = translate(fieldSpecification.id + "::selection:" + each, each);
                options.push({ name: label, value: each });
                if (currentValue === each)
                    isValueInChoices = true;
            }
            else {
                // TODO: Maybe bug in dojo select that it does not handle values that are not strings
                // http://stackoverflow.com/questions/16205699/programatically-change-selected-option-of-a-dojo-form-select-that-is-populated-b
                if (fieldSpecification.valueOptionsSubfield) {
                    value = each[fieldSpecification.valueOptionsSubfield];
                }
                else {
                    value = each.value;
                }
                if (fieldSpecification.displayDataOptionField) {
                    label = each[fieldSpecification.displayDataOptionField];
                }
                else {
                    label = value;
                }
                label = translate(fieldSpecification.id + "::selection:" + label, label);
                if (currentValue === value) {
                    selected = true;
                    isValueInChoices = true;
                }
                else {
                    selected = undefined;
                }
                options.push({ name: label, value: value, selected: selected });
            }
        });
        // console.log("isValueInChoices", isValueInChoices);
        // console.log("updateChoices", currentValue, isValueInChoices, (currentValue === null || currentValue === undefined || currentValue === ""));
        // return isValueInChoices || (currentValue === null || currentValue === undefined || currentValue === "");
        return options;
    }
    var displayTypesWithoutValues = {
        label: true,
        header: true
    };
    function displayQuestion(panelBuilder, model, fieldSpecification) {
        var fieldID = fieldSpecification.id;
        var displayType = fieldSpecification.displayType;
        var questionLabel = panelBuilder.buildQuestionLabel(fieldSpecification);
        function makeLabel() {
            // The for attribute of the label element must refer to a form control.
            questionLabel[0].attrs["for"] = getIdForText(fieldID);
            questionLabel[0].tag = "label";
        }
        var parts = [];
        function makeLegend() {
            // Do nothing for now
            parts.unshift(m("legend", questionLabel[0]));
            questionLabel = [];
        }
        var valueProperty = valuePathResolver.newValuePathForFieldSpecification(model, fieldSpecification);
        // Only fetch value if the field needs it
        var value;
        if (!displayTypesWithoutValues[displayType]) {
            value = valueProperty();
        }
        if (value === undefined)
            value = "";
        function change(event, value) {
            if (event)
                value = event.target.value;
            // console.log("onchange", fieldSpecification.id, value);
            valueProperty(value);
        }
        function isEmpty(value) {
            return value === undefined || value === null || value === "";
        }
        var readOnly = panelBuilder.readOnly || fieldSpecification.displayReadOnly || (fieldSpecification.valueImmutable && value) || undefined;
        // var disabled = (readOnly && displayType === "select") || undefined;
        var disabled = readOnly || undefined;
        var standardValueOptions = {
            value: value,
            id: getIdForText(fieldID),
            onchange: change,
            readOnly: readOnly,
            disabled: disabled
        };
        if (displayType === "label") {
        }
        else if (displayType === "header") {
        }
        else if (displayType === "text") {
            makeLabel();
            parts = [
                m("input[class=narrafirma-textbox]", standardValueOptions),
                m("br")
            ];
        }
        else if (displayType === "textarea") {
            makeLabel();
            parts = [
                m("textarea[class=narrafirma-textbox]", standardValueOptions),
                m("br")
            ];
        }
        else if (displayType === "checkbox") {
            makeLabel();
            var checkboxText = "";
            if (fieldSpecification.displayConfiguration) {
                checkboxText = fieldSpecification.displayConfiguration;
            }
            parts = [
                m("input[type=checkbox]", {
                    id: getIdForText(fieldID),
                    disabled: disabled,
                    checked: value,
                    onchange: function (event) {
                        change(null, event.target.checked);
                    }
                }),
                m("label", { "for": getIdForText(fieldID) }, checkboxText),
                m("br")
            ];
        }
        else if (displayType === "checkboxes") {
            // The for attribute of the label element must refer to a form control.
            delete questionLabel[0].attrs["for"];
            if (!value) {
                value = {};
                change(null, value);
            }
            else if (typeof (value) === "string") {
                var option = value;
                value = {};
                value[option] = true;
                change(null, value);
            }
            parts = [
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionID = getIdForText(fieldID + "_" + option);
                    return [
                        m("input[type=checkbox]", {
                            id: optionID,
                            disabled: disabled,
                            checked: !!value[option],
                            onchange: function (event) {
                                value[option] = event.target.checked;
                                change(null, value);
                            }
                        }),
                        m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(option)),
                        m("br")
                    ];
                })
            ];
            makeLegend();
            parts = [m("fieldset", parts)];
        }
        else if (displayType === "radiobuttons") {
            // The for attribute of the label element must refer to a form control.
            delete questionLabel[0].attrs["for"];
            parts = [
                fieldSpecification.valueOptions.map(function (option, index) {
                    var optionID = getIdForText(fieldID + "_" + option);
                    return [
                        m("input[type=radio]", {
                            id: optionID,
                            value: option,
                            name: fieldSpecification.id,
                            disabled: disabled,
                            checked: value === option,
                            onchange: change.bind(null, null, option)
                        }),
                        m("label", { "for": optionID }, sanitizeHTML.generateSmallerSetOfSanitizedHTMLForMithril(option)),
                        m("br")
                    ];
                })
            ];
            makeLegend();
            parts = [m("fieldset", parts)];
        }
        else if (displayType === "boolean") {
            // The for attribute of the label element must refer to a form control.
            delete questionLabel[0].attrs["for"];
            parts = [
                m("input[type=radio]", {
                    id: getIdForText(fieldID + "_yes"),
                    value: true,
                    name: fieldSpecification.id,
                    disabled: disabled,
                    checked: value === true,
                    onchange: change.bind(null, null, true) }),
                m("label", { "for": getIdForText(fieldID + "_yes") }, "yes"),
                m("br"),
                m("input[type=radio]", {
                    id: getIdForText(fieldID + "_no"),
                    value: false,
                    name: fieldSpecification.id,
                    disabled: disabled,
                    checked: value === false,
                    onchange: change.bind(null, null, false) }),
                m("label", { "for": getIdForText(fieldID + "_no") }, "no"),
                m("br")
            ];
            makeLegend();
            parts = [m("fieldset", parts)];
        }
        else if (displayType === "select") {
            makeLabel();
            var selectOptionsRaw = optionsForSelect(panelBuilder, model, fieldSpecification, value, true);
            var selectOptions = selectOptionsRaw.map(function (option, index) {
                var optionOptions = { value: option.value, selected: undefined };
                // console.log("optionValue, value", optionValue, value, optionValue === value);
                if (option.selected)
                    optionOptions.selected = 'selected';
                return m("option", optionOptions, option.name);
            });
            parts = [
                m("select", standardValueOptions, selectOptions),
                m("br")
            ];
        }
        else if (displayType === "slider") {
            makeLabel();
            var checkboxID = getIdForText(fieldID) + "_doesNotApply";
            var sliderValueOptions = {
                value: value,
                id: getIdForText(fieldID),
                onchange: change,
                readOnly: readOnly,
                disabled: disabled,
                min: 0,
                max: 100,
                step: 1
            };
            var leftSideText = "";
            var rightSideText = "";
            var doesNotApplyText = "Does not apply";
            if (fieldSpecification.displayConfiguration) {
                if (fieldSpecification.displayConfiguration.length > 1) {
                    leftSideText = fieldSpecification.displayConfiguration[0];
                    rightSideText = fieldSpecification.displayConfiguration[1];
                }
                if (fieldSpecification.displayConfiguration.length > 2) {
                    doesNotApplyText = fieldSpecification.displayConfiguration[2];
                }
            }
            // Could suggest 0-100 to support <IE10 that don't have range input -- or could do polyfill
            // if (fieldSpecification.displayPrompt) questionLabel[0].children = fieldSpecification.displayPrompt + " (0-100)";
            parts = [
                m("span", { "class": "narrafirma-survey-low" }, "◀ " + leftSideText),
                m('span', { "class": "narrafirma-survey-slider" }, m('input[type="range"]', sliderValueOptions)),
                m('span', { "class": "narrafirma-survey-high" }, rightSideText + " ▶"),
                m("br"),
                m('input[type="checkbox"]', {
                    "class": "narrafirma-survey-does-not-apply",
                    id: checkboxID,
                    checked: isEmpty(sliderValueOptions.value),
                    onclick: function (event) {
                        var isChecked = event.target.checked;
                        if (isChecked) {
                            valueProperty("");
                        }
                        else {
                            valueProperty("50");
                        }
                    }
                }),
                m("label", { "for": checkboxID }, doesNotApplyText)
            ];
        }
        else {
            parts = [
                m("span", { style: { "font-weight": "bold" } }, "UNFINISHED: " + fieldSpecification.displayType),
                m("br")
            ];
        }
        if (parts.length) {
            parts = m("div", { "class": "questionInternal narrafirma-question-type-" + displayType }, parts);
        }
        if (questionLabel) {
            parts = questionLabel.concat(parts);
        }
        var classString = "questionExternal";
        var isAnnotationQuestion = fieldSpecification.id.indexOf("A_") >= 0;
        if (isAnnotationQuestion)
            classString += "-annotation";
        classString += " narrafirma-question-type-" + displayType;
        if (fieldSpecification.displayClass) {
            classString += " " + fieldSpecification.displayClass;
        }
        return m("div", { key: fieldID, "class": classString }, parts);
    }
    exports.displayQuestion = displayQuestion;
});

define('js/panelBuilder/PanelBuilder',["require", "exports", "./browser", "./translate", "mithril", "./GridWithItemPanel", "./standardWidgets", "../sanitizeHTML", "lodash"], function (require, exports, browser, translate, m, GridWithItemPanel, standardWidgets, sanitizeHTML, _) {
    "use strict";
    // Developer local debug flag to cause an Exception if a widget type is missing instead of put in placeholder panel
    var debugFailIfMissingWidgets = false;
    // This is the tag to put into prompting text for functionResult items where you want the result to go
    var ResultTagToReplace = "{{result}}";
    // TODO: Need a better approach for calling JavaScript function than this
    window["narraFirma_launchApplication"] = browser.launchApplication;
    // TODO: Think about how to load plugins only as needed at runtime.
    // Asynchronous callbacks are nice, until you realize you would need
    // to refactor a lot to introduce one deep down in your application.
    // In this case, it would be nice to load plugin functions only at runtime as panels require them.
    // However, to use the AMD approach, that would mean everything that asked the builder
    // to do anything would have to wait on a callback for the builder to finish.
    function addButton(panelBuilder, model, fieldSpecification, callback) {
        if (!callback)
            callback = panelBuilder.buttonClicked.bind(panelBuilder, model, fieldSpecification);
        var options = {
            onclick: callback
        };
        if (fieldSpecification.displayClass)
            options.class = fieldSpecification.displayClass;
        var text = m("span", { "class": "button-text" }, translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt));
        var parts = [text];
        if (fieldSpecification.displayIconClass) {
            var icon = m("span", { "class": fieldSpecification.displayIconClass });
            if (fieldSpecification.displayIconPosition === "right") {
                parts.push(icon);
            }
            else {
                parts.unshift(icon);
            }
        }
        var button = m("button", options, parts);
        // TODO: Improve the naming of displayPreventBreak, maybe by using displayConfiguration somehow, perhaps by changing the meaning of that field to something else
        if (fieldSpecification.displayPreventBreak)
            return button;
        return [button, m("br")];
    }
    function add_html(panelBuilder, model, fieldSpecification, callback) {
        // add_html should only be called for NarraFirma application-supplied code, so trusting this should be OK
        return m("div.htmlWidget", { key: fieldSpecification.id }, m.trust(fieldSpecification.displayPrompt));
    }
    function add_image(panelBuilder, model, fieldSpecification, callback) {
        var imageSource = fieldSpecification.displayConfiguration;
        var questionText = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt || "");
        return m("div.narrafirma-image", { key: fieldSpecification.id }, [
            panelBuilder.addAllowedHTMLToPrompt(questionText),
            m("br"),
            m("img", {
                src: panelBuilder.applicationDirectory + imageSource,
                alt: "Image for question: " + questionText
            })
        ]);
    }
    function add_functionResult(panelBuilder, model, fieldSpecification, callback) {
        // This should now be triggered via a Mithril redraw...
        var value = panelBuilder.calculateFunctionResult(model, fieldSpecification);
        var baseText = translate(fieldSpecification.id + "::prompt", fieldSpecification.displayPrompt);
        var calculatedText = panelBuilder.calculateFunctionResult(model, fieldSpecification);
        var newLabelText = panelBuilder.substituteCalculatedResultInBaseText(baseText, calculatedText);
        return m("div.functionResult", panelBuilder.addAllowedHTMLToPrompt(newLabelText));
    }
    /* Defaults for displayConfiguration:
    {
       itemPanelID: undefined,
       itemPanelSpecification: undefined,
       idProperty: "_id",
       gridConfiguration: {...}
    }
     */
    function add_grid(panelBuilder, model, fieldSpecification) {
        var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
        return [
            prompt,
            m.component(GridWithItemPanel, { key: fieldSpecification.id, panelBuilder: panelBuilder, model: model, fieldSpecification: fieldSpecification, readOnly: panelBuilder.readOnly })
        ];
    }
    function addStandardPlugins() {
        // shared with survey builder
        var displayQuestion = standardWidgets.displayQuestion;
        PanelBuilder.addPlugin("boolean", displayQuestion);
        PanelBuilder.addPlugin("checkbox", displayQuestion);
        PanelBuilder.addPlugin("checkboxes", displayQuestion);
        PanelBuilder.addPlugin("header", displayQuestion);
        PanelBuilder.addPlugin("label", displayQuestion);
        PanelBuilder.addPlugin("radiobuttons", displayQuestion);
        PanelBuilder.addPlugin("select", displayQuestion);
        PanelBuilder.addPlugin("slider", displayQuestion);
        PanelBuilder.addPlugin("text", displayQuestion);
        PanelBuilder.addPlugin("textarea", displayQuestion);
        // other
        PanelBuilder.addPlugin("button", addButton);
        PanelBuilder.addPlugin("functionResult", add_functionResult);
        PanelBuilder.addPlugin("grid", add_grid);
        PanelBuilder.addPlugin("html", add_html);
        PanelBuilder.addPlugin("image", add_image);
    }
    var buildingFunctions = {};
    // This class builds panels from field specifications.
    // Field specifications define what widget to display and how to hook that widget to a model.
    var PanelBuilder = (function () {
        function PanelBuilder(application) {
            this.application = application;
            this.panelSpecificationCollection = null;
            this.buttonClickedCallback = null;
            this.calculateFunctionResultCallback = null;
            this.addHelpIcons = false;
            this.currentHelpPage = null;
            this.currentHelpSection = null;
            // TODO: Should this be an absolute path based on whether running as WordPress plugin or NodeJS?
            this.applicationDirectory = "";
            this.idsMade = {};
            this.idCount = 0;
            this.readOnly = false;
        }
        PanelBuilder.addPlugin = function (name, callback) {
            buildingFunctions[name] = callback;
        };
        // provide a way to find definitions needed to  build internal panels for some widgets like the GridWithItemPanel
        PanelBuilder.prototype.setPanelSpecifications = function (panelSpecificationCollection) {
            this.panelSpecificationCollection = panelSpecificationCollection;
        };
        // Convert arbitrary text to ids
        PanelBuilder.prototype.getIdForText = function (text) {
            if (!this.idsMade["$" + text]) {
                this.idsMade["$" + text] = this.idCount++;
            }
            return "panelField_" + this.idsMade["$" + text];
        };
        PanelBuilder.prototype.addMissingWidgetPlaceholder = function (panelBuilder, model, fieldSpecification) {
            var prompt = panelBuilder.buildQuestionLabel(fieldSpecification);
            return m("div", [
                prompt,
                m("b", "Unsupported widget type: " + fieldSpecification.displayType + " for: " + fieldSpecification.id)
            ]);
        };
        PanelBuilder.prototype.buildField = function (model, fieldSpecification) {
            // console.log("buildField", fieldSpecification);
            var displayVisible = fieldSpecification.displayVisible;
            if (displayVisible === undefined)
                displayVisible = true;
            if (typeof displayVisible === "function")
                displayVisible = displayVisible(this, model, fieldSpecification);
            if (!displayVisible)
                return m("div");
            var addFunction = buildingFunctions[fieldSpecification.displayType];
            if (!addFunction) {
                if (debugFailIfMissingWidgets) {
                    // Would be thrown if you forget to call "PanelBuilder.addStandardPlugins();" or similar at the beginning of your application
                    var error = "ERROR: unsupported field display type: " + fieldSpecification.displayType;
                    console.log(error);
                    throw new Error(error);
                }
                addFunction = this.addMissingWidgetPlaceholder.bind(this);
            }
            if (_.isString(addFunction)) {
                var addFunctionName = addFunction;
                addFunction = this[addFunctionName];
                if (!addFunction) {
                    var error2 = "ERROR: missing addFunction for: " + addFunctionName + " for field display type: " + fieldSpecification.displayType;
                    console.log(error2);
                    throw new Error(error2);
                }
            }
            try {
                return addFunction(this, model, fieldSpecification);
            }
            catch (e) {
                console.log("Exception creating widget", fieldSpecification, e);
                return m("div", { style: "border: 1px solid red; margin: 10px;" }, ["Problem creating widget type: " + fieldSpecification.displayType + " :: id: " + fieldSpecification.id, m("br"), "Exception: " + e]);
            }
        };
        // Returns array of widgets built from the fieldSpecifications
        PanelBuilder.prototype.buildFields = function (fieldSpecifications, model) {
            // console.log("buildFields", fieldSpecifications);
            if (!fieldSpecifications) {
                throw new Error("fieldSpecifications are not defined");
            }
            var fields = [];
            for (var fieldSpecificationIndex = 0; fieldSpecificationIndex < fieldSpecifications.length; fieldSpecificationIndex++) {
                var fieldSpecification = fieldSpecifications[fieldSpecificationIndex];
                var widget = this.buildField(model, fieldSpecification);
                fields.push(widget);
            }
            return fields;
        };
        // Build an entire panel; panel can be either a string ID referring to a panel or it can be a panel definition itself
        PanelBuilder.prototype.buildPanel = function (panelOrPanelID, model) {
            // console.log("buildPanel", panelOrPanelID);
            var fieldSpecifications;
            if (_.isString(panelOrPanelID)) {
                var panel = this.getPanelDefinitionForPanelID(panelOrPanelID);
                fieldSpecifications = panel.panelFields;
            }
            else if (panelOrPanelID.buildPanel) {
                // Call explicit constructor function
                return panelOrPanelID.buildPanel(this, model);
            }
            else {
                fieldSpecifications = panelOrPanelID.panelFields;
            }
            return this.buildFields(fieldSpecifications, model);
        };
        // Set this correctly before building a page to provide default help when it is not in a field specification
        PanelBuilder.prototype.setCurrentHelpPageAndSection = function (helpPage, helpSection) {
            this.currentHelpPage = helpPage;
            this.currentHelpSection = helpSection;
        };
        /// Suport functions
        PanelBuilder.prototype.getPanelDefinitionForPanelID = function (panelID) {
            if (!this.panelSpecificationCollection) {
                throw new Error("No panelSpecificationCollection set in PanelBuilder so can not resolve panelID: " + panelID);
            }
            var panelSpecification = this.panelSpecificationCollection.getPanelSpecificationForPanelID(panelID);
            if (!panelSpecification) {
                throw new Error("No panelSpecification found by PanelBuilder for panelID: " + panelID);
            }
            // console.log("getPanelDefinitionForPanelID", panelID, panelSpecification);
            return panelSpecification;
        };
        // Convenience method for most common case of finding page specification
        PanelBuilder.prototype.getPageSpecificationForPageID = function (pageID) {
            if (!this.panelSpecificationCollection) {
                throw new Error("No panelSpecificationCollection set in PanelBuilder so can not resolve pageID: " + pageID);
            }
            var pageSpecification = this.panelSpecificationCollection.getPageSpecificationForPageID(pageID);
            if (!pageSpecification) {
                throw new Error("No pageSpecification found by PanelBuilder for pageID: " + pageID);
            }
            // console.log("getPageSpecificationForPageID", pageID, pageSpecification);
            return pageSpecification;
        };
        // Provide a way to tell buttons what to do when clicked
        PanelBuilder.prototype.setButtonClickedCallback = function (callback) {
            this.buttonClickedCallback = callback;
        };
        PanelBuilder.prototype.buttonClicked = function (model, fieldSpecification, event) {
            if (_.isFunction(fieldSpecification.displayConfiguration)) {
                // Do callback; this can't be defined in JSON, but can be defined in an application
                fieldSpecification.displayConfiguration();
                return;
            }
            if (!this.buttonClickedCallback) {
                console.log("No buttonClickedCallback set in panelBuilder", this, fieldSpecification);
                throw new Error("No buttonClickedCallback set for PanelBuilder");
            }
            this.buttonClickedCallback(this, model, fieldSpecification, event);
        };
        PanelBuilder.prototype.setCalculateFunctionResultCallback = function (callback) {
            this.calculateFunctionResultCallback = callback;
        };
        PanelBuilder.prototype.calculateFunctionResult = function (model, fieldSpecification) {
            if (_.isFunction(fieldSpecification.displayConfiguration)) {
                // Do callback; this can't be defined in JSON, but can be defined in an application
                return fieldSpecification.displayConfiguration();
            }
            if (!this.calculateFunctionResultCallback) {
                console.log("No calculateFunctionResultCallback set in panelBuilder", this, fieldSpecification);
                throw new Error("No calculateFunctionResultCallback set for PanelBuilder");
            }
            return this.calculateFunctionResultCallback(this, model, fieldSpecification, fieldSpecification.displayConfiguration);
        };
        // This will only be valid during the building process for a page
        PanelBuilder.prototype.helpPageURLForField = function (fieldSpecification) {
            var section = fieldSpecification.helpSection;
            if (!section)
                section = this.currentHelpSection;
            var pageID = fieldSpecification.helpPage;
            if (!pageID)
                pageID = this.currentHelpPage;
            var helpID = fieldSpecification.helpID;
            if (!helpID)
                helpID = fieldSpecification.id;
            // console.log("helpPageURLForField", fieldSpecification, section, pageID, helpID);
            var url = "";
            if (section && pageID) {
                url = '/help/' + section + "/help_" + pageID + '.html';
                if (helpID)
                    url += '#' + helpID;
            }
            return url;
        };
        // TODO: Fix all this so attaching actual JavaScript function not text to be interpreted
        PanelBuilder.prototype.htmlForInformationIcon = function (url) {
            if (!url)
                return "";
            var template = '<img src="{iconFile}" height=16 width=16 title="{title}" onclick="window.narraFirma_launchApplication(\'{url}\', \'help\')">';
            var replacements = {
                // TODO: Remove unused images from project
                // "/images/Info_blauw.png"
                // "/images/Blue_question_mark_icon.svg"
                iconFile: this.applicationDirectory + 'images/Information_icon4.svg',
                title: "Click to open help system window on this topic...",
                url: url
            };
            function replace(template, values) {
                var result = template;
                for (var key in replacements) {
                    result = result.split('{' + key + '}').join(replacements[key]);
                }
                return result;
            }
            return replace(template, replacements);
        };
        PanelBuilder.prototype.addAllowedHTMLToPrompt = function (text) {
            return sanitizeHTML.generateSanitizedHTMLForMithril(text);
        };
        PanelBuilder.prototype.substituteCalculatedResultInBaseText = function (baseText, calculatedText) {
            var newLabelText;
            if (baseText.indexOf(ResultTagToReplace) !== -1) {
                newLabelText = baseText.replace(ResultTagToReplace, calculatedText);
            }
            else {
                newLabelText = baseText + " " + calculatedText;
            }
            return newLabelText;
        };
        PanelBuilder.prototype.buildQuestionLabel = function (fieldSpecification) {
            return [
                // TODO: Generalize this css class name
                m("span", { "class": "questionPrompt" }, this.addAllowedHTMLToPrompt(fieldSpecification.displayPrompt))
            ];
        };
        return PanelBuilder;
    })();
    addStandardPlugins();
    return PanelBuilder;
});

define('js/applicationPanelSpecifications/dashboard/page_dashboard',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_dashboard",
        displayName: "Home",
        panelFields: [
            {
                id: "project_mainDashboardPNIPhasesDiagram",
                valueType: "none",
                displayType: "html",
                displayPrompt: "<img class=\"narrafirma-pni-phases-image\" src=\"images/PNIPhasesDiagram-trimmed.png\" alt=\"PNI Phase Diagram\" usemap=\"#pniphasesmap\"></img>"
            },
            {
                id: "project_mainDashboardPNIPhasesImageMap",
                valueType: "none",
                displayType: "html",
                displayPrompt: "<map name=\"pniphasesmap\"><area shape=\"rect\" coords=\"4,44,111,162\" href=\"javascript:narrafirma_openPage('page_planning')\" alt=\"Planning\" title=\"Click here to go to the Planning section\"><area shape=\"rect\" coords=\"224,66,336,182\" href=\"javascript:narrafirma_openPage('page_collection')\" alt=\"Collection\" title=\"Click here to go to the Collection section\"><area shape=\"rect\" coords=\"447,46,553,162\" href=\"javascript:narrafirma_openPage('page_catalysis')\" alt=\"Catalysis\" title=\"Click here to go to the Catalysis section\"><area shape=\"rect\" coords=\"104,199,213,321\" href=\"javascript:narrafirma_openPage('page_return')\" alt=\"Return\" title=\"Click here to go to the Return section\"><area shape=\"rect\" coords=\"344,199,454,320\" href=\"javascript:narrafirma_openPage('page_sensemaking')\" alt=\"Sensemaking\" title=\"Click here to go to the Sensemaking section\"><area shape=\"rect\" coords=\"212,354,437,451\" href=\"javascript:narrafirma_openPage('page_intervention')\" alt=\"Intervention\" title=\"Click here to go to the Intervention section\"></map>"
            },
            {
                id: "project_launchSection_administration",
                valueType: "none",
                displayType: "dashboardSectionStatusDisplay",
                displayPreventBreak: false,
                displayConfiguration: {
                    action: "guiOpenSection",
                    section: "page_administration"
                },
                displayPrompt: "Administration"
            },
            {
                id: "project_launchSection_planning",
                valueType: "none",
                displayType: "dashboardSectionStatusDisplay",
                displayPreventBreak: false,
                displayConfiguration: {
                    action: "guiOpenSection",
                    section: "page_planning"
                },
                displayPrompt: "Planning"
            },
            {
                id: "project_launchSection_collection",
                valueType: "none",
                displayType: "dashboardSectionStatusDisplay",
                displayPreventBreak: false,
                displayConfiguration: {
                    action: "guiOpenSection",
                    section: "page_collection"
                },
                displayPrompt: "Collection"
            },
            {
                id: "project_launchSection_catalysis",
                valueType: "none",
                displayType: "dashboardSectionStatusDisplay",
                displayPreventBreak: false,
                displayConfiguration: {
                    action: "guiOpenSection",
                    section: "page_catalysis"
                },
                displayPrompt: "Catalysis"
            },
            {
                id: "project_launchSection_sensemaking",
                valueType: "none",
                displayType: "dashboardSectionStatusDisplay",
                displayPreventBreak: false,
                displayConfiguration: {
                    action: "guiOpenSection",
                    section: "page_sensemaking"
                },
                displayPrompt: "Sensemaking"
            },
            {
                id: "project_launchSection_intervention",
                valueType: "none",
                displayType: "dashboardSectionStatusDisplay",
                displayPreventBreak: false,
                displayConfiguration: {
                    action: "guiOpenSection",
                    section: "page_intervention"
                },
                displayPrompt: "Intervention"
            },
            {
                id: "project_launchSection_return",
                valueType: "none",
                displayType: "dashboardSectionStatusDisplay",
                displayPreventBreak: false,
                displayConfiguration: {
                    action: "guiOpenSection",
                    section: "page_return"
                },
                displayPrompt: "Return"
            },
            {
                id: "project_mainDashboardStoryCollectionStatus",
                valueType: "none",
                displayType: "dashboardStoryCollectionStatusDisplay",
                displayPrompt: "Story collections"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/administration/page_administration',["require", "exports", "../../versions"], function (require, exports, versions) {
    "use strict";
    var panel = {
        id: "page_administration",
        displayName: "Administration",
        panelFields: [
            {
                id: "administrationVersionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "NarraFirma version: " + versions.narrafirmaApplication
            },
            {
                id: "administrationIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In the administration section, you can do house-keeping actions like backing up data. Below are links to each activity, along with any reminders you may have entered on them."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/administration/page_importExport',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_importExport",
        displayName: "Import & Export",
        panelFields: [
            {
                id: "importExport_header",
                valueType: "none",
                displayType: "label",
                displayPrompt: "This page can be used to import or export project data in various ways."
            },
            {
                id: "importExport_export",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportEntireProject",
                displayPrompt: "Export entire project with history (includes survey results)"
            },
            {
                id: "importExport_import",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "importEntireProject",
                displayPrompt: "Import entire project with history"
            },
            {
                id: "project_projectFileUploaderForForm",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="projectFileUploader" name="files" title="Import Project from JSON File" style="display:none"/>'
            },
            {
                id: "importExport_exportCurrentProjectSummary",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportProjectCurrentStateWithSurveyResults",
                displayPrompt: "Export current state of project (with survey results)"
            },
            {
                id: "importExport_exportCurrentProjectSummaryWithoutSurveyResults",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportProjectCurrentStateWithoutSurveyResults",
                displayPrompt: "Export current state of project (without survey results)"
            },
            {
                id: "importExport_importCurrentProjectSummary",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "importProjectCurrentState",
                displayPrompt: "Import current state of project"
            },
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_planning',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_planning",
        displayName: "Planning",
        panelFields: [
            {
                id: "project_projectPlanningDescriptionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In the planning phase of your PNI project, you will make <strong>decisions</strong> about how your project will proceed. \nYou will think about your goals, your topic, your participants, and any opportunities and dangers you might encounter \n            during the project."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_projectFacts',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectFacts",
        displayName: "Enter project facts",
        tooltipText: "Record basic information about your project such as what it's about and who is doing it.",
        headerAbove: "Get Started",
        panelFields: [
            {
                id: "project_projectFacts",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will enter some <strong>facts</strong> about your project. The information you enter here will appear in your project report."
            },
            {
                id: "project_title",
                valueType: "string",
                displayType: "text",
                displayName: "Project title",
                displayPrompt: "What is the project's <strong>title</strong>?"
            },
            {
                id: "project_communityOrOrganizationName",
                valueType: "string",
                displayType: "text",
                displayName: "Community/organization name",
                displayPrompt: "What is the name of your <strong>community or organization</strong>?"
            },
            {
                id: "project_topic",
                valueType: "string",
                displayType: "text",
                displayName: "Project topic",
                displayPrompt: "Enter a brief name for the project's primary <strong>topic</strong>."
            },
            {
                id: "project_startAndEndDates",
                valueType: "string",
                displayType: "text",
                displayName: "Project start and end",
                displayPrompt: "What are the project's starting and ending <strong>dates</strong>?"
            },
            {
                id: "project_facilitators",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project facilitators",
                displayPrompt: "Who is <strong>facilitating</strong> the project?"
            },
            {
                id: "project_funders",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project funders",
                displayPrompt: "Who is funding or otherwise <strong>supporting</strong> the project?"
            },
            {
                id: "project_reportStartText",
                valueType: "string",
                displayType: "textarea",
                displayName: "General notes",
                displayPrompt: "Enter any <strong>general notes</strong> you want to remember about the project."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_planningQuestionsDraft',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_planningQuestionsDraft",
        displayName: "Answer PNI planning questions",
        tooltipText: "Start working on answers to questions about your project's goals, relationships, focus, range, scope, and emphasis.",
        panelFields: [
            {
                id: "project_draftQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will answer some <strong>planning questions</strong> about your project: its goals, relationships, focus, range, scope, and emphasis. If you don't have good answers for these questions right now, don't worry; you will have a chance to work on them again later."
            },
            {
                id: "project_pniQuestions_goal_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project goal",
                displayPrompt: "What is the <strong>goal</strong> of the project? Why are you doing it? What will be achieved if it succeeds?"
            },
            {
                id: "project_pniQuestions_relationships_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project relationships",
                displayPrompt: "What <strong>relationships</strong> are important to the project? Who will connect with whom, how, and why? Who will tell stories, listen to stories, make sense of stories, facilitate, and so on?"
            },
            {
                id: "project_pniQuestions_focus_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project focus",
                displayPrompt: "What is the <strong>focus</strong> of the project? What is it about? What is its subject matter?"
            },
            {
                id: "project_pniQuestions_range_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project range",
                displayPrompt: "What <strong>range</strong> (or ranges) of experience will the project cover? Which perspectives will be explored? (Perhaps multiple groups, or locations, or time frames.)"
            },
            {
                id: "project_pniQuestions_scope_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project scope",
                displayPrompt: "What is the project's <strong>scope</strong>? How many people will be involved? How many stories? How many questions? How many sessions?"
            },
            {
                id: "project_pniQuestions_emphasis_draft",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project emphasis",
                displayPrompt: "What is the project's <strong>emphasis</strong>? Which phases of PNI (planning, collection, catalysis, sensemaking, intervention, return) will be important to the project?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_participantGroups',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_participantGroups",
        displayName: "Describe participant groups",
        tooltipText: "Think about the people who will be telling stories.",
        headerAbove: "Think about Context",
        panelFields: [
            {
                id: "project_aboutParticipantGroups",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will think about groups of <strong>participants</strong> you want to involve in your project. \n(Examples might be: doctors and patients; staff and customers; natives, immigrants, and tourists.)\nThe choices you make here will influence the <strong>recommendations</strong> NarraFirma shows you (for story collection methods, \nquestions about stories, etc.)."
            },
            {
                id: "project_participantGroupsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addParticipantGroup",
                displayName: "Participant groups",
                displayPrompt: "Please add participant <strong>groups</strong> in the list below (typically up to three groups)."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_describeYourResources',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_describeYourResources",
        tooltipText: "Think about the resources you can draw on.",
        displayName: "Describe your resources",
        panelFields: [
            {
                id: "project_aboutYou",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page are a few questions about the <strong>resources</strong> available to you in carrying out your PNI project. As with the previous questions about participant groups, these choices will impact the recommendations you see later on in your project."
            },
            {
                id: "aboutYou_experience",
                valueType: "string",
                valueOptions: [
                    "none",
                    "a little",
                    "some",
                    "a lot"
                ],
                displayType: "select",
                displayName: "Experience",
                displayPrompt: "How much <strong>experience</strong> do you have facilitating PNI projects?"
            },
            {
                id: "aboutYou_help",
                valueType: "string",
                valueOptions: [
                    "none",
                    "a little",
                    "some",
                    "a lot"
                ],
                displayType: "select",
                displayName: "Help",
                displayPrompt: "How much <strong>help</strong> will you have carrying out this project?"
            },
            {
                id: "aboutYou_tech",
                valueType: "string",
                valueOptions: [
                    "none",
                    "a little",
                    "some",
                    "a lot"
                ],
                displayType: "select",
                displayName: "Technology",
                displayPrompt: "How many <strong>technological resources</strong> will you be able to use in carrying out this project?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_projectStories',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectStories",
        displayName: "Tell project stories",
        tooltipText: "Tell some stories about how your project might play out.",
        headerAbove: "Imagine the Future",
        panelFields: [
            {
                id: "project_projectStories",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will tell yourself some <strong>project stories</strong> about how your project might play out. These stories will help you think about how best to plan the project."
            },
            {
                id: "project_projectStoriesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_projectStory",
                displayName: "Project stories",
                displayPrompt: "These are the project stories you have told so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_createProjectStoryElements',["require", "exports"], function (require, exports) {
    "use strict";
    // TODO: Maybe store one set of diagrams for each type of question?
    // TODO: Maybe remove storiesList use and also supporting code?
    var panel = {
        id: "page_createProjectStoryElements",
        displayName: "Create project story elements",
        tooltipText: "Work with your stories to think about how you should plan your project.",
        panelFields: [
            {
                id: "project_storyElements_instructions",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will use your project stories to create <b>story elements</b>. Story elements are abstract representations of the meanings found in stories. Going through this exercise can help you think about what you want to happen in your project. (You can also do this exercise on paper. If you do that, skip to the bottom of this page to enter the story elements you created.)"
            },
            {
                id: "project_storyElements__questionType",
                valueType: "string",
                valueOptions: [
                    { value: "characters", label: "Characters: Who is doing things in this story?" },
                    { value: "situations", label: "Situations: What is going on in this story?" },
                    { value: "values", label: "Values: What matters to the characters in this story?" },
                    { value: "themes", label: "Themes: What is this story about?" },
                    { value: "relationships", label: "Relationships: How are the characters related in this story?" },
                    { value: "motivations", label: "Motivations: Why do the characters do what they do in this story?" },
                    { value: "beliefs", label: "Beliefs: What do people believe in this story?" },
                    { value: "conflicts", label: "Conflicts: Who or what stands in opposition in this story?" }
                ],
                displayDataOptionField: "label",
                displayType: "select",
                displayPrompt: "<b>1</b>. Choose a <b>type</b> of story element to create."
            },
            {
                id: "project_storyElements_storiesList",
                valueType: "object",
                valuePath: "project_projectStoriesList",
                displayType: "storiesList",
                displayPrompt: "\n                <b>2</b>. These are your project stories.\n                Click on the button below to copy them as clusters to the first diagram.\n            "
            },
            {
                id: "project_storyElements_copyButton1",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Copy planning stories to clustering diagram",
                displayConfiguration: "copyPlanningStoriesToClusteringDiagram"
            },
            {
                id: "project_storyElements_answersClusteringDiagram",
                valueType: "object",
                displayType: "clusteringDiagram",
                displayPrompt: "\n                <b>3</b>. For each story, come up with as many <b>answers</b> to the above question as you can.\n                For each answer, click the <b>New item</b> button to add it to the diagram below.\n            "
            },
            {
                id: "project_storyElements_copyButton2Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                <b>3</b>. When you have considered all of your project stories,\n                press the button below to copy the new items to the next clustering diagram. \n            "
            },
            {
                id: "project_storyElements_copyButton2",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Copy new answers to next clustering diagram",
                displayConfiguration: "copyAnswersToClusteringDiagram"
            },
            {
                id: "project_storyElements_answerClustersClusteringDiagram",
                valueType: "object",
                displayType: "clusteringDiagram",
                displayPrompt: "\n                <b>4</b>. Now <b>cluster</b> your answers together. \n                Drag the circles to place like with like.<br> \n                <b>5</b>. Give each cluster of answers a <b>name</b>. \n                Click the <b>New cluster</b> button to represent each answer cluster name on the diagram.\n            "
            },
            {
                id: "project_storyElements_copyButton3Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                <b>6</b>. Press the button below to copy the answer cluster names to the next clustering diagram. \n            "
            },
            {
                id: "project_storyElements_copyButton3",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Copy new answers to next clustering diagram",
                displayConfiguration: "copyAnswerClustersToClusteringDiagram"
            },
            {
                id: "project_storyElements_attributesClusteringDiagram",
                valueType: "object",
                displayType: "clusteringDiagram",
                displayPrompt: "\n                <b>7</b>. Describe each cluster by adding <b>attributes</b> to it as new items. \n                Ask yourself: What is good and bad about this cluster? What helps you, and what works against you? \n                Where is the opportunity, and where is the challenge? Create at least two positive and two negative \n                attributes for each cluster. (If you can't think of both positive and negative attributes, keep trying. \n                The exercise depends on the attributes being balanced.)\n            "
            },
            {
                id: "project_storyElements_copyButton4Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                <b>8</b>. Press the button below to copy the new attribute items to the next clustering diagram. \n            "
            },
            {
                id: "project_storyElements_copyButton4",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Copy new attributes to next clustering diagram",
                displayConfiguration: "copyAttributesToClusteringDiagram"
            },
            {
                id: "project_storyElements_attributeClustersClusteringDiagram",
                valueType: "object",
                displayType: "clusteringDiagram",
                displayPrompt: "\n                <b>9</b>. <b>Rearrange</b> the attributes into <em>new</em> clusters, placing like with like as you did before.<br>\n                <b>10</b>. <b>Create new clusters</b> with new names and descriptions. These are your story elements.\n            "
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_assessStorySharing',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_assessStorySharing",
        displayName: "Assess story sharing",
        tooltipText: "Consider how stories flow in your community or organization.",
        panelFields: [
            {
                id: "assessment_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can assess the <strong>story sharing culture</strong> of your community or organization. (This page is not connected to the recommendations system, but it can help you plan your project, especially if you are unsure about your participants.)"
            },
            {
                id: "assessment_intro_more",
                valueType: "none",
                displayType: "label",
                displayPrompt: "Before you answer these questions, you should spend some time <strong>listening to people</strong> sharing stories together in the places where they normally gather."
            },
            {
                id: "assessment_narrativeFreedom",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Narrative freedom"
            },
            {
                id: "assessment_counterStories",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Countering",
                displayPrompt: "As you listened to people talk, how often did you hear a person respond to a story with another story that <strong>countered</strong> it in some way?"
            },
            {
                id: "assessment_authority",
                valueType: "string",
                valueOptions: [
                    "enthrallment",
                    "strong listening",
                    "partial listening",
                    "nothing special",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Authority",
                displayPrompt: "When someone who was obviously in <strong>authority</strong> was telling stories, how much time and attention did they get?"
            },
            {
                id: "assessment_mistakes",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Mistakes",
                displayPrompt: "How many times did you hear people tell stories about <strong>mistakes</strong>?"
            },
            {
                id: "assessment_silencing",
                valueType: "string",
                valueOptions: [
                    "warning",
                    "caution",
                    "request",
                    "joke",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Stepping in",
                displayPrompt: "When somebody started telling a story and another person <strong>stopped</strong> them, <em>how</em> did they stop them?"
            },
            {
                id: "assessment_conflict",
                valueType: "string",
                valueOptions: [
                    "demand",
                    "criticism",
                    "comment",
                    "joke",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Disagreement",
                displayPrompt: "When somebody was telling a story and another person <strong>disagreed</strong> with the storyteller, <em>how</em> did they disagree?"
            },
            {
                id: "assessment_narrativeFlow",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Narrative flow"
            },
            {
                id: "assessment_remindings",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Reminding",
                displayPrompt: "When you listened to people telling stories, did you ever hear people say \"that reminds me of the time\" and then tell a story <strong>in response</strong>?"
            },
            {
                id: "assessment_retellings",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Passing on stories",
                displayPrompt: "How often did you hear people <strong>pass on</strong> stories they heard from other people?"
            },
            {
                id: "assessment_folklore",
                valueType: "string",
                valueOptions: [
                    "none",
                    "little",
                    "some",
                    "strong",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Folklore",
                displayPrompt: "How much evidence did you find for a <strong>narrative folklore</strong> in your community or organization?"
            },
            {
                id: "assessment_storyTypes",
                valueType: "string",
                valueOptions: [
                    "no",
                    "maybe",
                    "I think so",
                    "definitely",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Story types",
                displayPrompt: "Did you hear these story <strong>genres</strong>: comic stories, tragic stories, epic stories, and funny stories?"
            },
            {
                id: "assessment_sensemaking",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Decision making",
                displayPrompt: "Did you ever see people sharing stories as they prepared to make <strong>decisions</strong>?"
            },
            {
                id: "assessment_narrativeKnowledge",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Narrative knowledge"
            },
            {
                id: "assessment_realStories",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Recountings of events",
                displayPrompt: "Did you see people tell stories that were <strong>recountings of events</strong> based on emotional experiences from particular perspectives?"
            },
            {
                id: "assessment_negotiations",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Vitality",
                displayPrompt: "How often did you see <strong>negotiations</strong> between storytellers and audiences?"
            },
            {
                id: "assessment_cotelling",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Sharing storytelling",
                displayPrompt: "Did you ever see two or more people tell a story <strong>together</strong>?"
            },
            {
                id: "assessment_blunders",
                valueType: "string",
                valueOptions: [
                    "often",
                    "sometimes",
                    "seldom",
                    "never",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Blunders",
                displayPrompt: "How often did you see someone start telling the <strong>wrong</strong> story, to the wrong people, at the wrong time?"
            },
            {
                id: "assessment_accounting",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Accountability",
                displayPrompt: "Did you see people <strong>account</strong> for their actions and choices by telling each other stories?"
            },
            {
                id: "assessment_narrativeUnity",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Narrative unity"
            },
            {
                id: "assessment_commonStories",
                valueType: "string",
                valueOptions: [
                    "impossible",
                    "difficult",
                    "doable",
                    "easy",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Common stories",
                displayPrompt: "How easy would it be to create a list of <strong>common stories</strong>, those any member of your community or organization could be expected to know?"
            },
            {
                id: "assessment_sacredStories",
                valueType: "string",
                valueOptions: [
                    "impossible",
                    "difficult",
                    "doable",
                    "easy",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Sacred stories",
                displayPrompt: "How easy would it be to create a list of <strong>sacred stories</strong>, those important to understanding the community or organization?"
            },
            {
                id: "assessment_condensedStories",
                valueType: "string",
                valueOptions: [
                    "impossible",
                    "difficult",
                    "doable",
                    "easy",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Condensed stories",
                displayPrompt: "How easy would it be to create a list of <strong>condensed stories</strong>, in the form of proverbs or references?"
            },
            {
                id: "assessment_intermingling",
                valueType: "string",
                valueOptions: [
                    "never",
                    "seldom",
                    "sometimes",
                    "often",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Intermingling",
                displayPrompt: "How often were the stories you heard <strong>intermingled</strong> with each other?"
            },
            {
                id: "assessment_culture",
                valueType: "string",
                valueOptions: [
                    "impossible",
                    "difficult",
                    "doable",
                    "easy",
                    "I don't know"
                ],
                displayType: "select",
                displayName: "Culture",
                displayPrompt: "How easy would it be to describe the unique story sharing <strong>culture</strong> of your community or organization?"
            },
            {
                id: "assessment_result_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your score"
            },
            {
                id: "assessment_result_freedomSubscore",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_counterStories",
                    "assessment_authority",
                    "assessment_mistakes",
                    "assessment_silencing",
                    "assessment_conflict"
                ],
                displayPrompt: "Narrative <strong>freedom</strong>:"
            },
            {
                id: "assessment_result_flowSubscore",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_remindings",
                    "assessment_retellings",
                    "assessment_folklore",
                    "assessment_storyTypes",
                    "assessment_sensemaking"
                ],
                displayPrompt: "Narrative <strong>flow</strong>:"
            },
            {
                id: "assessment_result_knowledgeSubscore",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_realStories",
                    "assessment_negotiations",
                    "assessment_cotelling",
                    "assessment_blunders",
                    "assessment_accounting"
                ],
                displayPrompt: "Narrative <strong>knowledge</strong>:"
            },
            {
                id: "assessment_result_unitySubscore",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_commonStories",
                    "assessment_sacredStories",
                    "assessment_condensedStories",
                    "assessment_intermingling",
                    "assessment_culture"
                ],
                displayPrompt: "Narrative <strong>unity</strong>:"
            },
            {
                id: "assessment_result_grandTotal",
                valueType: "none",
                displayType: "quizScoreResult",
                displayConfiguration: [
                    "assessment_counterStories",
                    "assessment_authority",
                    "assessment_mistakes",
                    "assessment_silencing",
                    "assessment_conflict",
                    "assessment_remindings",
                    "assessment_retellings",
                    "assessment_folklore",
                    "assessment_storyTypes",
                    "assessment_sensemaking",
                    "assessment_realStories",
                    "assessment_negotiations",
                    "assessment_cotelling",
                    "assessment_blunders",
                    "assessment_accounting",
                    "assessment_commonStories",
                    "assessment_sacredStories",
                    "assessment_condensedStories",
                    "assessment_intermingling",
                    "assessment_culture"
                ],
                displayPrompt: "Combined score:"
            },
            {
                id: "assessment_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Here you can record some <strong>notes</strong> or comments about this assessment."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_revisePNIPlanningQuestions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_revisePNIPlanningQuestions",
        displayName: "Revise PNI planning questions",
        tooltipText: "Go back to your goals, focus, etc., and see how you can improve what you wrote before.",
        headerAbove: "Wrap Up Planning",
        panelFields: [
            {
                id: "project_improvePlanningDrafts",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can review and improve your draft answers to the <strong>PNI planning questions</strong>, based on your consideration of project aspects and your project stories."
            },
            {
                id: "project_pniQuestions_copyDraftsButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "copyDraftPNIQuestionVersionsIntoAnswers",
                displayPrompt: "Copy your draft versions into any empty answers below"
            },
            {
                id: "project_pniQuestions_goal_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project goal",
                displayPrompt: "What is the <strong>goal</strong> of the project? Why are you doing it? What will be achieved if it succeeds?"
            },
            {
                id: "project_pniQuestions_relationships_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project relationships",
                displayPrompt: "What <strong>relationships</strong> are important to the project? Who will connect with whom, how, and why? Who will tell stories, listen to stories, make sense of stories, facilitate, and so on?"
            },
            {
                id: "project_pniQuestions_focus_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project focus",
                displayPrompt: "What is the <strong>focus</strong> of the project? What is it about? What is its subject matter?"
            },
            {
                id: "project_pniQuestions_range_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project range",
                displayPrompt: "What <strong>range</strong> (or ranges) of experience will the project cover? Which perspectives will be explored? (Perhaps multiple groups, or locations, or time frames.)"
            },
            {
                id: "project_pniQuestions_scope_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project scope",
                displayPrompt: "What is the project's <strong>scope</strong>? How many people will be involved? How many stories? How many questions? How many sessions?"
            },
            {
                id: "project_pniQuestions_emphasis_final",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project emphasis",
                displayPrompt: "What is the project's <strong>emphasis</strong>? Which phases of PNI (planning, collection, catalysis, sensemaking, intervention, return) will be important to the project?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/page_writeProjectSynopsis',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeProjectSynopsis",
        displayName: "Write project synopsis",
        tooltipText: "Summarize your project planning with a brief description you can show to other people.",
        panelFields: [
            {
                id: "project_synopsis_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can write your project <strong>synopsis</strong>, a one or two sentence summary of what matters most about your project."
            },
            {
                id: "project_synopsis",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project synopsis",
                displayPrompt: "Your synopsis should briefly <strong>summarize</strong> the project, so that anyone who hears about it can quickly understand what you are doing and why."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/panel_addParticipantGroup',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addParticipantGroup",
        modelClass: "ParticipantGroup",
        panelFields: [
            {
                id: "participantGroup_name",
                valueType: "string",
                displayType: "text",
                displayName: "Participant group name",
                displayPrompt: "Please <strong>name</strong> this group of participants (for example, \"doctors\", \"students\", \"staff\")."
            },
            {
                id: "participantGroup_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> this group of participants."
            },
            {
                id: "participantGroup_statusHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Status"
            },
            {
                id: "participantGroup_status",
                valueType: "string",
                valueOptions: [
                    "very low",
                    "low",
                    "moderate",
                    "high",
                    "very high",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Status",
                displayPrompt: "What is the <strong>status</strong> of these participants in the community or organization?"
            },
            {
                id: "participantGroup_confidence",
                valueType: "string",
                valueOptions: [
                    "very low",
                    "low",
                    "medium",
                    "high",
                    "very high",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Self-confidence",
                displayPrompt: "How much <strong>self-confidence</strong> do these participants have?"
            },
            {
                id: "participantGroup_abilityHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Ability"
            },
            {
                id: "participantGroup_time",
                valueType: "string",
                valueOptions: [
                    "very little",
                    "little",
                    "some",
                    "a lot",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Free time",
                displayPrompt: "How much free <strong>time</strong> do these participants have?"
            },
            {
                id: "participantGroup_education",
                valueType: "string",
                valueOptions: [
                    "illiterate",
                    "minimal",
                    "moderate",
                    "high",
                    "very high",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Education level",
                displayPrompt: "What is the <strong>education</strong> level of these participants?"
            },
            {
                id: "participantGroup_physicalDisabilities",
                valueType: "string",
                valueOptions: [
                    "none",
                    "minimal",
                    "moderate",
                    "strong",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Physical limitations",
                displayPrompt: "Do these participants have <strong>physical limitations</strong> that will impact their participation?"
            },
            {
                id: "participantGroup_emotionalImpairments",
                valueType: "string",
                valueOptions: [
                    "none",
                    "minimal",
                    "moderate",
                    "strong",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Emotional limitations",
                displayPrompt: "Do these participants have <strong>emotional impairments</strong> that will impact their participation (such as mental illness or traumatic stress)?"
            },
            {
                id: "participantGroup_expectationsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Expectations"
            },
            {
                id: "participantGroup_performing",
                valueType: "string",
                valueOptions: [
                    "very unimportant",
                    "somewhat unimportant",
                    "somewhat important",
                    "very important",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Performance",
                displayPrompt: "For these participants, how important is <strong>performing</strong> well (with \"high marks\")?"
            },
            {
                id: "participantGroup_conforming",
                valueType: "string",
                valueOptions: [
                    "very unimportant",
                    "somewhat unimportant",
                    "somewhat important",
                    "very important",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Conformance",
                displayPrompt: "For these participants, how important is <strong>conforming</strong> (to what is \"normal\" or expected)?"
            },
            {
                id: "participantGroup_promoting",
                valueType: "string",
                valueOptions: [
                    "very unimportant",
                    "somewhat unimportant",
                    "somewhat important",
                    "very important",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Self-promotion",
                displayPrompt: "For these participants, how important is <strong>self-promotion</strong> (competing with others)?"
            },
            {
                id: "participantGroup_venting",
                valueType: "string",
                valueOptions: [
                    "very unimportant",
                    "somewhat unimportant",
                    "somewhat important",
                    "very important",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Speaking out",
                displayPrompt: "For these participants, how important is <strong>speaking out</strong> (having a say, venting, sounding off)?"
            },
            {
                id: "participantGroup_feelingsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Feelings about the project"
            },
            {
                id: "participantGroup_interest",
                valueType: "string",
                valueOptions: [
                    "very little",
                    "a little",
                    "some",
                    "a lot",
                    "extremely",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Motivated",
                displayPrompt: "How <strong>motivated</strong> are these people to participate in the project?"
            },
            {
                id: "participantGroup_feelings_project",
                valueType: "string",
                valueOptions: [
                    "negative",
                    "neutral",
                    "positive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Feelings about project",
                displayPrompt: "How are these participants likely to <strong>feel</strong> about the project? Will they see it as a good or bad thing?"
            },
            {
                id: "participantGroup_feelings_facilitator",
                valueType: "string",
                valueOptions: [
                    "negative",
                    "neutral",
                    "positive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Feelings about you",
                displayPrompt: "How do these participants feel about <strong>you</strong>?"
            },
            {
                id: "participantGroup_feelings_stories",
                valueType: "string",
                valueOptions: [
                    "negative",
                    "neutral",
                    "positive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Feel about stories",
                displayPrompt: "How do these participants feel about the idea of collecting <strong>stories</strong>?"
            },
            {
                id: "participantGroup_topicHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Feelings about the topic"
            },
            {
                id: "participantGroup_topic_feeling",
                valueType: "string",
                valueOptions: [
                    "strongly negative",
                    "negative",
                    "neutral",
                    "positive",
                    "strongly positive",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Experiences with topic",
                displayPrompt: "What experiences have these participants had with the project's <strong>topic</strong>?"
            },
            {
                id: "participantGroup_topic_private",
                valueType: "string",
                valueOptions: [
                    "very private",
                    "medium",
                    "not private",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "How private",
                displayPrompt: "How <strong>private</strong> do these participants consider the topic to be?"
            },
            {
                id: "participantGroup_topic_articulate",
                valueType: "string",
                valueOptions: [
                    "hard",
                    "medium",
                    "easy",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Articulation",
                displayPrompt: "How hard will it be for these participants to <strong>articulate</strong> their feelings about the topic? Do they know how they feel?"
            },
            {
                id: "participantGroup_topic_timeframe",
                valueType: "string",
                valueOptions: [
                    "hours",
                    "days",
                    "months",
                    "years",
                    "decades",
                    "mixed",
                    "unknown"
                ],
                displayType: "select",
                displayName: "Time period",
                displayPrompt: "How long of a <strong>time period</strong> do you need these participants to look back on?"
            },
            {
                id: "participantGroup_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any additional <strong>notes</strong> you want to remember about this group of participants."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/planning/panel_projectStory',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_projectStory",
        modelClass: "ProjectStory",
        panelFields: [
            {
                id: "projectStory_scenario",
                valueType: "string",
                valueOptions: [
                    "ask me anything",
                    "magic ears",
                    "fly on the wall",
                    "because of (something about the project)",
                    "my own scenario type"
                ],
                displayType: "select",
                displayName: "Scenario",
                displayPrompt: "Start by choosing a <strong>scenario</strong> for your project story. (Click \"Help\" for explanations of these scenario types.)"
            },
            {
                id: "projectStory_outcome",
                valueType: "string",
                valueOptions: [
                    "colossal success",
                    "miserable failure",
                    "acceptable outcome",
                    "my own outcome"
                ],
                displayType: "select",
                displayName: "Outcome",
                displayPrompt: "Now choose an <strong>outcome</strong> for your story. How will it end?"
            },
            {
                id: "projectStory_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Story",
                displayPrompt: "Now tell your project story. Tell it as a <strong>future history</strong>, as though it has already happened."
            },
            {
                id: "projectStory_name",
                valueType: "string",
                displayType: "text",
                displayName: "Project story name",
                displayPrompt: "Please <strong>name</strong> your project story."
            },
            {
                id: "projectStory_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project story surprise",
                displayPrompt: "What <strong>surprised</strong> you about this story?"
            },
            {
                id: "projectStory_dangers",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project story opportunities or dangers",
                displayPrompt: "Describe any <strong>opportunities</strong> or <strong>dangers</strong> you see in the story."
            },
            {
                id: "projectStory_changes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project story changes",
                displayPrompt: "Now that you've told and thought about this story, are there any <strong>changes</strong> you want to make to your project plans because of it?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_collection',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_collection",
        displayName: "Collection",
        panelFields: [
            {
                id: "project_collectionPhaseDescriptionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In the collection phase of your PNI project, you will decide on story collection <strong>methods</strong>; \nwrite <strong>questions</strong> for story elicitation and interpretation; design story <strong>forms</strong>; \ncollect stories over the <strong>web</strong>; and plan story collection <strong>sessions</strong>. You can also \n<strong>review</strong> incoming stories and enter <strong>records</strong> of story collection sessions."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_chooseCollectionMethods',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_chooseCollectionMethods",
        displayName: "Choose collection methods",
        tooltipText: "Decide how you will collect stories.",
        headerAbove: "Plan Your Story Collection",
        panelFields: [
            {
                id: "project_methodsIntro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will plan your story collection <strong>methods</strong>, or the ways you will collect stories."
            },
            {
                id: "SPECIAL_methodRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayConfiguration: "venues",
                displayPrompt: "Method recommendations"
            },
            {
                id: "project_methodsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addStoryCollectionMethod",
                displayName: "Story collection methods",
                displayPrompt: "These are the ways you will be collecting stories."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_planStoryCollectionSessions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_planStoryCollectionSessions",
        displayName: "Plan story collection sessions",
        tooltipText: "Create agendas for any group story sessions you want to hold.",
        panelFields: [
            {
                id: "project_collectionSessionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can design group <strong>sessions</strong> in which you will collect stories. (If you don't plan to collect stories using group sessions, you can skip this page.)"
            },
            {
                id: "SPECIAL_collectionSessionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayConfiguration: "sessions",
                displayPrompt: "Recommendations for story collection sessions"
            },
            {
                id: "project_collectionSessionPlansList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addStoryCollectionSession",
                displayName: "Story collection session plans",
                displayPrompt: "<strong>Plans</strong> for story collection sessions lay out what you will do and how. Each plan can be used in multiple sessions."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_writeStoryElicitingQuestions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeStoryElicitingQuestions",
        displayName: "Write story eliciting questions",
        tooltipText: "Think of questions you want people to answer by telling stories.",
        headerAbove: "Design Your Questions and Story Form",
        panelFields: [
            {
                id: "project_elicitingQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will design the questions you will use <strong>to ask people to tell stories</strong>. You need at least one question for people to answer. We recommend giving people three to five questions to choose from."
            },
            {
                id: "project_elicitingQuestionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addElicitingQuestion",
                displayName: "Story eliciting questions",
                displayPrompt: "These are the <strong>eliciting questions</strong> you have created so far."
            },
            {
                id: "SPECIAL_elicitingQuestionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayConfiguration: "elicitingQuestions",
                displayPrompt: "Recommendations for eliciting questions"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_writeQuestionsAboutStories',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeQuestionsAboutStories",
        displayName: "Write questions about stories",
        tooltipText: "Think of questions you want to ask people about their stories.",
        panelFields: [
            {
                id: "project_storyQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will write questions to ask people <strong>about their stories</strong>."
            },
            {
                id: "project_storyQuestionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addStoryQuestion",
                displayName: "Questions about stories",
                displayPrompt: "These are the questions you have written so far."
            },
            {
                id: "SPECIAL_storyQuestionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayConfiguration: "storyQuestions",
                displayPrompt: "Recommendations for story questions"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_writeQuestionsAboutParticipants',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeQuestionsAboutParticipants",
        displayName: "Write questions about participants",
        tooltipText: "Think of questions you want to ask people about themselves.",
        panelFields: [
            {
                id: "project_participantQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will write questions to ask people about <strong>themselves</strong>."
            },
            {
                id: "project_participantQuestionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addParticipantQuestion",
                displayName: "Questions about people",
                displayPrompt: "These are the questions you have written so far."
            },
            {
                id: "SPECIAL_participantQuestionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayConfiguration: "participantQuestions",
                displayPrompt: "Recommendations for participant questions"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_designStoryForms',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_designStoryForms",
        displayName: "Design story forms",
        tooltipText: "Bring your questions together into a structured conversation.",
        panelFields: [
            {
                id: "storyForms_Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "<p>On this page you will design one or more <strong>story forms</strong> for your project. Choose from the library of questions you already created to create the form your participants will use to tell their stories and answer questions about them.</p>"
            },
            {
                id: "project_storyForms",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addStoryForm",
                displayName: "Questionnaires",
                displayPrompt: "These are the story forms you have created so far."
            },
            {
                id: "project_csvFileUploaderForForm",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="csvFileLoader" name="files" title="Import Story Form from CSV File" style="display:none"/>'
            },
            {
                id: "project_importStoryFormAndDataFromCSV",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "importCSVQuestionnaire",
                displayPrompt: "Import story form from CSV file ..."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_startStoryCollection',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_startStoryCollection",
        displayName: "Start story collection",
        tooltipText: "Create a story repository, and if you want to, activate an online survey.",
        headerAbove: "Collect Stories",
        panelFields: [
            {
                id: "storyCollection_createCollectionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can create one or more <strong>story collections</strong> for your project. A story collection is a body of stories collected using a specific story form."
            },
            {
                id: "project_storyCollections",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addStoryCollection",
                    gridConfiguration: {
                        validateAdd: "storeQuestionnaireInStoryCollection",
                        viewButton: true,
                        editButton: true,
                        addButton: true,
                        removeButton: true,
                        customButton: { customButtonLabel: "Activate or Deactivate Web Form", callback: "toggleWebActivationOfSurvey" },
                        columnsToDisplay: ["storyCollection_shortName", "storyCollection_questionnaireIdentifier", "storyCollection_activeOnWeb", "storyCollection_notes"],
                        transformDisplayedValues: function (value, fieldName) {
                            if (fieldName !== "storyCollection_activeOnWeb")
                                return value;
                            return value ? "yes" : "no";
                        }
                    }
                },
                displayName: "Story collections",
                displayPrompt: "These are the story collections you have created so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_printQuestionForms',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_printQuestionForms",
        displayName: "Print story forms",
        tooltipText: "Export your story form for use in face-to-face sessions or interviews.",
        panelFields: [
            {
                id: "printQuestionsForm_introduction",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                On this page you can print story forms for off-line use. \n                Later, you can enter the completed forms into your story collection (see \"Enter stories\").\n                The printed form is intentionally simple, so you can format it\n                however you like in your word processor.\n                "
            },
            {
                id: "storyCollectionChoice_printing",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose the <strong>story collection</strong> whose story form you want to print."
            },
            {
                id: "printQuestionsForm_output",
                valueType: "none",
                displayType: "label",
                displayPrompt: ""
            },
            {
                id: "printQuestionsForm_printFormButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "printStoryForm",
                displayPrompt: "Print Story Form"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_enterStories',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_enterStories",
        displayName: "Enter stories",
        tooltipText: "Add stories you collected off-line.",
        panelFields: [
            {
                id: "enterStories_Label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can <strong>enter</strong> stories you collected from participants."
            },
            {
                id: "storyCollectionChoice_enterStories",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a <strong>story collection</strong> to add a story to."
            },
            {
                id: "project_enterStories",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "enterSurveyResult",
                displayPrompt: "Add Story..."
            },
            {
                id: "project_csvFileUploaderForStories",
                valueType: "none",
                displayType: "html",
                displayPrompt: '<input type="file" id="csvFileLoader" name="files" title="Import Stories from CSV File" style="display:none"/>'
            },
            {
                id: "project_importCSVStories",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "importCSVStories",
                displayPrompt: "Import story data from CSV file into story collection ..."
            },
            {
                id: "project_exportStoryForm",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportQuestionnaire",
                displayPrompt: "Export story form..."
            },
            {
                id: "project_exportStories",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "exportStoryCollection",
                displayPrompt: "Export story collection..."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_writeAnnotationsAboutStories',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_writeAnnotationsAboutStories",
        displayName: "Write annotations about stories",
        tooltipText: "Add some questions that you will answer by reading the stories you collected.",
        headerAbove: "Review, Repair, and Annotate",
        panelFields: [
            {
                id: "project_storyQuestionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can write questions you will use to <strong>annotate</strong> stories with additional information. You can add more annotation questions after you start collecting stories."
            },
            {
                id: "project_annotationQuestionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addAnnotationQuestion",
                displayName: "Annotations about stories",
                displayPrompt: "These are the annotation questions you have written so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_reviewIncomingStories',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reviewIncomingStories",
        displayName: "Review incoming stories",
        tooltipText: "Look at the stories you have collected, fix data entry mistakes, and answer any annotation questions you created.",
        panelFields: [
            {
                id: "collectedStoriesDuringCollectionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can see your <strong>collected stories</strong> as they come in."
            },
            {
                id: "storyCollectionChoiceX",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a <strong>story collection</strong> to review."
            },
            {
                id: "webStoryCollection_collectedStoriesDuringCollection",
                valuePath: "/clientState/storyCollectionName",
                valueType: "none",
                displayType: "storyBrowser",
                displayPrompt: "Collected stories"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_browseGraphs',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_browseGraphs",
        displayName: "Spot-check graphs",
        tooltipText: "Look at patterns in the data you collected.",
        panelFields: [
            {
                id: "graphBrowserLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can take a preliminary look at <strong>patterns</strong> in the answers people gave about their incoming stories. (This page is intended mainly to spot check for issues related to the story form design. You can review your graphs more systematically in the catalysis section.)"
            },
            {
                id: "storyCollectionChoiceY",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a <strong>story collection</strong> whose graphs you want to check."
            },
            {
                id: "graphBrowserDisplay",
                valuePath: "/clientState/storyCollectionName",
                valueType: "none",
                displayType: "graphBrowser",
                displayPrompt: "Choose one or two <strong>questions</strong> to explore."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_stopStoryCollection',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_stopStoryCollection",
        displayName: "Stop story collection",
        tooltipText: "Deactivate your online surveys.",
        headerAbove: "Wrap Up Story Collection",
        panelFields: [
            {
                id: "webStoryCollection_stopCollectionLabel2",
                valueType: "none",
                displayType: "label",
                displayPrompt: "If you are doing story collection over the internet, you can click this button to make <em>all</em> of your web surveys <strong>unavailable</strong>. You might want to do this when you have finished collecting stories for your project. You can re-enable story collection by going back to the \"Start story collection\" page."
            },
            {
                id: "webStoryCollection_disableWebStoryFormAfterStoryCollectionButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "storyCollectionStop",
                displayPrompt: "Disable All Web-based Story Collection"
            },
            {
                id: "webStoryCollection_enabledTracker2",
                valueType: "none",
                displayType: "functionResult",
                displayConfiguration: "isStoryCollectingEnabled",
                displayPrompt: "Web story collection enabled: <strong>{{result}}</strong>"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/page_enterCollectionSessionRecords',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_enterCollectionSessionRecords",
        displayName: "Enter story collection session records",
        tooltipText: "Learn from what happened when you collected stories in group sessions.",
        panelFields: [
            {
                id: "project_collectionRecordsIntroductionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can enter records for any group story <strong>sessions</strong> you held. (If you did not hold any group story sessions, you can skip this page.)"
            },
            {
                id: "project_collectionSessionRecordsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addCollectionSessionRecord",
                displayName: "Story collection session records",
                displayPrompt: "These are the sessions records you have created so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryCollectionMethod',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addStoryCollectionMethod",
        modelClass: "Venue",
        panelFields: [
            {
                id: "storyCollectionMethod_name",
                valueType: "string",
                displayType: "text",
                displayName: "Story collection method name",
                displayPrompt: "Please give this method plan a <strong>name</strong>."
            },
            {
                id: "storyCollectionMethod_primary_type",
                valueType: "string",
                valueOptions: [
                    "one-on-one expert interviews",
                    "group interviews",
                    "peer interviews",
                    "group story sessions",
                    "surveys",
                    "journals",
                    "narrative incident reports",
                    "gleaned stories",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of method is this?"
            },
            {
                id: "storyCollectionMethod_participantGroups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participants",
                displayPrompt: "Which <strong>group</strong> (or groups) of participants will tell stories using this method?"
            },
            {
                id: "storyCollectionMethod_participantGroupsMixing",
                valueType: "string",
                displayType: "textarea",
                displayName: "Mixing",
                displayPrompt: "What are your general plans for keeping participant groups <strong>together or apart</strong>?"
            },
            {
                id: "storyCollectionMethod_timeline",
                valueType: "string",
                displayType: "textarea",
                displayName: "Timeline",
                displayPrompt: "What is your <strong>timeline</strong> for collecting stories using this method?"
            },
            {
                id: "storyCollectionMethod_locations",
                valueType: "string",
                displayType: "textarea",
                displayName: "Locations",
                displayPrompt: "In what <strong>locations</strong> will stories be collected?"
            },
            {
                id: "storyCollectionMethod_help",
                valueType: "string",
                displayType: "textarea",
                displayName: "Help",
                displayPrompt: "What <strong>help</strong> will you have collecting stories? What are your plans for organizing your help?"
            },
            {
                id: "storyCollectionMethod_resources",
                valueType: "string",
                displayType: "textarea",
                displayName: "Technology",
                displayPrompt: "What <strong>technologies</strong>, if any, will you use to collect stories?"
            },
            {
                id: "storyCollectionMethod_why",
                valueType: "string",
                displayType: "textarea",
                displayName: "Why",
                displayPrompt: "<strong>Why</strong> did you choose this method? Why is it appropriate for this context?"
            },
            {
                id: "storyCollectionMethod_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "Describe any other <strong>details</strong> of your story collection plans for this method."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryCollectionSession',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addStoryCollectionSession",
        modelClass: "StoryCollectionSessionPlan",
        panelFields: [
            {
                id: "collectionSessionPlan_name",
                valueType: "string",
                displayType: "text",
                displayName: "Collection session plan name",
                displayPrompt: "Please give this session plan a <strong>name</strong>."
            },
            {
                id: "collectionSessionPlan_groups",
                valueType: "string",
                displayType: "text",
                displayName: "Participant groups",
                displayPrompt: "From which participant <strong>group</strong> (or groups) will people be invited?"
            },
            {
                id: "collectionSessionPlan_participantGroupsMixing",
                valueType: "string",
                displayType: "textarea",
                displayName: "Mixing",
                displayPrompt: "What are your plans for keeping participant groups <strong>together or apart</strong>?"
            },
            {
                id: "collectionSessionPlan_repetitions",
                valueType: "string",
                displayType: "text",
                displayName: "Repetitions",
                displayPrompt: "How many <strong>repetitions</strong> of the session will there be?"
            },
            {
                id: "collectionSessionPlan_duration",
                valueType: "string",
                displayType: "text",
                displayName: "Length",
                displayPrompt: "<strong>How long</strong> will each session be?"
            },
            {
                id: "collectionSessionPlan_times",
                valueType: "string",
                displayType: "text",
                displayName: "Time",
                displayPrompt: "<strong>When</strong> will these sessions take place?"
            },
            {
                id: "collectionSessionPlan_location",
                valueType: "string",
                displayType: "text",
                displayName: "Location",
                displayPrompt: "<strong>Where</strong> will these sessions take place?"
            },
            {
                id: "collectionSessionPlan_numPeople",
                valueType: "string",
                displayType: "text",
                displayName: "Number of people",
                displayPrompt: "<strong>How many people</strong> will be invited to each repetition of this session?"
            },
            {
                id: "collectionSessionPlan_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What <strong>materials</strong> will this session require?"
            },
            {
                id: "collectionSessionPlan_opportunitiesAndDangers",
                valueType: "string",
                displayType: "textarea",
                displayName: "Opportunities and dangers",
                displayPrompt: "What are some of the <strong>opportunities</strong> and <strong>dangers</strong> you foresee for this session plan?"
            },
            {
                id: "collectionSessionPlan_details",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "Here you can enter other <strong>details</strong> about this session."
            },
            {
                id: "collectionSessionPlan_activitiesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addCollectionSessionActivity",
                displayName: "Story collection activities",
                displayPrompt: "Here you can enter some <strong>activities</strong> you plan for the session. Activities within story collection sessions can be simple instructions or complicated exercises (like the creation of timelines)."
            },
            {
                id: "collectionSessionPlan_exportCollectionSessionAgendaButton",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Export session agenda",
                displayConfiguration: "exportCollectionSessionAgenda"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addCollectionSessionActivity',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addCollectionSessionActivity",
        modelClass: "CollectionSessionActivity",
        panelFields: [
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayName: "Order",
                displayPrompt: "Specify the <strong>order</strong> in which to do this collection activity (e.g., 1, 2a, 2b, 3)."
            },
            {
                id: "collectionSessionActivity_name",
                valueType: "string",
                displayType: "text",
                displayName: "Name",
                displayPrompt: "Please give this activity a <strong>name</strong>."
            },
            {
                id: "collectionSessionActivity_duration",
                valueType: "string",
                displayType: "text",
                displayName: "Length",
                displayPrompt: "<strong>How long</strong> will this activity take?"
            },
            {
                id: "collectionSessionActivity_type",
                valueType: "string",
                valueOptions: [
                    "ice-breaker",
                    "sharing stories (no task)",
                    "sharing stories (simple task)",
                    "discussing stories",
                    "looking for patterns in stories",
                    "twice-told stories exercise",
                    "timeline exercise",
                    "landscape exercise",
                    "my own exercise",
                    "break",
                    "wrap-up",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of activity is this?"
            },
            {
                id: "collectionSessionActivity_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Describe the <strong>plan</strong> for this activity."
            },
            {
                id: "collectionSessionActivity_optionalParts",
                valueType: "string",
                displayType: "textarea",
                displayName: "Optional elaborations",
                displayPrompt: "Describe any optional <strong>elaborations</strong> you might or might not use in this activity."
            },
            {
                id: "collectionSessionActivity_recording",
                valueType: "string",
                displayType: "textarea",
                displayName: "Recording",
                displayPrompt: "How will stories be <strong>recorded</strong> during this activity?"
            },
            {
                id: "collectionSessionActivity_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What <strong>materials</strong> will be needed for this activity?"
            },
            {
                id: "collectionSessionActivity_spaces",
                valueType: "string",
                displayType: "textarea",
                displayName: "Spaces",
                displayPrompt: "What <strong>spaces</strong> will be used for this activity?"
            },
            {
                id: "collectionSessionActivity_facilitation",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation",
                displayPrompt: "What sort of <strong>facilitation</strong> will be necessary for this activity?"
            },
            {
                id: "collectionSessionActivity_helping",
                valueType: "string",
                displayType: "textarea",
                displayName: "Helpers",
                displayPrompt: "What will <strong>helpers</strong> do during this activity?"
            },
            {
                id: "SPECIAL_templates_storyCollectionActivities",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "storyCollectionActivities",
                displayPrompt: "Copy an activity from a template"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addElicitingQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addElicitingQuestion",
        modelClass: "ElicitingQuestion",
        panelFields: [
            {
                id: "elicitingQuestion_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Question",
                displayPrompt: "What <strong>question</strong> will you ask? (Remember to write a question whose answer is a story.)"
            },
            {
                id: "elicitingQuestion_shortName",
                valueType: "string",
                displayType: "text",
                displayName: "Short Name",
                displayPrompt: "Enter a short <strong>name</strong> for this question, to use as a reference."
            },
            {
                id: "elicitingQuestion_type",
                valueType: "dictionary",
                valueOptions: [
                    "what happened",
                    "directed question",
                    "undirected question",
                    "point in time",
                    "event",
                    "extreme",
                    "surprise or change",
                    "people, places, things, decisions",
                    "fictional scenario",
                    "other"
                ],
                displayType: "checkboxes",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of question is this?"
            },
            {
                id: "SPECIAL_templates_elicitingQuestions",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "elicitationQuestions",
                displayPrompt: "Copy a question from a template"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addStoryQuestion",
        modelClass: "StoryQuestion",
        panelFields: [
            {
                id: "storyQuestion_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Question",
                displayPrompt: "Enter a <strong>question</strong> to ask people about their stories."
            },
            {
                id: "storyQuestion_type",
                valueType: "string",
                valueOptions: [
                    "boolean",
                    "label",
                    "header",
                    "checkbox",
                    "checkboxes",
                    "text",
                    "textarea",
                    "select",
                    "radiobuttons",
                    "slider"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of question is this? (For an explanation of the question types, click the Help button.)"
            },
            {
                id: "storyQuestion_shortName",
                valueType: "string",
                displayType: "text",
                displayName: "Short name",
                displayPrompt: "Please enter a <strong>short name</strong> we can use to refer to the question. (It must be unique within the project.)"
            },
            {
                id: "storyQuestion_options",
                valueType: "string",
                displayType: "textarea",
                displayName: "Options",
                displayPrompt: "\n                If your question requires <strong>choices</strong>, enter them here. \n                Write each choice on a separate line.\n                <br><br>\n                For a slider, enter the texts to place on the left and right sides of the slider, \n                then the text to show on the \"Does not apply\" checkbox (or leave the third line blank\n                to use \"Does not apply\"). \n            "
            },
            {
                id: "SPECIAL_templates_storyQuestions",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "storyQuestions",
                displayPrompt: "Copy a question from a template"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addParticipantQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addParticipantQuestion",
        modelClass: "ParticipantQuestion",
        panelFields: [
            {
                id: "participantQuestion_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Question",
                displayPrompt: "Enter a <strong>question</strong> to ask people about themselves."
            },
            {
                id: "participantQuestion_type",
                valueType: "string",
                valueOptions: [
                    "boolean",
                    "label",
                    "header",
                    "checkbox",
                    "checkboxes",
                    "text",
                    "textarea",
                    "select",
                    "radiobuttons",
                    "slider"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of question is this? (For an explanation of the question types, click the Help button.)"
            },
            {
                id: "participantQuestion_shortName",
                valueType: "string",
                displayType: "text",
                displayName: "Short name",
                displayPrompt: "Please enter a short <strong>name</strong> we can use to refer to the question. (It must be unique within the project.)"
            },
            {
                id: "participantQuestion_options",
                valueType: "string",
                displayType: "textarea",
                displayName: "Options",
                displayPrompt: "\n                If your question requires <strong>choices</strong>, enter them here. \n                Write each choice on a separate line.\n                <br><br>\n                For a slider, enter the texts to place on the left and right sides of the slider, \n                then the text to show on the \"Does not apply\" checkbox (or leave the third line blank\n                to use \"Does not apply\"). \n            "
            },
            {
                id: "SPECIAL_templates_participantQuestions",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "participantQuestions",
                displayPrompt: "Copy a question from a template"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryForm',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addStoryForm",
        modelClass: "StoryForm",
        panelFields: [
            {
                id: "questionForm_shortName",
                valueType: "string",
                displayType: "text",
                displayName: "Title",
                displayPrompt: "Please enter a short <strong>name</strong> for the story form, so we can refer to it elsewhere in the project. (It must be unique within the project.)"
            },
            {
                id: "questionForm_title",
                valueType: "string",
                displayType: "text",
                displayName: "Title",
                displayPrompt: "Please enter a <strong>title</strong> to be shown at the top of the story form."
            },
            {
                id: "questionForm_startText",
                valueType: "string",
                displayType: "textarea",
                displayName: "Introduction",
                displayPrompt: "Please enter an <strong>introduction</strong> to be shown at the start of the story form, after the title."
            },
            {
                id: "questionForm_image",
                valueType: "string",
                displayType: "text",
                displayName: "Image",
                displayPrompt: "You can link to a <strong>logo</strong> or other image to show at the top of the form."
            },
            {
                id: "questionForm_elicitingQuestions",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_chooseElicitingQuestion",
                displayName: "Eliciting questions",
                displayPrompt: "Add one or more <strong>eliciting questions</strong>, choosing from those you already wrote."
            },
            {
                id: "questionForm_storyQuestions",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_chooseStoryQuestion",
                displayName: "Story questions",
                displayPrompt: "Add one or more <strong>questions about stories</strong>, choosing from those you already wrote."
            },
            {
                id: "questionForm_participantQuestions",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_chooseParticipantQuestion",
                displayName: "Participant questions",
                displayPrompt: "Add one or more <strong>questions about participants</strong>, choosing from those you already wrote."
            },
            {
                id: "questionForm_endText",
                valueType: "string",
                displayType: "textarea",
                displayName: "End of form text",
                displayPrompt: "Please enter any <strong>closing text</strong> to be shown at the end of the form."
            },
            {
                id: "questionForm_participantGroups",
                valueType: "string",
                displayType: "text",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>groups</strong> is this story form intended for? (This information will not appear on the form; it's just for your records.)"
            },
            {
                id: "questionForm_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "If you'd like to make any <strong>notes</strong> to yourself about this form, you can make them here. (They won't appear on the form.)"
            },
            {
                id: "questionForm_preview",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "previewQuestionForm",
                displayName: "Question form preview",
                displayPrompt: "Preview question form"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_chooseElicitingQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_chooseElicitingQuestion",
        modelClass: "ElicitingQuestionChoice",
        panelFields: [
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayName: "Order",
                displayPrompt: "Specify the order to present this eliciting question (e.g. 1, 2a, 2b, 3)"
            },
            {
                id: "elicitingQuestion",
                valueType: "string",
                valueOptions: "/project/project_elicitingQuestionsList",
                valueOptionsSubfield: "elicitingQuestion_shortName",
                displayType: "select",
                displayName: "Question choice",
                displayPrompt: "Choose a story-eliciting question."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_chooseStoryQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_chooseStoryQuestion",
        modelClass: "StoryQuestionChoice",
        panelFields: [
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayName: "Order",
                displayPrompt: "Specify the order to ask this story question (e.g. 1, 2a, 2b, 3)"
            },
            {
                id: "storyQuestion",
                valueType: "string",
                valueOptions: "/project/project_storyQuestionsList",
                valueOptionsSubfield: "storyQuestion_shortName",
                displayType: "select",
                displayName: "Question choice",
                displayPrompt: "Choose a story question."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_chooseParticipantQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_chooseParticipantQuestion",
        modelClass: "ParticipantQuestionChoice",
        panelFields: [
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayName: "Order",
                displayPrompt: "Specify the order to ask this participant question (e.g. 1, 2a, 2b, 3)"
            },
            {
                id: "participantQuestion",
                valueType: "string",
                valueOptions: "/project/project_participantQuestionsList",
                valueOptionsSubfield: "participantQuestion_shortName",
                displayType: "select",
                displayName: "Question choice",
                displayPrompt: "Choose a participant question."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addStoryCollection',["require", "exports", "../../surveyCollection"], function (require, exports, surveyCollection) {
    "use strict";
    var panel = {
        id: "panel_addStoryCollection",
        modelClass: "StoryCollection",
        panelFields: [
            {
                id: "storyCollection_note",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                The story collection is only created when you click the <strong>Close</strong> button.\n                If you forget to click the Close button when you create the story collection, \n                you can come back to this panel, set the story form, and click the \"Update Story Form\" button.\n            "
            },
            {
                id: "storyCollection_shortName",
                valueType: "string",
                // valueImmutable: true,
                displayType: "text",
                displayName: "Story collection name",
                displayPrompt: "\n                Please give this story collection a short <strong>name</strong>, so we can refer to it.<br><br>\n                <span.narrafirma-special-warning>This name should not be changed after you start using the story collection.\n                Also, the name should be unique within the project.</span>\n            "
            },
            {
                id: "storyCollection_questionnaireIdentifier",
                valueType: "string",
                // valueImmutable: true,
                valueOptions: "/project/project_storyForms",
                valueOptionsSubfield: "questionForm_shortName",
                displayType: "select",
                displayName: "Story form",
                displayPrompt: "\n                Please select a <strong>story form</strong> to use for this story collection.<br><br>\n                <span.narrafirma-special-warning>The first time you choose a story form here and click the Close button,\n                a <strong>copy</strong> of the story form, <em>as it is at that moment</em>, will be placed into the new story collection.\n                Any changes you make to the story form afterwards will <em>not</em> be automatically reflected in the copy stored in the story collection.\n                To start using new changes to a story form (like during testing), press the \"Update Story Form button\" below.\n                However, it is not recommended to update a story form after data collection has begun (except perhaps for minor typographical errors).\n                Also, you should not change which form is used in an existing story collection.\n                To use a different or significantly revised story form after story collection has begun, create a new story collection.</span>\n            "
            },
            {
                id: "storyCollection_updateStoryForm",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "updateQuestionnaireForStoryCollection",
                displayPrompt: "Update Story Form (see caution above)"
            },
            {
                id: "storyCollection_activeOnWeb",
                valueType: "boolean",
                displayType: "checkbox",
                displayReadOnly: true,
                displayName: "Active on web?",
                displayPrompt: "If this survey is currently <strong>active</strong> on the web server, this check box will be checked."
            },
            {
                id: "storyCollection_webFormAddress",
                valueType: "none",
                displayType: "questionAnswer",
                displayName: "Web form address",
                displayPrompt: "The <strong>web address</strong> (URL) of this story collection is:",
                displayConfiguration: "storyCollection_activeOnWeb",
                displayTransformValue: function (value, model) {
                    if (!value)
                        return "";
                    return surveyCollection.urlForSurvey(model);
                }
            },
            {
                id: "storyCollection_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "You can enter <strong>notes</strong> on the story collection here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addAnnotationQuestion',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addAnnotationQuestion",
        modelClass: "AnnotationQuestion",
        panelFields: [
            {
                id: "annotationQuestion_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Question",
                displayPrompt: "Enter a <strong>question</strong> you will use to annotate stories after they have been collected."
            },
            {
                id: "annotationQuestion_type",
                valueType: "string",
                valueOptions: [
                    "boolean",
                    "label",
                    "header",
                    "checkbox",
                    "checkboxes",
                    "text",
                    "textarea",
                    "select",
                    "radiobuttons",
                    "slider"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of question is this?"
            },
            {
                id: "annotationQuestion_shortName",
                valueType: "string",
                displayType: "text",
                displayName: "Short name",
                displayPrompt: "Please enter a <strong>short name</strong> we can use to refer to the question. (It must be unique within the project.)"
            },
            {
                id: "annotationQuestion_options",
                valueType: "string",
                displayType: "textarea",
                displayName: "Options",
                displayPrompt: "If your question requires <strong>choices</strong>, enter them here (one per line). For a slider, enter the texts to place on the left and right sides (on separate lines)."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_addCollectionSessionRecord',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addCollectionSessionRecord",
        modelClass: "CollectionSessionRecord",
        panelFields: [
            {
                id: "collectionSessionRecord_name",
                valueType: "string",
                displayType: "text",
                displayName: "Collection session record name",
                displayPrompt: "Please give this session record a <strong>name</strong>."
            },
            {
                id: "collectionSessionRecord_whenWhere",
                valueType: "string",
                displayType: "textarea",
                displayName: "When and where",
                displayPrompt: "<strong>When and where</strong> did the session take place?"
            },
            {
                id: "collectionSessionRecord_groups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>groups</strong> were involved in this session?"
            },
            {
                id: "collectionSessionRecord_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Who attended",
                displayPrompt: "Describe the <strong>participants</strong> at this session."
            },
            {
                id: "collectionSessionRecord_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Which of your collection session <strong>plans</strong> did you follow in this session? (And did you stick to the plan?)"
            },
            {
                id: "collectionSessionRecord_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter additional <strong>notes</strong> on the session here. Your notes can include links to images or other documents."
            },
            {
                id: "collectionSessionRecord_constructionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_newCollectionSessionConstruction",
                displayName: "Story collection session constructions",
                displayPrompt: "People in your story collection sessions might have created <strong>constructions</strong> such as timelines or landscapes. You can enter details about those here."
            },
            {
                id: "collectionSessionRecord_reflectionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use the questions below to <strong>reflect</strong> on the session."
            },
            {
                id: "collectionSessionRecord_reflectionsOnChangeHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Change"
            },
            {
                id: "collectionSessionRecord_reflections_change_participantPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in participant perceptions",
                displayPrompt: "How did the perceptions of the <strong>participants</strong> change from the start to the end of the session?"
            },
            {
                id: "collectionSessionRecord_reflections_change_yourPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in facilitator perceptions",
                displayPrompt: "How did <strong>your</strong> perceptions change?"
            },
            {
                id: "collectionSessionRecord_reflections_change_project",
                valueType: "string",
                displayType: "textarea",
                displayName: "Changes to the project",
                displayPrompt: "How has the overall <strong>project</strong> changed as a result of this session?"
            },
            {
                id: "collectionSessionRecord_interactionsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Interactions"
            },
            {
                id: "collectionSessionRecord_reflections_interaction_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions among participants",
                displayPrompt: "Describe the interactions <strong>among participants</strong> in this session."
            },
            {
                id: "collectionSessionRecord_reflections_interaction_participantsAndFacilitator",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions between participants and facilitators",
                displayPrompt: "Describe the interactions <strong>between participants and facilitators</strong>."
            },
            {
                id: "collectionSessionRecord_reflections_interaction_stories",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories",
                displayPrompt: "What did you notice about the <strong>stories</strong> people told, retold, chose, and worked with during the session?"
            },
            {
                id: "collectionSessionRecord_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "collectionSessionRecord_reflections_learning_special",
                valueType: "string",
                displayType: "textarea",
                displayName: "Unique features",
                displayPrompt: "What was <strong>special</strong> about these people, in this place, on this day?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprise",
                displayPrompt: "What <strong>surprised</strong> you about this session?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_workedWell",
                valueType: "string",
                displayType: "textarea",
                displayName: "Worked and didn't work",
                displayPrompt: "Which parts of your <strong>plans</strong> for this session worked out well? Which parts didn't?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "What <strong>new ideas</strong> did you gain from this session? What did you <strong>learn</strong> from it?"
            },
            {
                id: "collectionSessionRecord_reflections_learning_wantToRemember",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "<strong>What else</strong> do you want to remember about this session?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/collection/panel_newCollectionSessionConstruction',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_newCollectionSessionConstruction",
        modelClass: "CollectionSessionConstruction",
        panelFields: [
            {
                id: "collectionSessionRecord_construction_name",
                valueType: "string",
                displayType: "text",
                displayName: "Collection construction name",
                displayPrompt: "Please give this construction a <strong>name</strong>."
            },
            {
                id: "collectionSessionRecord_construction_type",
                valueType: "string",
                valueOptions: [
                    "timeline",
                    "landscape",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of construction is it?"
            },
            {
                id: "collectionSessionRecord_construction_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> the construction (or include a description given by participants). Your description can include links to images or other documents."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_catalysis',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_catalysis",
        displayName: "Catalysis",
        panelFields: [
            {
                id: "catalysisIntro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In the catalysis phase of your PNI project, you will look for <strong>patterns</strong>\nin the stories people told and in their answers to questions. You will build on these\npatterns by adding <strong>observations</strong>, <strong>interpretations</strong> and <strong>ideas</strong> that will \ncatalyze thought and discussion\nduring the sensemaking phase of your project."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_startCatalysisReport',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_startCatalysisReport",
        displayName: "Start catalysis report",
        tooltipText: "Create a place to store your catalysis report.",
        headerAbove: "Get Started",
        panelFields: [
            {
                id: "catalysis_createCatalysisReportLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can create one or more catalysis reports: sets of <strong>observations</strong> and <strong>interpretations</strong> based on <strong>patterns</strong> you find in one or more story collections.<br><br>Note: You should only create a catalysis report when your story collection is complete. Otherwise, the report may be incorrect or incomplete (because new data might change the patterns you see)."
            },
            {
                id: "project_catalysisReports",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addCatalysisReport",
                    gridConfiguration: {
                        viewButton: true,
                        editButton: true,
                        addButton: true,
                        removeButton: true,
                        columnsToDisplay: ["catalysisReport_shortName", "catalysisReport_notes"]
                    }
                },
                displayName: "Catalysis reports",
                displayPrompt: "These are the catalysis reports you have created so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_configureCatalysisReport',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    var panel = {
        id: "page_configureCatalysisReport",
        displayName: "Configure Catalysis Report",
        tooltipText: "Decide what questions you want to consider as you build your catalysis report.",
        panelFields: [
            {
                id: "configureCatalysisReport_label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                On this page you can choose the <strong>questions</strong> you want to explore in your catalysis report.\n                You can also specify a threshold for statistical tests.\n            "
            },
            {
                id: "configureCatalysisReport_chooseReport",
                valuePath: "/clientState/catalysisReportName",
                valueType: "string",
                valueOptions: "project_catalysisReports",
                valueOptionsSubfield: "catalysisReport_shortName",
                displayType: "select",
                displayName: "Catalysis report",
                displayPrompt: "Choose a catalysis report to work on."
            },
            {
                id: "configureCatalysisReport_promptToSelectCatalysisReportForInterpretations",
                valueType: "none",
                displayType: "label",
                displayPrompt: "<strong>Please select a catalysis report above to get a list of questions here.</strong>",
                displayVisible: function (panelBuilder, model) {
                    return !Globals.clientState().catalysisReportName();
                }
            },
            {
                id: "configureCatalysisReport_minimumSubsetSize",
                valuePath: "/clientState/catalysisReportIdentifier/minimumSubsetSize",
                valueType: "string",
                valueOptions: [
                    "0",
                    "5",
                    "10",
                    "15",
                    "20",
                    "25",
                    "30",
                    "35",
                    "40",
                    "45",
                    "50"
                ],
                displayType: "select",
                displayName: "Minimum subset size",
                displayPrompt: "How large should subsets of stories be to be considered for statistical tests?",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportName();
                }
            },
            {
                id: "configureCatalysisReport_chooseQuestions",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/questionsToInclude",
                displayType: "catalysisReportQuestionChooser",
                displayPrompt: "Choose questions to include in the catalysis report",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportName();
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_explorePatterns',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_explorePatterns",
        displayName: "Explore patterns",
        tooltipText: "Look at graphs of your data, discover useful patterns, and write observations and interpretations about them.",
        headerAbove: "Work Through Your Data",
        panelFields: [
            {
                id: "explorePatternsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n            On this page you will explore <strong>patterns</strong> in the data you \n            collected, make <strong>observations</strong> on the patterns,\n            and <strong>interpret</strong> the observations. The\n            <strong>catalysis report</strong> you build here can help other people \n            make sense of what the story collection has to say.\n            "
            },
            {
                id: "catalysisReportExplorePatterns",
                valuePath: "/clientState/catalysisReportName",
                valueType: "string",
                valueOptions: "project_catalysisReports",
                valueOptionsSubfield: "catalysisReport_shortName",
                displayType: "select",
                displayName: "Catalysis report",
                displayPrompt: "Choose a catalysis report to work on."
            },
            {
                id: "explorePatterns_display",
                valuePath: "/clientState/catalysisReportName",
                valueType: "none",
                displayType: "patternExplorer",
                displayPrompt: ""
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_clusterInterpretations',["require", "exports", "../../Globals"], function (require, exports, Globals) {
    "use strict";
    var panel = {
        id: "page_clusterInterpretations",
        displayName: "Cluster interpretations",
        tooltipText: "Draw your interpretations together into clusters that make them more accessible during sensemaking.",
        panelFields: [
            {
                id: "project_interpretationsClusteringLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you will draw together the interpretations you have collected (on the previous page) into <strong>perspectives</strong> that will become the headings of your catalysis report.<br><br>Note: Do not cluster your interpretations until you are sure you have finished collecting them."
            },
            {
                id: "catalysisReportClusterInterpretations",
                valuePath: "/clientState/catalysisReportName",
                valueType: "string",
                valueOptions: "project_catalysisReports",
                valueOptionsSubfield: "catalysisReport_shortName",
                displayType: "select",
                displayName: "Catalysis report",
                displayPrompt: "Choose a catalysis report to work on."
            },
            {
                id: "promptToSelectCatalysisReportForInterpretations",
                valueType: "none",
                displayType: "label",
                displayPrompt: "<strong>Please select a catalysis report above to get a clustering diagram here.</strong>",
                displayVisible: function (panelBuilder, model) {
                    return !Globals.clientState().catalysisReportName();
                }
            },
            {
                id: "copyInterpretationsButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "copyInterpretationsToClusteringDiagram",
                displayPrompt: "Copy interpretations to clustering diagram",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportName();
                }
            },
            {
                id: "interpretationsClusteringDiagram",
                valueType: "object",
                valuePath: "/clientState/catalysisReportIdentifier/interpretationsClusteringDiagram",
                displayType: "clusteringDiagram",
                displayPrompt: "Place similar interpretations together. Then name and describe each cluster of interpretations. Those clusters, or <strong>perspectives</strong>, will become the headings of your catalysis report.",
                displayVisible: function (panelBuilder, model) {
                    return !!Globals.clientState().catalysisReportName();
                }
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/page_printCatalysisReport',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_printCatalysisReport",
        displayName: "Print catalysis report",
        tooltipText: "Export the graphs you've selected, and the observations and interpretations you've written, to use in a sensemaking session.",
        headerAbove: "Wrap Up Catalysis",
        panelFields: [
            {
                id: "catalysisReportPrint_label",
                valueType: "none",
                displayType: "label",
                displayPrompt: "\n                On this page you can <strong>export</strong> your catalysis report. You will probably want to format it in your word processor.\n                If you're having trouble reading the generated HTML file in your word processor, click the Help button\n                for some options.\n                "
            },
            {
                id: "catalysisReportPrint_selected",
                valuePath: "/clientState/catalysisReportName",
                valueType: "string",
                valueOptions: "project_catalysisReports",
                valueOptionsSubfield: "catalysisReport_shortName",
                displayType: "select",
                displayName: "Catalysis report",
                displayPrompt: "Choose a catalysis report to print"
            },
            {
                id: "catalysisReportPrint_printButton",
                valuePath: "/clientState/catalysisReportName",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Print selected catalysis report",
                displayConfiguration: "printCatalysisReport"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/panel_addCatalysisReport',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addCatalysisReport",
        modelClass: "CatalysisReport",
        panelFields: [
            {
                id: "catalysisReport_shortName",
                valueType: "string",
                displayType: "text",
                displayName: "Catalysis report name",
                displayPrompt: "Please give this catalysis report a short <strong>name</strong>."
            },
            {
                id: "catalysisReport_storyCollections",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_chooseStoryCollection",
                    gridConfiguration: {
                        viewButton: true,
                        editButton: true,
                        addButton: true,
                        removeButton: true
                    }
                },
                displayName: "Story collections",
                displayPrompt: "Add one or more <strong>story collections</strong> to this catalysis report."
            },
            {
                id: "catalysisReport_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "You can enter <strong>notes</strong> on the catalysis report here. They will appear at the start of your printed report."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/panel_chooseStoryCollection',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_chooseStoryCollection",
        modelClass: "StoryCollectionChoice",
        panelFields: [
            {
                id: "storyCollection",
                valueType: "string",
                valueOptions: "/project/project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose a story collection."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/catalysis/panel_addInterpretation',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addInterpretation",
        modelClass: "Interpretation",
        panelFields: [
            {
                id: "interpretation_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> this interpretation. What does the pattern mean, from this perspective?"
            },
            {
                id: "interpretation_name",
                valueType: "string",
                displayType: "text",
                displayName: "Name",
                displayPrompt: "Please give this interpretation a <strong>name</strong>."
            },
            {
                id: "interpretation_idea",
                valueType: "string",
                displayType: "textarea",
                displayName: "Idea",
                displayPrompt: "If you like, you can record an <strong>idea</strong> that follows from this interpretation."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_sensemaking',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_sensemaking",
        displayName: "Sensemaking",
        panelFields: [
            {
                id: "sensemakingIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In the sensemaking phase of your PNI project, you will plan <strong>sensemaking sessions</strong>, \nduring which people will make use of your collected <strong>stories and patterns</strong> to think together \nabout the topic of your project. Afterward, you can record what happened in your \nsensemaking sessions."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_printStoryCards',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_printStoryCards",
        displayName: "Print story cards",
        tooltipText: "Print out the stories you collected so people can use them during sensemaking sessions.",
        headerAbove: "Get Ready for Sensemaking",
        panelFields: [
            {
                id: "printStoryCards_introduction",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can print or export <strong>story cards</strong>, printed versions \n                of stories that people can arrange and compare as they \n                encounter stories and work on sensemaking exercises.\n                "
            },
            {
                id: "storyCollectionChoice_printing",
                valuePath: "/clientState/storyCollectionName",
                valueType: "string",
                valueOptions: "project_storyCollections",
                valueOptionsSubfield: "storyCollection_shortName",
                displayType: "select",
                displayName: "Story collection",
                displayPrompt: "Choose the <strong>story collection</strong> whose story cards you want to print."
            },
            {
                id: "printStoryCards_output",
                valueType: "none",
                displayType: "label",
                displayPrompt: ""
            },
            {
                id: "printStoryCards_printFormButton",
                valueType: "none",
                displayType: "button",
                displayConfiguration: "printStoryCards",
                displayPrompt: "Print Story Cards"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_planSensemakingSessions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_planSensemakingSessions",
        displayName: "Plan sensemaking sessions",
        tooltipText: "Create an agenda you will use as people read, talk about, and work with the stories you collected.",
        panelFields: [
            {
                id: "project_sensemakingSessionPlansLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can create <strong>plans</strong> for your sensemaking sessions. After a plan is complete, you can print a session agenda and use it to remember what you plan to do, and to coordinate your facilitation with any helpers you might have."
            },
            {
                id: "sensemakingSessionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayConfiguration: "sessions",
                displayPrompt: "Recommendations for sensemaking sessions"
            },
            {
                id: "project_sensemakingSessionPlansList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addSensemakingSessionPlan",
                displayName: "Sensemaking session plans",
                displayPrompt: "These are the session plans you have created so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/page_enterSensemakingSessionRecords',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_enterSensemakingSessionRecords",
        displayName: "Enter sensemaking session records",
        tooltipText: "Reflect on your sensemaking sessions to capture what happened and what you learned.",
        headerAbove: "Think About What Happened",
        panelFields: [
            {
                id: "project_sensemakingSessionRecordsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can enter <strong>records</strong> of what happened during your sensemaking sessions."
            },
            {
                id: "project_sensemakingSessionRecordsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addSensemakingSessionRecord",
                displayName: "Sensemaking session records",
                displayPrompt: "These are the session records you have created so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addSensemakingSessionPlan',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addSensemakingSessionPlan",
        modelClass: "SensemakingSessionPlan",
        panelFields: [
            {
                id: "sensemakingSessionPlan_name",
                valueType: "string",
                displayType: "text",
                displayName: "Sensemaking session plan name",
                displayPrompt: "Please give this session plan a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionPlan_groups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>group</strong> (or groups) will be involved?"
            },
            {
                id: "sensemakingSessionPlan_participantGroupsMixing",
                valueType: "string",
                displayType: "textarea",
                displayName: "Mixing",
                displayPrompt: "What are your plans for keeping participant groups <strong>together or apart</strong>?"
            },
            {
                id: "sensemakingSessionPlan_repetitions",
                valueType: "string",
                displayType: "text",
                displayName: "Repetitions",
                displayPrompt: "How many <strong>repetitions</strong> of the session will there be?"
            },
            {
                id: "sensemakingSessionPlan_duration",
                valueType: "string",
                displayType: "text",
                displayName: "Length",
                displayPrompt: "<strong>How long</strong> will this session last?"
            },
            {
                id: "sensemakingSessionPlan_times",
                valueType: "string",
                displayType: "text",
                displayName: "Time",
                displayPrompt: "<strong>When</strong> will the sessions take place?"
            },
            {
                id: "sensemakingSessionPlan_location",
                valueType: "string",
                displayType: "text",
                displayName: "Location",
                displayPrompt: "<strong>Where</strong> will these sessions take place?"
            },
            {
                id: "sensemakingSessionPlan_numPeople",
                valueType: "string",
                displayType: "textarea",
                displayName: "Number of people",
                displayPrompt: "<strong>How many people</strong> will be invited to each repetition of this session?"
            },
            {
                id: "sensemakingSessionPlan_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What <strong>materials</strong> will this session plan require?"
            },
            {
                id: "sensemakingSessionPlan_smallGroups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Groups",
                displayPrompt: "What sorts of <strong>small groups</strong> will be formed in this session?"
            },
            {
                id: "sensemakingSessionPlan_details",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "Enter other <strong>details</strong> about this session."
            },
            {
                id: "sensemakingSessionPlan_activitiesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addSensemakingSessionActivity",
                displayName: "Sensemaking session activities",
                displayPrompt: "Here you can enter some <strong>activities</strong> you plan to use in the session. Activities can be simple instructions or complicated exercises (like the creation of timelines)."
            },
            {
                id: "sensemakingSessionPlan_printSensemakingSessionAgendaButton",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Export session agenda",
                displayConfiguration: "printSensemakingSessionAgenda"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addSensemakingSessionActivity',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addSensemakingSessionActivity",
        modelClass: "SensemakingSessionActivityPlan",
        panelFields: [
            {
                id: "order",
                valueType: "string",
                displayType: "text",
                displayName: "Order",
                displayPrompt: "Specify the order in which to do this sensemaking activity (e.g. 1, 2a, 2b, 3)"
            },
            {
                id: "sensemakingSessionPlan_activity_name",
                valueType: "string",
                displayType: "text",
                displayName: "Name",
                displayPrompt: "Please give this activity a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionPlan_activity_duration",
                valueType: "string",
                displayType: "text",
                displayName: "Length",
                displayPrompt: "<strong>How long</strong> will this activity take?"
            },
            {
                id: "sensemakingSessionPlan_activity_type",
                valueType: "string",
                valueOptions: [
                    "ice-breaker",
                    "encountering stories (no task)",
                    "encountering stories (simple task)",
                    "discussing stories",
                    "encountering patterns (no task)",
                    "encountering patterns (simple task)",
                    "discussing patterns",
                    "twice-told stories exercise",
                    "timeline exercise",
                    "landscape exercise",
                    "story elements exercise",
                    "composite stories exercise",
                    "my own exercise",
                    "break",
                    "wrap-up",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of activity is this?"
            },
            {
                id: "sensemakingSessionPlan_activity_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Describe the <strong>plan</strong> for this activity."
            },
            {
                id: "sensemakingSessionPlan_activity_optionalParts",
                valueType: "string",
                displayType: "textarea",
                displayName: "Optional elaborations",
                displayPrompt: "Describe any optional <strong>elaborations</strong> you might or might not use in this activity."
            },
            {
                id: "sensemakingSessionPlan_activity_recording",
                valueType: "string",
                displayType: "textarea",
                displayName: "New stories",
                displayPrompt: "Will new stories be <strong>recorded</strong> during this activity? If so, how?"
            },
            {
                id: "sensemakingSessionPlan_activity_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What materials (including catalytic materials, e.g., graphs and story cards) will this session plan require?"
            },
            {
                id: "sensemakingSessionPlan_activity_spaces",
                valueType: "string",
                displayType: "textarea",
                displayName: "Spaces",
                displayPrompt: "What <strong>spaces</strong> will be used for this activity?"
            },
            {
                id: "sensemakingSessionPlan_activity_facilitation",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation",
                displayPrompt: "What sort of <strong>facilitation</strong> will be necessary for this activity?"
            },
            {
                id: "sensemakingSessionActivity_helping",
                valueType: "string",
                displayType: "textarea",
                displayName: "Help",
                displayPrompt: "What will <strong>helpers</strong> do during this activity?"
            },
            {
                id: "templates_sensemakingActivities",
                valueType: "none",
                displayType: "templateList",
                displayConfiguration: "sensemakingActivities",
                displayPrompt: "Copy activity from template"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addSensemakingSessionRecord',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addSensemakingSessionRecord",
        modelClass: "SensemakingSessionRecord",
        panelFields: [
            {
                id: "sensemakingSessionRecord_name",
                valueType: "string",
                displayType: "text",
                displayName: "Sensemaking session record name",
                displayPrompt: "Please give this session record a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionRecord_whenWhere",
                valueType: "string",
                displayType: "textarea",
                displayName: "When and where",
                displayPrompt: "<strong>When and where</strong> did this session take place?"
            },
            {
                id: "sensemakingSessionRecord_groups",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>group</strong> (or groups) attended the session?"
            },
            {
                id: "sensemakingSessionRecord_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Who attended",
                displayPrompt: "Describe the <strong>participants</strong> at this session."
            },
            {
                id: "sensemakingSessionRecord_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Which of your sensemaking <strong>plans</strong> did you follow in this session? (And did you stick to the plan?)"
            },
            {
                id: "sensemakingSessionRecord_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Here you can enter general <strong>notes</strong> on the session. Your notes can include links to images or other documents."
            },
            {
                id: "sensemakingSessionRecord_resonantStoriesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addResonantStory",
                displayName: "Sensemaking session resonant stories",
                displayPrompt: "If you discovered any <strong>resonant stories</strong> (pivot, voice, discovery) in this session, you can enter them here."
            },
            {
                id: "sensemakingSessionRecord_resonantPatternsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addResonantPattern",
                displayName: "Sensemaking session resonant patterns",
                displayPrompt: "If you discovered any <strong>resonant patterns</strong> (pivot, voice, discovery) in this session, you can enter them here."
            },
            {
                id: "sensemakingSessionRecord_outcomesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_newSensemakingSessionOutcome",
                displayName: "Sensemaking session outcomes",
                displayPrompt: "If your session ended with creating lists of <strong>outcomes</strong> (like discoveries and ideas), you can enter them here."
            },
            {
                id: "sensemakingSessionRecord_constructionsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_newSensemakingSessionConstruction",
                displayName: "Sensemaking session constructions",
                displayPrompt: "If your session involve creating any group <strong>constructions</strong> (like landscapes or timelines), you can describe them here."
            },
            {
                id: "sensemakingSessionRecord_reflectionsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use the questions below to <strong>reflect</strong> on the session."
            },
            {
                id: "sensemakingSessionRecord_reflectionsOnChangeHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Change"
            },
            {
                id: "sensemakingSessionRecord_reflections_change_participantPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in participant perceptions",
                displayPrompt: "How did the perceptions of the <strong>participants</strong> change from the start to the end of the session?"
            },
            {
                id: "sensemakingSessionRecord_reflections_change_yourPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in facilitator perceptions",
                displayPrompt: "How did <strong>your</strong> perceptions change?"
            },
            {
                id: "sensemakingSessionRecord_reflections_change_project",
                valueType: "string",
                displayType: "textarea",
                displayName: "Changes to the project",
                displayPrompt: "How has the overall <strong>project</strong> changed as a result of this session?"
            },
            {
                id: "sensemakingSessionRecord_interactionsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Interactions"
            },
            {
                id: "sensemakingSessionRecord_reflections_interaction_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions among participants",
                displayPrompt: "Describe the interactions <strong>among participants</strong> in this session."
            },
            {
                id: "sensemakingSessionRecord_reflections_interaction_participantsAndFacilitator",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions between participants and facilitators",
                displayPrompt: "Describe the interactions <strong>between participants and facilitators</strong>."
            },
            {
                id: "sensemakingSessionRecord_reflections_interaction_stories",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories",
                displayPrompt: "What did you notice about the <strong>stories</strong> people told, retold, chose, and worked with during the session?"
            },
            {
                id: "sensemakingSessionRecord_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_special",
                valueType: "string",
                displayType: "textarea",
                displayName: "Unique features",
                displayPrompt: "What was <strong>special</strong> about these people in this place on this day?"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprise",
                displayPrompt: "What <strong>surprised</strong> you about this session?"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_workedWell",
                valueType: "string",
                displayType: "textarea",
                displayName: "Worked and didn't work",
                displayPrompt: "Which parts of your <strong>plans</strong> for this session worked out well? Which parts didn't?"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "What <strong>new ideas</strong> did you gain from this session? What did you <strong>learn</strong> from it?"
            },
            {
                id: "sensemakingSessionRecord_reflections_learning_wantToRemember",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "<strong>What else</strong> do you want to remember about this session?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addResonantStory',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addResonantStory",
        modelClass: "ResonantStory",
        panelFields: [
            {
                id: "sensemakingSessionRecord_resonantStory_name",
                valueType: "string",
                displayType: "text",
                displayName: "Resonant story name",
                displayPrompt: "What is the <strong>name</strong> of the resonant story?"
            },
            {
                id: "sensemakingSessionRecord_resonantStory_type",
                valueType: "string",
                valueOptions: [
                    "pivot",
                    "voice",
                    "discovery",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "Which <strong>type</strong> of resonant story is this?"
            },
            {
                id: "sensemakingSessionRecord_resonantStory_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Story text",
                displayPrompt: "You can type (or paste) the story <strong>text</strong> (or summary) here."
            },
            {
                id: "sensemakingSessionRecord_resonantStory_reason",
                valueType: "string",
                displayType: "textarea",
                displayName: "Why",
                displayPrompt: "Why did this story <strong>stand out</strong>?"
            },
            {
                id: "sensemakingSessionRecord_resonantStory_peopleSaid",
                valueType: "string",
                displayType: "textarea",
                displayName: "People said",
                displayPrompt: "What did people <strong>say</strong> about this story?"
            },
            {
                id: "sensemakingSessionRecord_resonantStory_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "You can enter any other <strong>notes</strong> about this story here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_addResonantPattern',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addResonantPattern",
        modelClass: "ResonantPattern",
        panelFields: [
            {
                id: "sensemakingSessionRecord_resonantPattern_name",
                valueType: "string",
                displayType: "text",
                displayName: "Why",
                displayPrompt: "Please give this resonant pattern a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_type",
                valueType: "string",
                valueOptions: [
                    "pivot",
                    "voice",
                    "discovery",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "Which <strong>type</strong> of resonant pattern is this?"
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> the pattern."
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_reason",
                valueType: "string",
                displayType: "textarea",
                displayName: "Why",
                displayPrompt: "Why did this pattern <strong>stand out</strong>?"
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_peopleSaid",
                valueType: "string",
                displayType: "textarea",
                displayName: "People said",
                displayPrompt: "What did people <strong>say</strong> about this pattern?"
            },
            {
                id: "sensemakingSessionRecord_resonantPattern_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "You can enter any other <strong>notes</strong> about this pattern here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_newSensemakingSessionOutcome',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_newSensemakingSessionOutcome",
        modelClass: "SensemakingSessionOutcome",
        panelFields: [
            {
                id: "sensemakingSessionRecord_outcome_name",
                valueType: "string",
                displayType: "text",
                displayName: "Name",
                displayPrompt: "Please give this outcome a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionRecord_outcome_type",
                valueType: "string",
                valueOptions: [
                    "discovery",
                    "opportunity",
                    "issue",
                    "idea",
                    "recommendation",
                    "perspective",
                    "dilemma",
                    "discussion",
                    "priority",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of session outcome is this?"
            },
            {
                id: "sensemakingSessionRecord_outcome_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "<strong>Describe</strong> the outcome."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/sensemaking/panel_newSensemakingSessionConstruction',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_newSensemakingSessionConstruction",
        modelClass: "SensemakingSessionConstruction",
        panelFields: [
            {
                id: "sensemakingSessionRecord_construction_name",
                valueType: "string",
                displayType: "text",
                displayName: "Sensemaking construction name",
                displayPrompt: "Please give this construction a <strong>name</strong>."
            },
            {
                id: "sensemakingSessionRecord_construction_type",
                valueType: "string",
                valueOptions: [
                    "timeline",
                    "landscape",
                    "story elements",
                    "composite story",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of construction is it?"
            },
            {
                id: "sensemakingSessionRecord_construction_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> the construction (or include a description given by participants). Your description can include links to images or documents."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_intervention',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_intervention",
        displayName: "Intervention",
        panelFields: [
            {
                id: "interventionIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "A <strong>narrative intervention</strong> is something that changes the flow of stories in your community or organization.\nIn the intervention phase of your PNI project, you will describe your project <strong>outcomes</strong> \nso you can get recommendations for useful interventions (like story sharing spaces or narrative therapy). \nThen you might <strong>plan</strong> interventions \nand <strong>record</strong> what happened when you carried them out."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_projectOutcomesForIntervention',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectOutcomesForIntervention",
        displayName: "Answer questions about project outcomes",
        tooltipText: "Describe the project's outcomes (so far) so you can think about what interventions might be useful.",
        headerAbove: "Plan Interventions",
        panelFields: [
            {
                id: "project_outcomes_intro",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In order to choose interventions that will be useful in your project, it will be helpful to think about some of the <strong>outcomes</strong> of your project (so far). Please answer these questions in reference to the <strong>participant groups</strong> you set up in the project planning phase. Enter one set of outcomes for each participant group."
            },
            {
                id: "project_outcomesList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_projectOutcome",
                displayName: "Project outcomes",
                displayPrompt: "These are the participant groups for which you have entered outcomes so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_designInterventions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_designInterventions",
        displayName: "Design intervention plans",
        tooltipText: "Write out plans for interventions you want to carry out.",
        panelFields: [
            {
                id: "project_interventionLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can <strong>design plans</strong> for interventions that change the stories people tell in your community or organization."
            },
            {
                id: "interventionRecommendations",
                valueType: "none",
                displayType: "recommendationTable",
                displayConfiguration: "interventions",
                displayPrompt: "Recommendations for intervention plans"
            },
            {
                id: "project_interventionPlansList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addIntervention",
                displayName: "Intervention plans",
                displayPrompt: "These are the intervention plans you have created so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/page_recordInterventions',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_recordInterventions",
        displayName: "Enter intervention records",
        tooltipText: "Reflect on the interventions you carried out to capture what happened and what you learned.",
        headerAbove: "Think About What Happened",
        panelFields: [
            {
                id: "project_interventionRecordsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can enter <strong>records</strong> of the interventions you have carried out as part of your project."
            },
            {
                id: "project_interventionRecordsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addInterventionRecord",
                displayName: "Intervention records",
                displayPrompt: "These are the intervention records you have created so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/panel_projectOutcome',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_projectOutcome",
        displayName: "Project outcomes",
        modelClass: "ProjectOutcome",
        panelFields: [
            {
                id: "outcomes_group",
                valueType: "string",
                displayType: "text",
                displayName: "Participant group",
                displayPrompt: "Which participant <strong>group</strong> is this outcome for?"
            },
            {
                id: "outcomes_hopesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Hopes"
            },
            {
                id: "outcomes_peopleFeltHeard",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Felt heard",
                displayPrompt: "During your project, did the people in this group say they <strong>felt heard</strong> for the first time?"
            },
            {
                id: "outcomes_peopleFeltInvolved",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Felt involved",
                displayPrompt: "Did they say they <strong>felt involved</strong> for the first time?"
            },
            {
                id: "outcomes_peopleLearnedAboutCommOrg",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Learned about community",
                displayPrompt: "Did they say they <strong>learned about their community or organization</strong>?"
            },
            {
                id: "outcomes_voicesHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Voices"
            },
            {
                id: "outcomes_peopleWantedToTellMoreStories",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Wanted to tell more",
                displayPrompt: "During your story collection, did these people seem to want to <strong>tell more stories</strong> than you collected?"
            },
            {
                id: "outcomes_peopleWantedToShareMoreStoriesWithEachOther",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Wanted to share more",
                displayPrompt: "Did you ever feel that they wanted to <strong>share more experiences</strong> (with each other) than they did?"
            },
            {
                id: "outcomes_peopleFeltStoriesNeededToBeHeard",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Felt that stories needed to be heard",
                displayPrompt: "Did these people feel that some of the stories you collected <strong>needed to be heard</strong> by anyone?"
            },
            {
                id: "outcomes_peopleFeltNobodyCares",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Felt that nobody cares",
                displayPrompt: "Were there any issues that these people thought <strong>nobody cares</strong> about?"
            },
            {
                id: "outcomes_needsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Needs"
            },
            {
                id: "outcomes_peopleFeltNobodyCanMeetNeeds",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Needs could not be met",
                displayPrompt: "Do the people in this group have <strong>needs that nobody can meet</strong>?"
            },
            {
                id: "outcomes_peopleFeltTheyNeedNewStories",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Needed to tell themselves new stories",
                displayPrompt: "Do these people need to start <strong>telling themselves new stories</strong>?"
            },
            {
                id: "outcomes_peopleWantedToKeepExploring",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Wanted more exploration",
                displayPrompt: "Were there any issues about which the people in this group seemed to want to <strong>keep exploring</strong>?"
            },
            {
                id: "outcomes_crisisPointsWereFound",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Crisis points",
                displayPrompt: "Did you discover any <strong>crisis points</strong> where people in this group needed help and didn't get it?"
            },
            {
                id: "outcomes_issuesWereBeyondWords",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Beyond words",
                displayPrompt: "Did you find any issues for this group that were <strong>beyond words</strong>, that no amount of discussion could resolve?"
            },
            {
                id: "outcomes_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "outcomes_peopleLearnedAboutTopic",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Learned about topic",
                displayPrompt: "Did these people say that they <strong>learned about the topic</strong> by participating in the project?"
            },
            {
                id: "outcomes_issuesNewMembersStruggleWith",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "New members needed help",
                displayPrompt: "Did you notice that <strong>new members</strong> of the community or organization were having a harder time making sense of things?"
            },
            {
                id: "outcomes_foundInfoWithoutUnderstanding",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Had more information than understanding",
                displayPrompt: "Were there any issues that these people found <strong>difficult to understand</strong>, even though abundant information was available?"
            },
            {
                id: "outcomes_foundOverConfidence",
                valueType: "string",
                valueOptions: [
                    "not at all",
                    "somewhat",
                    "definitely",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Had more confidence than skill",
                displayPrompt: "Did you discover any areas in which these people had <strong>more confidence than skill</strong>?"
            },
            {
                id: "outcomes_peopleCuriousAboutStoryWork",
                valueType: "string",
                valueOptions: [
                    "never",
                    "occasionally",
                    "sometimes",
                    "often",
                    "mixed"
                ],
                displayType: "select",
                displayName: "Wanted to learn about story work",
                displayPrompt: "Did any of these participants express an interest in <strong>learning more about story work</strong>?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/panel_addIntervention',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addIntervention",
        displayName: "Plan an intervention",
        modelClass: "InterventionPlan",
        panelFields: [
            {
                id: "interventionPlan_name",
                valueType: "string",
                displayType: "text",
                displayName: "Intervention plan name",
                displayPrompt: "Please give this intervention plan a <strong>name</strong>."
            },
            {
                id: "interventionPlan_type",
                valueType: "string",
                valueOptions: [
                    "narrative ombudsman",
                    "narrative suggestion box",
                    "story sharing space",
                    "narrative orientation",
                    "narrative learning resource",
                    "narrative simulation",
                    "narrative presentation",
                    "dramatic action",
                    "sensemaking space",
                    "sensemaking pyramid",
                    "narrative mentoring program",
                    "narrative therapy",
                    "participatory theatre",
                    "mixed",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of intervention will this be?"
            },
            {
                id: "interventionPlan_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please describe your <strong>plan</strong> for this intervention."
            },
            {
                id: "interventionPlan_groups",
                valueType: "string",
                displayType: "text",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>group</strong> (or groups) will be involved?"
            },
            {
                id: "interventionPlan_howmany",
                valueType: "string",
                displayType: "text",
                displayName: "How many",
                displayPrompt: "<strong>How many</strong> people will be involved in this intervention?"
            },
            {
                id: "interventionPlan_times",
                valueType: "string",
                displayType: "text",
                displayName: "Time",
                displayPrompt: "<strong>When</strong> will the intervention take place?"
            },
            {
                id: "interventionPlan_locations",
                valueType: "string",
                displayType: "text",
                displayName: "Location",
                displayPrompt: "<strong>Where</strong> will the intervention take place?"
            },
            {
                id: "interventionPlan_help",
                valueType: "string",
                displayType: "textarea",
                displayName: "Help",
                displayPrompt: "What sort of <strong>help</strong> will you need to carry out this intervention?"
            },
            {
                id: "interventionPlan_permission",
                valueType: "string",
                displayType: "textarea",
                displayName: "Permission",
                displayPrompt: "Describe any <strong>permissions</strong> you will need to carry out this intervention."
            },
            {
                id: "interventionPlan_participation",
                valueType: "string",
                displayType: "textarea",
                displayName: "Participation",
                displayPrompt: "How will you <strong>recruit</strong> people to participate in this intervention?"
            },
            {
                id: "interventionPlan_materials",
                valueType: "string",
                displayType: "textarea",
                displayName: "Materials",
                displayPrompt: "What physical <strong>materials</strong> will you need?"
            },
            {
                id: "interventionPlan_space",
                valueType: "string",
                displayType: "textarea",
                displayName: "Spaces",
                displayPrompt: "What <strong>spaces</strong> will you use?"
            },
            {
                id: "interventionPlan_techResources",
                valueType: "string",
                displayType: "textarea",
                displayName: "Technology",
                displayPrompt: "What technological <strong>resources</strong> will you need?"
            },
            {
                id: "interventionPlan_recording",
                valueType: "string",
                displayType: "textarea",
                displayName: "Recording",
                displayPrompt: "How will you <strong>record</strong> the results of this intervention?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/intervention/panel_addInterventionRecord',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addInterventionRecord",
        displayName: "Add intervention record",
        modelClass: "InterventionRecord",
        panelFields: [
            {
                id: "interventionRecord_name",
                valueType: "string",
                displayType: "text",
                displayName: "Intervention record name",
                displayPrompt: "Please give this intervention record a <strong>name</strong>."
            },
            {
                id: "interventionRecord_groups",
                valueType: "string",
                displayType: "text",
                displayName: "Participant groups",
                displayPrompt: "Which participant <strong>group</strong> (or groups) were involved?"
            },
            {
                id: "interventionRecord_timeandplace",
                valueType: "string",
                displayType: "textarea",
                displayName: "When and where",
                displayPrompt: "<strong>When and where</strong> did the intervention take place?"
            },
            {
                id: "interventionRecord_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> what happened during the intervention, in general."
            },
            {
                id: "interventionRecord_plan",
                valueType: "string",
                displayType: "textarea",
                displayName: "Plan",
                displayPrompt: "Which of your intervention plans did you follow in this intervention? (And did you stick to the plan?)"
            },
            {
                id: "interventionRecord_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter additional <strong>notes</strong> on the intervention here. Your notes can include links to images or other documents."
            },
            {
                id: "interventionRecord_reflectLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use the questions below to <strong>reflect</strong> on the intervention."
            },
            {
                id: "interventionRecord_reflectionsOnChangeHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Change"
            },
            {
                id: "interventionRecord_reflections_change_participantPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in participant perceptions",
                displayPrompt: "How did the perceptions of the <strong>participants</strong> change from the start to the end of the intervention?"
            },
            {
                id: "interventionRecord_reflections_change_yourPerceptions",
                valueType: "string",
                displayType: "textarea",
                displayName: "Change in facilitator perceptions",
                displayPrompt: "How did <strong>your</strong> perceptions change?"
            },
            {
                id: "interventionRecord_reflections_change_project",
                valueType: "string",
                displayType: "textarea",
                displayName: "Changes to the project",
                displayPrompt: "How has the overall <strong>project</strong> changed as a result of this intervention?"
            },
            {
                id: "interventionRecord_interactionsHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Interactions"
            },
            {
                id: "interventionRecord_reflections_interaction_participants",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions among participants",
                displayPrompt: "Describe the interactions <strong>among participants</strong> in this intervention."
            },
            {
                id: "interventionRecord_reflections_interaction_participantsAndFacilitator",
                valueType: "string",
                displayType: "textarea",
                displayName: "Interactions between participants and facilitators",
                displayPrompt: "Describe the interactions <strong>between participants and facilitators</strong>."
            },
            {
                id: "interventionRecord_reflections_interaction_stories",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories",
                displayPrompt: "What did you notice about the <strong>stories</strong> people told, retold, chose, and worked with during the intervention?"
            },
            {
                id: "interventionRecord_learningHeader",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Learning"
            },
            {
                id: "interventionRecord_reflections_learning_special",
                valueType: "string",
                displayType: "textarea",
                displayName: "Unique features",
                displayPrompt: "What was <strong>special</strong> about this intervention?"
            },
            {
                id: "interventionRecord_reflections_learning_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Surprise",
                displayPrompt: "What <strong>surprised</strong> you about this intervention?"
            },
            {
                id: "interventionRecord_reflections_learning_workedWell",
                valueType: "string",
                displayType: "textarea",
                displayName: "Worked and didn't work",
                displayPrompt: "Which parts of your <strong>plans</strong> for this intervention worked out well? Which parts didn't?"
            },
            {
                id: "interventionRecord_reflections_learning_newIdeas",
                valueType: "string",
                displayType: "textarea",
                displayName: "New ideas",
                displayPrompt: "What <strong>new ideas</strong> did you gain from this intervention? What did you <strong>learn</strong> from it?"
            },
            {
                id: "interventionRecord_reflections_learning_wantToRemember",
                valueType: "string",
                displayType: "textarea",
                displayName: "Other",
                displayPrompt: "<strong>What else</strong> do you want to remember about this intervention?"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_return',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_return",
        displayName: "Return",
        panelFields: [
            {
                id: "returnIntroLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "In the return phase of your PNI project, you will support the return of stories to your community or organization. \nYou will gather <strong>feedback</strong>, <strong>reflect</strong> on the project, perhaps make \na <strong>presentation</strong> about the project, and help people with <strong>requests</strong> about the project."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_gatherFeedback',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_gatherFeedback",
        displayName: "Gather feedback",
        tooltipText: "Enter things people told you about the project so you can remember them and learn from them.",
        headerAbove: "Think About What Happened",
        panelFields: [
            {
                id: "project_feedbackLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can record any <strong>feedback</strong> you have gathered about your project."
            },
            {
                id: "project_feedbackItemsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_enterFeedbackPiece",
                displayName: "Pieces of feedback",
                displayPrompt: "These are the pieces of feedback you have entered so far."
            },
            {
                id: "feedback_generalNotes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "If you would like to enter any <strong>general notes</strong> on the feedback you've received about the project, you can write them here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_reflectOnProject',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_reflectOnProject",
        displayName: "Reflect on the project",
        tooltipText: "Answer some questions about the project, to think about it now and to help you remember it later.",
        panelFields: [
            {
                id: "project_reflectLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can answer some questions to <strong>reflect</strong> in general on the entire project."
            },
            {
                id: "project_reflect_stories_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "The stories you heard"
            },
            {
                id: "project_reflect_stories_surprised",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories surprise",
                displayPrompt: "What <strong>surprised</strong> you about the stories you heard in this project?"
            },
            {
                id: "project_reflect_stories_learned",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories learned",
                displayPrompt: "What do you know <strong>about stories</strong> that you didn't know before this project?"
            },
            {
                id: "project_reflect_stories_definition",
                valueType: "string",
                displayType: "textarea",
                displayName: "Stories definition",
                displayPrompt: "Has your <strong>definition</strong> of the word \"story\" changed during this project? If so, how?"
            },
            {
                id: "project_reflect_community_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your community or organization"
            },
            {
                id: "project_reflect_community_knownow",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community know now",
                displayPrompt: "What do you <strong>know</strong> about your community or organization that you didn’t know before the project started?"
            },
            {
                id: "project_reflect_community_dangersoppportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community dangers or opportunities",
                displayPrompt: "Did this project uncover any <strong>dangers or opportunities</strong> about your community or organization? If so, what are they?"
            },
            {
                id: "project_reflect_community_future",
                valueType: "string",
                displayType: "textarea",
                displayName: "Community future",
                displayPrompt: "How will what you have learned about your community or organization impact any <strong>future</strong> projects you do with or for it?"
            },
            {
                id: "project_reflect_yourself_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Yourself"
            },
            {
                id: "project_reflect_yourself_stuck",
                valueType: "string",
                displayType: "textarea",
                displayName: "Yourself stuck",
                displayPrompt: "In any part of this project, did you ever find yourself (personally or as a team) <strong>stuck</strong> in an area in which you thought you had strength?"
            },
            {
                id: "project_reflect_yourself_skills",
                valueType: "string",
                displayType: "textarea",
                displayName: "Yourself skills",
                displayPrompt: "During this project, did you ever find <strong>skills</strong> you didn't know you had? What happened?"
            },
            {
                id: "project_reflect_yourself_team",
                valueType: "string",
                displayType: "textarea",
                displayName: "Yourself team",
                displayPrompt: "If you are working in a <strong>team</strong>: What did you learn about how your team works together during this project? How can you use that knowledge going forward?"
            },
            {
                id: "project_reflect_planning_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your project planning"
            },
            {
                id: "project_reflect_planning_turnedout",
                valueType: "string",
                displayType: "textarea",
                displayName: "Project turned out",
                displayPrompt: "Did your project plan <strong>turn out</strong> the way you thought it would? What worked as you expected, and what didn't?"
            },
            {
                id: "project_reflect_planning_crises",
                valueType: "string",
                displayType: "textarea",
                displayName: "Planning crises",
                displayPrompt: "Were there any moments during the project where you experienced <strong>crises</strong> because your plan was not working? What happened during those moments?"
            },
            {
                id: "project_reflect_planning_opportunities",
                valueType: "string",
                displayType: "textarea",
                displayName: "Planning opportunities",
                displayPrompt: "Did any unexpected <strong>opportunities</strong> or <strong>new ideas</strong> present themselves during the project? Were there times when you said to yourself, \"I didn't plan on that, but it's a great idea\"?"
            },
            {
                id: "project_reflect_facilitation_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your facilitation"
            },
            {
                id: "project_reflect_facilitation_highlowpoints",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation high and low points",
                displayPrompt: "If you held any facilitated sessions during this project, what were some of the <strong>high and low points</strong> in your facilitation?"
            },
            {
                id: "project_reflect_facilitation_surprise",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation surprise",
                displayPrompt: "What <strong>surprised</strong> you about your facilitation?"
            },
            {
                id: "project_reflect_facilitation_know",
                valueType: "string",
                displayType: "textarea",
                displayName: "Facilitation know",
                displayPrompt: "What do you know <strong>about facilitation</strong> that you didn't know before this project?"
            },
            {
                id: "project_reflect_ownPNI_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Your own version of PNI"
            },
            {
                id: "project_reflect_ownPNI_challenge",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your PNI challenge",
                displayPrompt: "How did this project <strong>challenge</strong> the way you do PNI? What <strong>limitations</strong> did it expose?"
            },
            {
                id: "project_reflect_ownPNI_experiments",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your PNI experiments",
                displayPrompt: "Did you try any <strong>experiments</strong> with your PNI practice during this project? If so, what happened?"
            },
            {
                id: "project_reflect_ownPNI_know",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your PNI knowledge",
                displayPrompt: "What do you <strong>know</strong> about PNI that you didn't know before this project?"
            },
            {
                id: "project_reflect_ownPNI_change",
                valueType: "string",
                displayType: "textarea",
                displayName: "Your PNI change",
                displayPrompt: "How do you think your PNI practice will <strong>change</strong> because of this project?"
            },
            {
                id: "project_reflect_future_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "The future"
            },
            {
                id: "project_reflect_future_curiousity",
                valueType: "string",
                displayType: "textarea",
                displayName: "Future curiosity",
                displayPrompt: "Are there any aspects of PNI, or of story work in general, that this project makes you <strong>curious</strong> about trying in the future?"
            },
            {
                id: "project_reflect_future_projects",
                valueType: "string",
                displayType: "textarea",
                displayName: "Future projects",
                displayPrompt: "List some <strong>future projects</strong> that you would like to do after this project, if you can. What would you like to do next?"
            },
            {
                id: "project_reflect_notes_header",
                valueType: "none",
                displayType: "header",
                displayPrompt: "Notes"
            },
            {
                id: "project_reflect_future_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any <strong>general notes</strong> you'd like to remember about the project."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_prepareProjectPresentation',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_prepareProjectPresentation",
        displayName: "Prepare outline of project presentation",
        tooltipText: "Create an outline you can use to present your project to other people.",
        headerAbove: "Support Your Community",
        panelFields: [
            {
                id: "project_presentationLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "You can use this page to build an outline for a <strong>presentation</strong> about your project to show to others. After you finish building your outline, you can export it, open it in your word processor, format your writing, and add material from NarraFirma's final project report."
            },
            {
                id: "project_presentationElementsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: "panel_addPresentationElement",
                displayName: "Statements",
                displayPrompt: "These are the presentation elements you have created so far."
            },
            {
                id: "projectPresentation_exportPresentationOutlineButton",
                valueType: "none",
                displayType: "button",
                displayPrompt: "Export Outline",
                displayConfiguration: "exportPresentationOutline"
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/page_projectRequests',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "page_projectRequests",
        displayName: "Respond to requests for post-project support",
        tooltipText: "Record requests for help as the project winds down, so you can meet them now and remember them later.",
        panelFields: [
            {
                id: "project_returnRequestsLabel",
                valueType: "none",
                displayType: "label",
                displayPrompt: "On this page you can keep track of <strong>requests for help</strong> you receive as your project winds down."
            },
            {
                id: "project_returnRequestsList",
                valueType: "array",
                displayType: "grid",
                displayConfiguration: {
                    itemPanelID: "panel_addNewReturnRequest",
                    gridConfiguration: {
                        viewButton: true,
                        editButton: true,
                        addButton: true,
                        removeButton: true,
                        columnsToDisplay: ["returnRequest_description", "returnRequest_type", "returnRequest_isMet"]
                    }
                },
                displayName: "Help requests",
                displayPrompt: "These are the requests you have recorded so far."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/panel_enterFeedbackPiece',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_enterFeedbackPiece",
        modelClass: "FeedbackPiece",
        panelFields: [
            {
                id: "feedback_name",
                valueType: "string",
                displayType: "text",
                displayName: "Name",
                displayPrompt: "Please give this piece of feedback a <strong>name</strong>."
            },
            {
                id: "feedback_text",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "What did someone <strong>say or do</strong>?"
            },
            {
                id: "feedback_type",
                valueType: "string",
                valueOptions: [
                    "a reference to something from the project",
                    "a concern or complaint",
                    "a thank you",
                    "a suggestion",
                    "a hope or wish",
                    "a statement of fact",
                    "an opinion",
                    "a story",
                    "an action",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of feedback was it?"
            },
            {
                id: "feedback_who",
                valueType: "string",
                displayType: "text",
                displayName: "Source",
                displayPrompt: "<strong>Who</strong> said or did this?"
            },
            {
                id: "feedback_prompt",
                valueType: "string",
                displayType: "textarea",
                displayName: "What led to it",
                displayPrompt: "What did you say or do (if anything) that <strong>led to</strong> this feedback?"
            },
            {
                id: "feedback_response",
                valueType: "string",
                displayType: "textarea",
                displayName: "What I said back",
                displayPrompt: "What did you say or do (if anything) <strong>in response</strong>?"
            },
            {
                id: "feedback_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Please enter any other <strong>notes</strong> you would like to remember about this piece of feedback."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/panel_addPresentationElement',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addPresentationElement",
        modelClass: "PresentationElement",
        panelFields: [
            {
                id: "projectPresentationElement_name",
                valueType: "string",
                displayType: "text",
                displayName: "Element name",
                displayPrompt: "Please give this presentation element a <strong>name</strong>."
            },
            {
                id: "projectPresentationElement_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "<strong>Describe</strong> this presentation element. What do you want to tell people about?"
            },
            {
                id: "projectPresentationElement_type",
                valueType: "string",
                valueOptions: [
                    "a background explanation about the project",
                    "a report on what happened",
                    "a project outcome",
                    "something someone said about the project",
                    "something you learned during the project",
                    "how the project affected the community",
                    "a proposal for the future",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of element is this?"
            },
            {
                id: "projectPresentationElement_examples",
                valueType: "string",
                displayType: "textarea",
                displayName: "Examples",
                displayPrompt: "Here you can list some <strong>stories and/or patterns</strong> that illustrate this presentation element."
            },
            {
                id: "projectPresentationElement_QA",
                valueType: "string",
                displayType: "textarea",
                displayName: "Q&A",
                displayPrompt: "What <strong>questions</strong> do you anticipate about this element? How would you like to answer them?"
            },
            {
                id: "projectPresentationElement_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any other <strong>notes</strong> you want to include about this presentation element."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/return/panel_addNewReturnRequest',["require", "exports"], function (require, exports) {
    "use strict";
    var panel = {
        id: "panel_addNewReturnRequest",
        modelClass: "ReturnRequest",
        panelFields: [
            {
                id: "returnRequest_description",
                valueType: "string",
                displayType: "textarea",
                displayName: "Description",
                displayPrompt: "Please <strong>describe</strong> the request."
            },
            {
                id: "returnRequest_type",
                valueType: "string",
                valueOptions: [
                    "help with their own projects",
                    "help with sustaining story exchange",
                    "help with examining this project's stories and results",
                    "help learning about story work",
                    "other"
                ],
                displayType: "select",
                displayName: "Type",
                displayPrompt: "What <strong>type</strong> of request is this?"
            },
            {
                id: "returnRequest_isMet",
                valueType: "boolean",
                displayType: "boolean",
                displayName: "Satisfied",
                displayPrompt: "Do you consider this request to have been <strong>satisfied</strong>?"
            },
            {
                id: "returnRequest_whatHappened",
                valueType: "string",
                displayType: "textarea",
                displayName: "What happened",
                displayPrompt: "<strong>What has happened</strong> in relation to this request? What discussions took place? Who did what?"
            },
            {
                id: "returnRequest_notes",
                valueType: "string",
                displayType: "textarea",
                displayName: "Notes",
                displayPrompt: "Enter any other <strong>notes</strong> about the request here."
            }
        ]
    };
    return panel;
});

define('js/applicationPanelSpecifications/navigation',["require", "exports", "./dashboard/page_dashboard", "./administration/page_administration", "./administration/page_importExport", "./planning/page_planning", "./planning/page_projectFacts", "./planning/page_planningQuestionsDraft", "./planning/page_participantGroups", "./planning/page_describeYourResources", "./planning/page_projectStories", "./planning/page_createProjectStoryElements", "./planning/page_assessStorySharing", "./planning/page_revisePNIPlanningQuestions", "./planning/page_writeProjectSynopsis", "./planning/panel_addParticipantGroup", "./planning/panel_projectStory", "./collection/page_collection", "./collection/page_chooseCollectionMethods", "./collection/page_planStoryCollectionSessions", "./collection/page_writeStoryElicitingQuestions", "./collection/page_writeQuestionsAboutStories", "./collection/page_writeQuestionsAboutParticipants", "./collection/page_designStoryForms", "./collection/page_startStoryCollection", "./collection/page_printQuestionForms", "./collection/page_enterStories", "./collection/page_writeAnnotationsAboutStories", "./collection/page_reviewIncomingStories", "./collection/page_browseGraphs", "./collection/page_stopStoryCollection", "./collection/page_enterCollectionSessionRecords", "./collection/panel_addStoryCollectionMethod", "./collection/panel_addStoryCollectionSession", "./collection/panel_addCollectionSessionActivity", "./collection/panel_addElicitingQuestion", "./collection/panel_addStoryQuestion", "./collection/panel_addParticipantQuestion", "./collection/panel_addStoryForm", "./collection/panel_chooseElicitingQuestion", "./collection/panel_chooseStoryQuestion", "./collection/panel_chooseParticipantQuestion", "./collection/panel_addStoryCollection", "./collection/panel_addAnnotationQuestion", "./collection/panel_addCollectionSessionRecord", "./collection/panel_newCollectionSessionConstruction", "./catalysis/page_catalysis", "./catalysis/page_startCatalysisReport", "./catalysis/page_configureCatalysisReport", "./catalysis/page_explorePatterns", "./catalysis/page_clusterInterpretations", "./catalysis/page_printCatalysisReport", "./catalysis/panel_addCatalysisReport", "./catalysis/panel_chooseStoryCollection", "./catalysis/panel_addInterpretation", "./sensemaking/page_sensemaking", "./sensemaking/page_printStoryCards", "./sensemaking/page_planSensemakingSessions", "./sensemaking/page_enterSensemakingSessionRecords", "./sensemaking/panel_addSensemakingSessionPlan", "./sensemaking/panel_addSensemakingSessionActivity", "./sensemaking/panel_addSensemakingSessionRecord", "./sensemaking/panel_addResonantStory", "./sensemaking/panel_addResonantPattern", "./sensemaking/panel_newSensemakingSessionOutcome", "./sensemaking/panel_newSensemakingSessionConstruction", "./intervention/page_intervention", "./intervention/page_projectOutcomesForIntervention", "./intervention/page_designInterventions", "./intervention/page_recordInterventions", "./intervention/panel_projectOutcome", "./intervention/panel_addIntervention", "./intervention/panel_addInterventionRecord", "./return/page_return", "./return/page_gatherFeedback", "./return/page_reflectOnProject", "./return/page_prepareProjectPresentation", "./return/page_projectRequests", "./return/panel_enterFeedbackPiece", "./return/panel_addPresentationElement", "./return/panel_addNewReturnRequest"], function (require, exports, page_dashboard, page_administration, page_importExport, page_planning, page_projectFacts, page_planningQuestionsDraft, page_participantGroups, page_describeYourResources, page_projectStories, page_createProjectStoryElements, page_assessStorySharing, page_revisePNIPlanningQuestions, page_writeProjectSynopsis, panel_addParticipantGroup, panel_projectStory, page_collection, page_chooseCollectionMethods, page_planStoryCollectionSessions, page_writeStoryElicitingQuestions, page_writeQuestionsAboutStories, page_writeQuestionsAboutParticipants, page_designStoryForms, page_startStoryCollection, page_printQuestionForms, page_enterStories, page_writeAnnotationsAboutStories, page_reviewIncomingStories, page_browseGraphs, page_stopStoryCollection, page_enterCollectionSessionRecords, panel_addStoryCollectionMethod, panel_addStoryCollectionSession, panel_addCollectionSessionActivity, panel_addElicitingQuestion, panel_addStoryQuestion, panel_addParticipantQuestion, panel_addStoryForm, panel_chooseElicitingQuestion, panel_chooseStoryQuestion, panel_chooseParticipantQuestion, panel_addStoryCollection, panel_addAnnotationQuestion, panel_addCollectionSessionRecord, panel_newCollectionSessionConstruction, page_catalysis, page_startCatalysisReport, page_configureCatalysisReport, page_explorePatterns, page_clusterInterpretations, page_printCatalysisReport, panel_addCatalysisReport, panel_chooseStoryCollection, panel_addInterpretation, page_sensemaking, page_printStoryCards, page_planSensemakingSessions, page_enterSensemakingSessionRecords, panel_addSensemakingSessionPlan, panel_addSensemakingSessionActivity, panel_addSensemakingSessionRecord, panel_addResonantStory, panel_addResonantPattern, panel_newSensemakingSessionOutcome, panel_newSensemakingSessionConstruction, page_intervention, page_projectOutcomesForIntervention, page_designInterventions, page_recordInterventions, panel_projectOutcome, panel_addIntervention, panel_addInterventionRecord, page_return, page_gatherFeedback, page_reflectOnProject, page_prepareProjectPresentation, page_projectRequests, panel_enterFeedbackPiece, panel_addPresentationElement, panel_addNewReturnRequest) {
    var navigationModules = {};
    navigationModules["page_dashboard"] = page_dashboard;
    navigationModules["page_administration"] = page_administration;
    navigationModules["page_importExport"] = page_importExport;
    navigationModules["page_planning"] = page_planning;
    navigationModules["page_projectFacts"] = page_projectFacts;
    navigationModules["page_planningQuestionsDraft"] = page_planningQuestionsDraft;
    navigationModules["page_participantGroups"] = page_participantGroups;
    navigationModules["page_describeYourResources"] = page_describeYourResources;
    navigationModules["page_projectStories"] = page_projectStories;
    navigationModules["page_createProjectStoryElements"] = page_createProjectStoryElements;
    navigationModules["page_assessStorySharing"] = page_assessStorySharing;
    navigationModules["page_revisePNIPlanningQuestions"] = page_revisePNIPlanningQuestions;
    navigationModules["page_writeProjectSynopsis"] = page_writeProjectSynopsis;
    navigationModules["panel_addParticipantGroup"] = panel_addParticipantGroup;
    navigationModules["panel_projectStory"] = panel_projectStory;
    navigationModules["page_collection"] = page_collection;
    navigationModules["page_chooseCollectionMethods"] = page_chooseCollectionMethods;
    navigationModules["page_planStoryCollectionSessions"] = page_planStoryCollectionSessions;
    navigationModules["page_writeStoryElicitingQuestions"] = page_writeStoryElicitingQuestions;
    navigationModules["page_writeQuestionsAboutStories"] = page_writeQuestionsAboutStories;
    navigationModules["page_writeQuestionsAboutParticipants"] = page_writeQuestionsAboutParticipants;
    navigationModules["page_designStoryForms"] = page_designStoryForms;
    navigationModules["page_startStoryCollection"] = page_startStoryCollection;
    navigationModules["page_printQuestionForms"] = page_printQuestionForms;
    navigationModules["page_enterStories"] = page_enterStories;
    navigationModules["page_writeAnnotationsAboutStories"] = page_writeAnnotationsAboutStories;
    navigationModules["page_reviewIncomingStories"] = page_reviewIncomingStories;
    navigationModules["page_browseGraphs"] = page_browseGraphs;
    navigationModules["page_stopStoryCollection"] = page_stopStoryCollection;
    navigationModules["page_enterCollectionSessionRecords"] = page_enterCollectionSessionRecords;
    navigationModules["panel_addStoryCollectionMethod"] = panel_addStoryCollectionMethod;
    navigationModules["panel_addStoryCollectionSession"] = panel_addStoryCollectionSession;
    navigationModules["panel_addCollectionSessionActivity"] = panel_addCollectionSessionActivity;
    navigationModules["panel_addElicitingQuestion"] = panel_addElicitingQuestion;
    navigationModules["panel_addStoryQuestion"] = panel_addStoryQuestion;
    navigationModules["panel_addParticipantQuestion"] = panel_addParticipantQuestion;
    navigationModules["panel_addStoryForm"] = panel_addStoryForm;
    navigationModules["panel_chooseElicitingQuestion"] = panel_chooseElicitingQuestion;
    navigationModules["panel_chooseStoryQuestion"] = panel_chooseStoryQuestion;
    navigationModules["panel_chooseParticipantQuestion"] = panel_chooseParticipantQuestion;
    navigationModules["panel_addStoryCollection"] = panel_addStoryCollection;
    navigationModules["panel_addAnnotationQuestion"] = panel_addAnnotationQuestion;
    navigationModules["panel_addCollectionSessionRecord"] = panel_addCollectionSessionRecord;
    navigationModules["panel_newCollectionSessionConstruction"] = panel_newCollectionSessionConstruction;
    navigationModules["page_catalysis"] = page_catalysis;
    navigationModules["page_startCatalysisReport"] = page_startCatalysisReport;
    navigationModules["page_configureCatalysisReport"] = page_configureCatalysisReport;
    navigationModules["page_explorePatterns"] = page_explorePatterns;
    navigationModules["page_clusterInterpretations"] = page_clusterInterpretations;
    navigationModules["page_printCatalysisReport"] = page_printCatalysisReport;
    navigationModules["panel_addCatalysisReport"] = panel_addCatalysisReport;
    navigationModules["panel_chooseStoryCollection"] = panel_chooseStoryCollection;
    navigationModules["panel_addInterpretation"] = panel_addInterpretation;
    navigationModules["page_sensemaking"] = page_sensemaking;
    navigationModules["page_printStoryCards"] = page_printStoryCards;
    navigationModules["page_planSensemakingSessions"] = page_planSensemakingSessions;
    navigationModules["page_enterSensemakingSessionRecords"] = page_enterSensemakingSessionRecords;
    navigationModules["panel_addSensemakingSessionPlan"] = panel_addSensemakingSessionPlan;
    navigationModules["panel_addSensemakingSessionActivity"] = panel_addSensemakingSessionActivity;
    navigationModules["panel_addSensemakingSessionRecord"] = panel_addSensemakingSessionRecord;
    navigationModules["panel_addResonantStory"] = panel_addResonantStory;
    navigationModules["panel_addResonantPattern"] = panel_addResonantPattern;
    navigationModules["panel_newSensemakingSessionOutcome"] = panel_newSensemakingSessionOutcome;
    navigationModules["panel_newSensemakingSessionConstruction"] = panel_newSensemakingSessionConstruction;
    navigationModules["page_intervention"] = page_intervention;
    navigationModules["page_projectOutcomesForIntervention"] = page_projectOutcomesForIntervention;
    navigationModules["page_designInterventions"] = page_designInterventions;
    navigationModules["page_recordInterventions"] = page_recordInterventions;
    navigationModules["panel_projectOutcome"] = panel_projectOutcome;
    navigationModules["panel_addIntervention"] = panel_addIntervention;
    navigationModules["panel_addInterventionRecord"] = panel_addInterventionRecord;
    navigationModules["page_return"] = page_return;
    navigationModules["page_gatherFeedback"] = page_gatherFeedback;
    navigationModules["page_reflectOnProject"] = page_reflectOnProject;
    navigationModules["page_prepareProjectPresentation"] = page_prepareProjectPresentation;
    navigationModules["page_projectRequests"] = page_projectRequests;
    navigationModules["panel_enterFeedbackPiece"] = panel_enterFeedbackPiece;
    navigationModules["panel_addPresentationElement"] = panel_addPresentationElement;
    navigationModules["panel_addNewReturnRequest"] = panel_addNewReturnRequest;
    var sections = [
        {
            section: "dashboard",
            sectionName: "Dashboard",
            pages: [
                "page_dashboard"
            ],
            panels: []
        },
        {
            section: "administration",
            sectionName: "Administration",
            pages: [
                "page_administration",
                "page_importExport"
            ],
            panels: []
        },
        {
            section: "planning",
            sectionName: "Planning",
            pages: [
                "page_planning",
                "page_projectFacts",
                "page_planningQuestionsDraft",
                "page_participantGroups",
                "page_describeYourResources",
                "page_projectStories",
                "page_createProjectStoryElements",
                "page_assessStorySharing",
                "page_revisePNIPlanningQuestions",
                "page_writeProjectSynopsis"
            ],
            panels: [
                "panel_addParticipantGroup",
                "panel_projectStory"
            ]
        },
        {
            section: "collection",
            sectionName: "Collection",
            pages: [
                "page_collection",
                "page_chooseCollectionMethods",
                "page_planStoryCollectionSessions",
                "page_writeStoryElicitingQuestions",
                "page_writeQuestionsAboutStories",
                "page_writeQuestionsAboutParticipants",
                "page_designStoryForms",
                "page_startStoryCollection",
                "page_printQuestionForms",
                "page_enterStories",
                "page_writeAnnotationsAboutStories",
                "page_reviewIncomingStories",
                "page_browseGraphs",
                "page_stopStoryCollection",
                "page_enterCollectionSessionRecords"
            ],
            panels: [
                "panel_addStoryCollectionMethod",
                "panel_addStoryCollectionSession",
                "panel_addCollectionSessionActivity",
                "panel_addElicitingQuestion",
                "panel_addStoryQuestion",
                "panel_addParticipantQuestion",
                "panel_addStoryForm",
                "panel_chooseElicitingQuestion",
                "panel_chooseStoryQuestion",
                "panel_chooseParticipantQuestion",
                "panel_addStoryCollection",
                "panel_addAnnotationQuestion",
                "panel_addCollectionSessionRecord",
                "panel_newCollectionSessionConstruction"
            ]
        },
        {
            section: "catalysis",
            sectionName: "Catalysis",
            pages: [
                "page_catalysis",
                "page_startCatalysisReport",
                "page_configureCatalysisReport",
                "page_explorePatterns",
                "page_clusterInterpretations",
                "page_printCatalysisReport"
            ],
            panels: [
                "panel_addCatalysisReport",
                "panel_chooseStoryCollection",
                "panel_addInterpretation"
            ]
        },
        {
            section: "sensemaking",
            sectionName: "Sensemaking",
            pages: [
                "page_sensemaking",
                "page_printStoryCards",
                "page_planSensemakingSessions",
                "page_enterSensemakingSessionRecords"
            ],
            panels: [
                "panel_addSensemakingSessionPlan",
                "panel_addSensemakingSessionActivity",
                "panel_addSensemakingSessionRecord",
                "panel_addResonantStory",
                "panel_addResonantPattern",
                "panel_newSensemakingSessionOutcome",
                "panel_newSensemakingSessionConstruction"
            ]
        },
        {
            section: "intervention",
            sectionName: "Intervention",
            pages: [
                "page_intervention",
                "page_projectOutcomesForIntervention",
                "page_designInterventions",
                "page_recordInterventions"
            ],
            panels: [
                "panel_projectOutcome",
                "panel_addIntervention",
                "panel_addInterventionRecord"
            ]
        },
        {
            section: "return",
            sectionName: "Return",
            pages: [
                "page_return",
                "page_gatherFeedback",
                "page_reflectOnProject",
                "page_prepareProjectPresentation",
                "page_projectRequests"
            ],
            panels: [
                "panel_enterFeedbackPiece",
                "panel_addPresentationElement",
                "panel_addNewReturnRequest"
            ]
        }
    ];
    sections["navigationModules"] = navigationModules;
    return sections;
});

define('js/Application',["require", "exports", "./nls/applicationMessages", "./buttonActions", "./csvImportExport", "./panelBuilder/dialogSupport", "./applicationWidgets/loadAllApplicationWidgets", "./panelBuilder/loadAllPanelSpecifications", "./navigationPane", "./pageDisplayer", "./panelBuilder/PanelBuilder", "./pointrel20150417/PointrelClient", "./Project", "./surveyCollection", "./panelBuilder/toaster", "./panelBuilder/translate", "mithril", "./applicationPanelSpecifications/navigation", "./PanelSetup", "./Globals", "lodash"], function (require, exports, applicationMessages, buttonActions, csvImportExport, dialogSupport, loadAllApplicationWidgets, loadAllPanelSpecifications, navigationPane, pageDisplayer, PanelBuilder, PointrelClient, Project, surveyCollection, toaster, translate, m, navigationSections, PanelSetup, Globals, _) {
    "use strict";
    // TODO: Add page validation
    var narrafirmaProjectPrefix = "NarraFirmaProject-";
    var loadingBase = "js/applicationPanelSpecifications/";
    var Application = (function () {
        function Application() {
            this.readOnly = false;
            /*
            export function project() {
                return _project;
            }
            */
            this.lastServerError = "";
            // The runningAfterIdle falg is used to limit redraws for new project messages until after initial set recevied
            this.runningAfterInitialIdle = false;
            this.pendingRedraw = null;
            this.updateHashTimer = null;
            this.panelBuilder = new PanelBuilder(this);
        }
        // Make all of the application pages selectable from the dropdown list and back/next buttons and put them in a TabContainer
        Application.prototype.createLayout = function () {
            // console.log("createLayout start");
            // TODO: Improve status reporting
            // serverStatusPane = panelBuilder.newContentPane({content: "Server status: unknown"});
            // serverStatusPane.placeAt(pageControlsPane);
            /*
            statusTooltip = new Tooltip({
                connectId: ["narrafirma-name"],
                label: "Server status: unknown",
                position: ["below", "after", "above", "before"]
            });
            */
            // updateServerStatus("Server status: unknown");
            // console.log("createLayout end");
        };
        // TODO: Think more about how to integrate updatedServerStatus this with Mithril
        Application.prototype.updateServerStatus = function (status, text) {
            // The serverStatusPane may be created only after we start talking to the server
            // if (!serverStatusPane) return;
            var nameDiv = document.getElementById("narrafirma-name");
            if (!nameDiv)
                return;
            // TODO: Translate
            var statusText = "Project: " + Globals.project().journalIdentifier.substring(narrafirmaProjectPrefix.length) + "; Server status: (" + status + ") " + text;
            if (status === "ok") {
                nameDiv.className = "narrafirma-serverstatus-ok";
                //nameDiv.style.color = "green";
                //nameDiv.style.border = "initial";
                this.lastServerError = "";
            }
            else if (status === "waiting") {
                //nameDiv.style.color = "yellow";
                if (this.lastServerError) {
                    // TODO: Translate
                    nameDiv.className = "narrafirma-serverstatus-waiting-last-error";
                    statusText += "\n" + "Last error: " + this.lastServerError;
                }
                else {
                    nameDiv.className = "narrafirma-serverstatus-waiting";
                }
            }
            else if (status === "failure" || status === "failure-loss") {
                nameDiv.className = "narrafirma-serverstatus-failure";
                //nameDiv.style.color = "red";
                this.lastServerError = text;
                //nameDiv.style.border = "thick solid #FF0000";
                console.log("updateServerStatus failure", text);
                if (status === "failure-loss") {
                    // Very serious error with data loss -- alert the user
                    if (this.readOnly) {
                        // toaster.toast("Project is read only; changes are not being saved.");
                        nameDiv.className = "narrafirma-serverstatus-ok";
                        this.lastServerError = "Read-only OK";
                    }
                    else {
                        toaster.toast("Server lost recent change:\n" + text);
                    }
                }
            }
            else {
                console.log("Unexpected server status", status);
                nameDiv.className = "narrafirma-serverstatus-unexpected";
                //nameDiv.style.color = "black";
                console.log("updateServerStatus unexpected", text);
            }
            nameDiv.title = statusText;
            Globals.clientState().serverStatus(nameDiv.className);
            Globals.clientState().serverStatusText(statusText);
            // TODO: Need to make tooltip text ARIA accessible; suggestion in tooltip docs on setting text in tab order
            // statusTooltip.set("label", statusText); 
            // serverStatusPane.set("content", statusText);
        };
        // dispatch the button click
        Application.prototype.buttonClicked = function (panelBuilder, model, fieldSpecification, value) {
            // console.log("buttonClicked", fieldSpecification);
            var functionName = fieldSpecification.id;
            if (fieldSpecification.displayConfiguration) {
                if (_.isString(fieldSpecification.displayConfiguration)) {
                    functionName = fieldSpecification.displayConfiguration;
                }
                else {
                    functionName = fieldSpecification.displayConfiguration.action;
                }
            }
            var actualFunction = buttonActions[functionName];
            if (!actualFunction) {
                var message = "Unfinished handling for: " + fieldSpecification.id + " with functionName: " + functionName;
                console.log(message, model, fieldSpecification, value);
                alert(message);
            }
            else {
                actualFunction(model, fieldSpecification, value);
            }
        };
        // Panel builder "functionResult" components will get routed through here to calculate their text.
        Application.prototype.calculateFunctionResultForGUI = function (panelBuilder, model, fieldSpecification, functionName) {
            if (functionName === "isStoryCollectingEnabled") {
                return surveyCollection.isStoryCollectingEnabled();
            }
            else if (functionName === "storeQuestionnaireInStoryCollection") {
                var storyCollectionIdentifier = fieldSpecification.value;
                var success = buttonActions.setQuestionnaireForStoryCollection(storyCollectionIdentifier);
                return success ? null : ["Questionnaire could not be created for story collection"];
            }
            else {
                console.log("TODO: calculateFunctionResultForGUI ", functionName, fieldSpecification);
                return "calculateFunctionResultForGUI UNFINISHED: " + functionName + " for: " + fieldSpecification.id;
            }
        };
        Application.prototype.setupGlobalFunctions = function () {
            // Set up global function used by section dashboard links
            window["narrafirma_openPage"] = function (pageIdentifier) {
                // console.log("narrafirma_openPage", pageIdentifier);
                if (!pageIdentifier)
                    return;
                Globals.clientState().pageIdentifier(pageIdentifier);
                Globals.clientState().updateHashIfNeededForChangedClientState();
                // Page displayer will handle cases where the hash is not valid and also optimizing out page redraws if staying on same page
                pageDisplayer.showPage(Globals.clientState().pageIdentifier());
                // document.body.scrollTop = 0;
                // document.documentElement.scrollTop = 0;
                window.scrollTo(0, 0);
            };
            window["narrafirma_logoutClicked"] = function () {
                buttonActions.logoutButtonClicked();
            };
            window["narrafirma_loginClicked"] = function () {
                buttonActions.loginButtonClicked();
            };
            window["narrafirma_helpClicked"] = function (pageIdentifier) {
                buttonActions.helpButtonClicked();
            };
        };
        // The main starting point of the application
        Application.prototype.initialize = function () {
            var _this = this;
            console.log("=======", new Date().toISOString(), "application.initialize() called");
            // TODO: Translate
            document.getElementById("pleaseWaitDiv").innerHTML = "Retrieving user information from server; please wait...";
            // Cast to silence TypeScript warning about use of translate.configure
            translate.configure({}, applicationMessages.root);
            Globals.clientState().initialize();
            this.setupGlobalFunctions();
            // mount Mithril dialog support now, as it may be needed in choosing a project
            dialogSupport.initialize();
            // Throwaway single-use pointrel client instance which does not access a specific journal and for which polling is not started
            var singleUsePointrelClient = new PointrelClient("/api/pointrel20150417", "unused", {});
            singleUsePointrelClient.getCurrentUserInformation(function (error, response) {
                if (error) {
                    console.log("error", error, response);
                    document.getElementById("pleaseWaitDiv").style.display = "none";
                    document.getElementById("pageDiv").innerHTML = "Problem talking to server. Please contact your NarraFirma administrator.";
                    document.getElementById("pageDiv").style.display = "block";
                    alert("Something went wrong determining the current user identifier");
                    return;
                }
                console.log("initialize response", response);
                var userIdentifier = response.userIdentifier;
                if (userIdentifier === undefined || userIdentifier === null || userIdentifier === false) {
                    userIdentifier = "anonymous";
                }
                _this.userIdentifier = userIdentifier;
                var projects = [];
                for (var key in response.journalPermissions) {
                    if (!_.startsWith(key, narrafirmaProjectPrefix))
                        continue;
                    var permissions = response.journalPermissions[key];
                    projects.push({
                        id: key,
                        name: key.substring(narrafirmaProjectPrefix.length),
                        read: permissions.read,
                        write: permissions.write,
                        admin: permissions.admin
                    });
                }
                if (!projects.length) {
                    document.getElementById("pleaseWaitDiv").style.display = "none";
                    var recoveryText = "Please contact your NarraFirma project administrator.";
                    var loginText = "";
                    if (_this.userIdentifier === "anonymous") {
                        recoveryText = "Please try logging in.";
                        // TODO: Needs to be different for Wordpress
                        loginText = ' <a href="/login">login</a>';
                    }
                    document.body.innerHTML += '<br><b>No projects. The NarraFirma application can not run.</b> ' + recoveryText + loginText;
                    alert("There are no projects accessible by the current user (" + _this.userIdentifier + "). " + recoveryText);
                    return;
                }
                _this.chooseAProjectToOpen(response.userIdentifier, projects);
            });
        };
        Application.prototype.chooseAProjectToOpen = function (userIdentifierFromServer, projects) {
            var _this = this;
            // Initialize toaster
            toaster.createToasterWidget("toasterDiv");
            loadAllApplicationWidgets(PanelBuilder);
            document.getElementById("pleaseWaitDiv").style.display = "none";
            var userCredentials = {
                userIdentifier: this.userIdentifier
            };
            var projectIdentifierSupplied = Globals.clientState().projectIdentifier();
            console.log("projectIdentifierSupplied", projectIdentifierSupplied);
            if (projectIdentifierSupplied) {
                // TODO: Could put up project chooser if the supplied project is invalid...
                this.openProject(userCredentials, narrafirmaProjectPrefix + projectIdentifierSupplied, projects);
            }
            else {
                // TODO: Translate
                var columns = { name: "Project name", id: "Project journal", write: "Editable" };
                // TODO: Only allow new project button for admins
                var isNewAllowed = false;
                dialogSupport.openListChoiceDialog(null, projects, columns, "Projects", "Select a project to work on", isNewAllowed, function (projectChoice) {
                    if (!projectChoice)
                        return;
                    _this.projectIdentifier = projectChoice.id;
                    if (!_this.projectIdentifier)
                        return;
                    if (projectChoice.isNew) {
                        Globals.clientState().projectIdentifier(_this.projectIdentifier);
                        _this.projectIdentifier = narrafirmaProjectPrefix + _this.projectIdentifier;
                        _this.journalIdentifier = _this.projectIdentifier;
                        alert("About to make project: " + _this.projectIdentifier);
                        _this.makeNewProject();
                        return;
                    }
                    else {
                        Globals.clientState().projectIdentifier(_this.projectIdentifier.substring(narrafirmaProjectPrefix.length));
                    }
                    _this.openProject(userCredentials, _this.projectIdentifier, projects);
                });
                // Because we are opening a dialog at startup, not caused by a user event, we need to tell Mithril to redraw.
                // Safari 5 seems to sometimes get the event sequence wrong at startup, adding 100ms delay to help ensure the redraw is queued after this event is entirely done
                setTimeout(m.redraw, 100);
            }
        };
        Application.prototype.makeNewProject = function () {
            var _this = this;
            console.log("add-journal", this.journalIdentifier);
            var singleUsePointrelClient = new PointrelClient("/api/pointrel20150417", "unused", {});
            singleUsePointrelClient.createJournal(this.journalIdentifier, function (error, response) {
                if (error || !response.success) {
                    console.log("Error creating journal", _this.journalIdentifier, error, response);
                    var message = "error";
                    if (response)
                        message = response.description;
                    if (error)
                        message = error.description;
                    toaster.toast("Error: creating journal: " + _this.journalIdentifier + " :: " + message);
                }
                else {
                    console.log("Created journal OK", _this.journalIdentifier, response);
                    toaster.toast("Created journal OK: " + _this.journalIdentifier);
                    // allProjectsModel.projects.push({name: this.journalIdentifier.substring(narrafirmaProjectPrefix.length)});
                    // Need to call redraw as event changing data was triggered by network
                    // m.redraw();
                    console.log("About to trigger page reload for changed project");
                    location.reload();
                }
            });
        };
        Application.prototype.redrawFromProject = function () {
            var _this = this;
            // The tripleStore may not be updated yet, so this redraw needs to get queued for later by the application
            if (this.runningAfterInitialIdle) {
                if (!this.pendingRedraw) {
                    // console.log("queueing redrawFromProject");
                    this.pendingRedraw = setTimeout(function () {
                        // console.log("redrawFromProject");
                        _this.pendingRedraw = null;
                        m.redraw();
                    }, 0);
                }
            }
        };
        Application.prototype.openProject = function (userCredentials, projectIdentifier, projects) {
            var _this = this;
            document.getElementById("pleaseWaitDiv").style.display = "block";
            // TODO: Should this be managed separately?
            this.journalIdentifier = projectIdentifier;
            Globals.project(new Project(this.journalIdentifier, projectIdentifier, userCredentials, this.updateServerStatus.bind(this), this.redrawFromProject.bind(this)));
            console.log("openProject", Globals.project());
            surveyCollection.setProject(Globals.project());
            // TODO: Translate
            document.getElementById("pleaseWaitDiv").innerHTML = "Retrieving project data from server; please wait...";
            Globals.project().startup(function (error) {
                if (error) {
                    document.getElementById("pleaseWaitDiv").style.display = "none";
                    // TODO: Sanitize journalIdentifier
                    document.body.innerHTML += '<br>Problem connecting to project journal on server for: "<b>' + _this.journalIdentifier + '</b>"';
                    alert("Problem connecting to project journal on server. Application will not run.");
                    return;
                }
                else {
                    projects.forEach(function (project) {
                        if (project.id !== projectIdentifier)
                            return;
                        _this.readOnly = !project.write;
                        Globals.project().readOnly = _this.readOnly;
                        // this.panelBuilder.readOnly = isReadOnly;
                        if (_this.readOnly) {
                            toaster.toast("Project is read-only for this user");
                            Globals.project().pointrelClient.suspendOutgoingMessages(true);
                        }
                    });
                    _this.loadApplicationDesign();
                }
            });
        };
        Application.prototype.loadApplicationDesign = function () {
            var _this = this;
            var panelSpecificationCollection = PanelSetup.panelSpecificationCollection();
            Globals.panelSpecificationCollection(panelSpecificationCollection);
            // Load the application design
            loadAllPanelSpecifications(panelSpecificationCollection, navigationSections, loadingBase, function () {
                // generateNavigationDataInJSON();
                PanelSetup.processAllPanels();
                // TODO: Only for creating models once
                //printModels();
                //return;
                // Tell the panel builder how to build panels
                _this.panelBuilder.setPanelSpecifications(panelSpecificationCollection);
                // Tell the panelBuilder what do do if a button is clicked
                _this.panelBuilder.setButtonClickedCallback(_this.buttonClicked.bind(_this));
                _this.panelBuilder.setCalculateFunctionResultCallback(_this.calculateFunctionResultForGUI.bind(_this));
                // Initialize different Mithril components which will be mounted using m.mount
                // Note that dialogSupport has already been initialized and that component mounted
                navigationPane.initializeNavigationPane(panelSpecificationCollection, _this.userIdentifier, _this.panelBuilder);
                pageDisplayer.configurePageDisplayer(_this.panelBuilder, Globals.project(), Globals.clientState());
                // Fill out initial hash string if needed
                Globals.clientState().updateHashIfNeededForChangedClientState();
                _this.createLayout();
                // TODO: What to do while waiting for data for a project to load from server the first time? Assuming authenticated OK etc.???
                // TODO: This assumes we have picked a project, and are actually loading data and have not errored out
                // TODO: Need some kind of progress indicator of messages loaded...
                Globals.project().pointrelClient.idleCallback = function () {
                    // Now that data is presumably loaded into the Project tripleStore, we can proceed with further initialization
                    buttonActions.initialize(Globals.project(), Globals.clientState());
                    csvImportExport.initialize(Globals.project());
                    // Ensure the pageDisplayer will display the first page
                    Globals.clientState().urlHashFragmentChanged(pageDisplayer);
                    // Update if the URL hash fragment is changed by hand
                    window.onhashchange = Globals.clientState().urlHashFragmentChanged.bind(Globals.clientState(), pageDisplayer);
                    // turn off initial "please wait" display
                    document.getElementById("pleaseWaitDiv").style.display = "none";
                    document.getElementById("navigationDiv").style.display = "block";
                    document.getElementById("pageDiv").style.display = "block";
                    _this.runningAfterInitialIdle = true;
                    // TODO: Polling for changes by a read-only client should be an option somewhere; hard-coding it for now to reduce server load on NarraFirma.com
                    if (_this.readOnly) {
                        console.log("Shutting down polling for updates by read-only client");
                        Globals.project().pointrelClient.shutdown();
                    }
                    // toaster.toast("Started up!!!");
                };
                // From: https://developer.mozilla.org/en-US/docs/Web/Events/beforeunload
                window.addEventListener("beforeunload", function (e) {
                    // TODO: IMPORTANT Ensure the current text field if any does the equivalent of a blur to commit its data...
                    // TODO: But may not be reliable: http://stackoverflow.com/questions/18718494/will-onblur-event-trigger-when-window-closes
                    return null;
                    /* TODO: Need to check for unsaved changes in any grids
                    if (!hasUnsavedChangesForCurrentPage()) return null;
                        
                    var confirmationMessage = "You have unsaved changes";
        
                    (e || window.event).returnValue = confirmationMessage;     // Gecko and Trident
                    return confirmationMessage;
                    */ // Gecko and WebKit
                });
            });
        };
        return Application;
    })();
    return Application;
});

define('js/main',["require", "exports", "./Application"], function (require, exports, Application) {
    "use strict";
    function run() {
        console.log("main: starting");
        var application = new Application();
        application.initialize();
        console.log("main: done with initialize");
    }
    exports.run = run;
});

/**
 * @license RequireJS text 2.0.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require, XMLHttpRequest, ActiveXObject,
  define, window, process, Packages,
  java, location, Components, FileUtils */

define('lib/text',['module'], function (module) {
    'use strict';

    var text, fs, Cc, Ci, xpcIsWindows,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = {},
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.14',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.lastIndexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config && config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config && config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            // Do not load if it is an empty: url
            if (url.indexOf('empty:') === 0) {
                onLoad();
                return;
            }

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node &&
            !process.versions['node-webkit'] &&
            !process.versions['atom-shell'])) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback, errback) {
            try {
                var file = fs.readFileSync(url, 'utf8');
                //Remove BOM (Byte Mark Order) from utf8 files if it is there.
                if (file[0] === '\uFEFF') {
                    file = file.substring(1);
                }
                callback(file);
            } catch (e) {
                if (errback) {
                    errback(e);
                }
            }
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status || 0;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        if (errback) {
                            errback(err);
                        }
                    } else {
                        callback(xhr.responseText);
                    }

                    if (masterConfig.onXhrComplete) {
                        masterConfig.onXhrComplete(xhr, url);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                if (line !== null) {
                    stringBuffer.append(line);
                }

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (masterConfig.env === 'xpconnect' || (!masterConfig.env &&
            typeof Components !== 'undefined' && Components.classes &&
            Components.interfaces)) {
        //Avert your gaze!
        Cc = Components.classes;
        Ci = Components.interfaces;
        Components.utils['import']('resource://gre/modules/FileUtils.jsm');
        xpcIsWindows = ('@mozilla.org/windows-registry-key;1' in Cc);

        text.get = function (url, callback) {
            var inStream, convertStream, fileObj,
                readData = {};

            if (xpcIsWindows) {
                url = url.replace(/\//g, '\\');
            }

            fileObj = new FileUtils.File(url);

            //XPCOM, you so crazy
            try {
                inStream = Cc['@mozilla.org/network/file-input-stream;1']
                           .createInstance(Ci.nsIFileInputStream);
                inStream.init(fileObj, 1, 0, false);

                convertStream = Cc['@mozilla.org/intl/converter-input-stream;1']
                                .createInstance(Ci.nsIConverterInputStream);
                convertStream.init(inStream, "utf-8", inStream.available(),
                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);

                convertStream.readString(inStream.available(), readData);
                convertStream.close();
                inStream.close();
                callback(readData.value);
            } catch (e) {
                throw new Error((fileObj && fileObj.path || '') + ': ' + e);
            }
        };
    }
    return text;
});


define('lib/text!recommendations/recommendations_filledin.csv',[],function () { return ',# participantGroup_status,unknown,very low,low,moderate,high,very high,mixed,,# participantGroup_confidence,unknown,very low,low,medium,high,very high,mixed,,# participantGroup_time,unknown,very little,little,some,a lot,mixed,,# participantGroup_education,unknown,illiterate,minimal,moderate,high,very high,mixed,,# participantGroup_physicalDisabilities,unknown,none,minimal,moderate,strong,mixed,,# participantGroup_emotionalImpairments,unknown,none,minimal,moderate,strong,mixed,,# participantGroup_performing,unknown,very unimportant,somewhat unimportant,somewhat important,very important,mixed,,# participantGroup_conforming,unknown,very unimportant,somewhat unimportant,somewhat important,very important,mixed,,# participantGroup_promoting,unknown,very unimportant,somewhat unimportant,somewhat important,very important,mixed,,# participantGroup_venting,unknown,very unimportant,somewhat unimportant,somewhat important,very important,mixed,,# participantGroup_interest,unknown,very little,a little,some,a lot,extremely,mixed,,# participantGroup_feelings_project,unknown,negative,neutral,positive,mixed,,# participantGroup_feelings_facilitator,unknown,negative,neutral,positive,mixed,,# participantGroup_feelings_stories,unknown,negative,neutral,positive,mixed,,# participantGroup_topic_feeling,unknown,strongly negative,negative,neutral,positive,strongly positive,mixed,,# participantGroup_topic_private,unknown,very private,medium,not private,mixed,,# participantGroup_topic_articulate,unknown,hard,medium,easy,mixed,,# participantGroup_topic_timeframe,unknown,hours,days,months,years,decades,mixed,,# aboutYou_experience,none,a little,some,a lot,,# aboutYou_help,none,a little,some,a lot,,# aboutYou_tech,none,a little,some,a lot\r#elicitingQuestions,What is the status of these participants in the community or organization?,,,,,,,,,How much self-confidence do these participants have?,,,,,,,,,How much free time do these participants have?,,,,,,,,What is the education level of these participants? ,,,,,,,,,Do these participants have physical limitations that will impact their participation? ,,,,,,,,Do these participants have emotional impairments that will impact their participation (such as mental illness or traumatic stress)?,,,,,,,,"For these participants, how important is performing well (with ""high marks"")?",,,,,,,,"For these participants, how important is conforming (to what is ""normal"" or expected)?",,,,,,,,"For these participants, how important is self-promotion (competing with others)?",,,,,,,,"For these participants, how important is speaking out (having a say, venting, sounding off)?",,,,,,,,How motivated are these participants to participate in the project?,,,,,,,,,How are these participants likely to feel about the project? ,,,,,,,How do these participants feel about you?,,,,,,,How do these participants feel about the idea of collecting stories?,,,,,,,What experiences have these participants had with the project\'s topic?,,,,,,,,,How private do these participants consider the topic to be?,,,,,,,How hard will it be for these participants to articulate their feelings about the topic?,,,,,,,How long of a time period do you need these participants to look back on?,,,,,,,,,How much experience do you have facilitating PNI projects?,,,,,,How much help will you have carrying out this project?,,,,,,How many technological resources will you have for carrying out this project?,,,,\rdirected questions,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,maybe,,,maybe,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,maybe,,very good,,,,,no,,,,,,,,,,,,,,no,maybe,,,maybe,maybe,,,,maybe,,,,,,,very good,,very good,,,,,very good,,,,very good,,,,very good,,,,,,very good,,,,,,,,,\rundirected questions,,,no,maybe,,maybe,no,maybe,,,,no,maybe,,,maybe,maybe,,,,no,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,,,maybe,no,,,,,no,maybe,,,very good,,,,,,,maybe,,,,,very good,,maybe,,,,,no,maybe,,maybe,,,,very good,,,,very good,,,,,very good,,,,,,,no,,maybe,no,,,,no,maybe,,maybe,no,maybe,,,no,maybe,,,,,no,maybe,,,,,,,,\rpoint in time,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,\revent,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rextreme,,,maybe,,,,maybe,,,,,maybe,,,maybe,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,maybe,,,,,maybe,,,maybe,,,,,,,maybe,no,,,,,,,maybe,no,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,,,,,very good,,,,,,,no,maybe,,,very good,,,,maybe,,,,,,maybe,,,,,,,,,\rsurprise,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,very good,,,,,maybe,,,,,,,very good,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,\rchange,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,,,,,maybe,,,,,,,no,maybe,,,,,,,,,,,,,,,,,,,,,,\rpeople places things,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,very good,,,,,,,,,no,maybe,,maybe,,,,no,,,,,,,,,,maybe,no,,,,,,,,,,,,,,,,,,,\rfictional scenario,,,no,maybe,,maybe,no,maybe,,,,no,maybe,,maybe,no,maybe,,,,no,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,no,maybe,,,,maybe,,maybe,no,,,,,,,,,,,,,,,maybe,no,,,,,no,maybe,,,very good,no,,,,no,,,no,,,,no,,,no,,,,no,maybe,,no,,,,no,no,maybe,,,no,,,,very good,,,,,,,no,,,,,,,,,,,,,,,no,maybe,,,,,no,maybe,,,,,,,,\rmenu method (choose a question),,,maybe,,,,maybe,very good,,,,maybe,,,,maybe,very good,,,,no,maybe,,,maybe,,,,maybe,maybe,,,,,,,,,,,maybe,very good,,,,,,maybe,maybe,very good,,,,,,,,very good,,,,,,,,very good,,,,,,,,very good,,,,,,,,very good,,,,no,maybe,,,very good,maybe,,,,maybe,,,very good,,,,maybe,,,very good,,,,very good,,,very good,,,,very good,very good,very good,,,very good,,,,very good,very good,,very good,,,,very good,,,very good,,,,,,,,,,,,very good,,,,,,maybe,maybe,,,,,maybe,maybe,,\rmultiple questions per person,,,no,maybe,,maybe,no,maybe,,,,no,maybe,,maybe,no,maybe,,,,no,no,,,no,,,,maybe,maybe,,,,,,,,,,,maybe,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,no,maybe,,,very good,no,,,,no,maybe,,no,,,,no,,,no,,,,maybe,,,maybe,,,,no,no,maybe,,,no,,,,,,,,,,,very good,,,,,,,,,,,,,,,no,maybe,,,,,no,maybe,,,,,maybe,maybe,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r#storyQuestions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rfew questions (5 or fewer),,,very good,,,,very good,,,,,very good,,,,,,,,,very good,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,no,maybe,,,,,,,,,,,very good,,maybe,maybe,,,,very good,,maybe,maybe,,,,very good,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rsome questions (6-10),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,very good,maybe,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rmany questions (11 or more),,,maybe,,,,maybe,,,,,no,maybe,,,,,,,,no,maybe,,very good,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,maybe,,,,maybe,,,,no,,very good,maybe,,,,no,,very good,maybe,,,,no,,very good,maybe,,,,no,maybe,,,,maybe,,,,no,,,maybe,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,maybe,maybe,,\rquestions about emotion (how do you feel),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,noi,,,,,,,very good,,,,,,,,very good,,,,,,,,very good,,,,,,,maybe,no,no,,,,no,maybe,,,very good,maybe,,,,very good,,,,,,,no,,very good,maybe,,,,no,,very good,no,,,,maybe,,,,,maybe,,,,no,,,maybe,,,,very good,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,\rquestions about categorizing (what type of story is this),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,very good,very good,,,,,,,no,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,very good,,,,,,,,,,,,,,no,,,maybe,,,,very good,,,,,,,very good,,maybe,maybe,,,,very good,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about story form,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,maybe,,,,,,,,very good,,,,,maybe,maybe,,,very good,maybe,,,,,,,,,,,,,,,,,,maybe,,very good,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about story function,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about story phenomenon,,,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,maybe,,,maybe,,,,maybe,,,,,,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,\rquestions using story elements,,,maybe,,,,maybe,,,,,maybe,,,,,maybe,,,,no,,,very good,no,,,,very good,,,,,,,,,,,,maybe,maybe,,,,,,maybe,no,no,,,,,,maybe,maybe,maybe,,,,,,maybe,maybe,maybe,,,,,,,maybe,,,,,,,,very good,,,,,no,maybe,maybe,,very good,no,,,,no,,very good,no,,,,no,,,no,,,,no,,very good,no,,,,,,,,,,,,,very good,,,,,,,very good,,,,,,,,,,,very good,,,,no,maybe,,very good,,,no,maybe,,very good,,,,,,\rchoice list (nominal),,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rchoice list (ordinal with middle option),,,no,,,,maybe,,,,,maybe,,,,,maybe,,,,no,maybe,,,maybe,,,,maybe,maybe,,,,,,,,,,,maybe,maybe,,,,,,maybe,maybe,maybe,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,maybe,,,,,,,,,,,,,no,maybe,maybe,,,no,,,,no,,,no,,,,no,,,maybe,,,,,,,,,,,,,,,,,,,,no,maybe,,maybe,,,,no,maybe,,maybe,,,,maybe,,,maybe,no,,,,maybe,maybe,,,,,,,,,,,,,,\rchoice list (ordinal without middle option),,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rrange (unipolar),,,maybe,,,,,,,,,maybe,,,,,maybe,,,,,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,\rrange (bipolar),,,maybe,,,,maybe,,,,,maybe,,,,,maybe,,,,no,maybe,,very good,no,,,,maybe,maybe,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,,very good,,,,,,,,very good,,,,,,,,very good,,,,,,,,,,,,,no,maybe,,,very good,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,maybe,,,,very good,,,,,,,,,,,,,,,no,maybe,,,,,maybe,,,,,,,,,\rvisual range,,,very good,,,,,,,,,very good,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,very good,,,,,,,very good,,,,,,,,very good,,,,,,,,,,,,maybe,maybe,,\rword range,,,very good,,,,,,,,,very good,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,maybe,,,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rfree text,,,no,maybe,,,maybe,maybe,,,,no,,,,very good,no,,,,no,maybe,,very good,no,,,,very good,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,very good,,,,,no,maybe,maybe,,very good,no,,,,very good,,,very good,,,,very good,,,,,,,very good,,,,,,,very good,very good,,,,very good,,,,maybe,,,maybe,,,,very good,,,,,,,,,,maybe,no,,,,very good,,,,,,maybe,maybe,,very good,,,maybe,maybe,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r#participantQuestions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rdetailed questions (your age),,,no,maybe,,,,,,,,no,maybe,,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,,no,,,,no,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,,no,maybe,,no,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,\rbroad questions (your age group),,,very good,,,,,,,,,very good,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,maybe,maybe,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rpersonal questions (your marital status),,,no,maybe,,,,,,,,no,maybe,,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,,no,,,,no,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,,no,maybe,,no,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,\rquestions about demographics,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,maybe,maybe,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about personality,,,,,,,,,,,,maybe,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,maybe,maybe,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about role in community,,,maybe,maybe,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,maybe,maybe,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about views on issues,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rquestions about views on community,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r#venues,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rindividual interviews,,,very good,,,,very good,,,,,very good,,,,very good,,,,,very good,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,very good,,,,,very good,,,very good,,,,,very good,,,very good,,,,,,,,very good,,,,,maybe,,,very good,,,,,maybe,very good,,maybe,maybe,maybe,,,,,,,,,,,no,,,no,,,,very good,,,,,,,very good,very good,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,no,maybe,,very good,,,maybe,,,very good,,,,,,\rgroup interviews,,,no,maybe,,,maybe,no,,,,,,,,,,,,,maybe,maybe,,,maybe,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,maybe,,,,,,,,maybe,,,,,very good,,,maybe,maybe,,,,maybe,,,very good,,,,,maybe,very good,,,,maybe,,,,maybe,,very good,maybe,,,,maybe,,,maybe,,,,,,very good,,,,,,,,,,,,,,maybe,,,maybe,,,,very good,,,,,,,no,maybe,,,very good,,,,no,maybe,,very good,,,maybe,,,very good,,,,,,\rpeer interviews,,,very good,,,no,no,no,,,,maybe,,,,,,,,,no,maybe,,,no,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,very good,,,maybe,maybe,,,,maybe,,,maybe,,,,,no,maybe,,,very good,maybe,,,,no,,very good,maybe,,,,very good,,,,,,,no,,very good,,,,,maybe,,,,,maybe,,,,maybe,,very good,maybe,,,,very good,,,,,,,no,maybe,,,very good,no,,,,,,,,,,,,,,,maybe,,,\rgroup story sessions,,,maybe,,,maybe,no,no,,,,,,,,,,,,,no,maybe,,very good,no,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,maybe,,,very good,,,,,maybe,,,,very good,,,,,maybe,,very good,maybe,,,,maybe,,,maybe,,,,,,very good,,,,,maybe,,,,,maybe,,,,maybe,,very good,maybe,,,,very good,,,,,,,no,maybe,,,very good,,,,maybe,,very good,very good,,,maybe,,,very good,,,,,,\rsurvey (web),,,,,,no,no,no,,,,maybe,,,,maybe,,,,,maybe,,,maybe,maybe,,,,no,maybe,,,,no,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,,,,maybe,,,,,maybe,,,,,,,,no,maybe,,,,maybe,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,maybe,,,,no,,,no,,,,no,maybe,,no,,,,very good,,,,maybe,,,,maybe,,,,,,,,,,,,no,maybe,,\rsurvey (email),,,,,,no,no,no,,,,maybe,,,,maybe,,,,,maybe,,,maybe,maybe,,,,no,maybe,,,,no,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,,,,maybe,,,,,maybe,,,,,,,,no,maybe,,,,maybe,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,maybe,,,,no,,,no,,,,no,maybe,,no,,,,very good,,,,maybe,,,,maybe,,,,,,no,maybe,,,,,no,maybe,,\rsurvey (paper),,,,,,no,no,no,,,,maybe,,,,maybe,,,,,maybe,,,maybe,maybe,,,,no,maybe,,,,no,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,maybe,,,maybe,maybe,,,,,,,maybe,,,,,maybe,,,,,,,,no,maybe,,,,maybe,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,maybe,,,,no,,,no,,,,no,maybe,,no,,,,very good,,,,maybe,,,,maybe,,,,,,no,maybe,,,,,,,,\rjournals,,,very good,,,no,no,no,,,,maybe,,,,maybe,,,,,no,maybe,,very good,no,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,maybe,,,very good,,,,,maybe,,,maybe,maybe,,,,very good,,,maybe,,,,,maybe,,,,,,,,no,maybe,,,very good,maybe,,,,no,,very good,maybe,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,no,,,no,,,,maybe,,,,,,,no,,,maybe,maybe,maybe,,,maybe,,,,,,no,maybe,,,,,maybe,,,\rnarrative incident reports,,,,,,no,no,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,,,,,,maybe,,,maybe,maybe,,,,very good,,,maybe,,,,,maybe,,,,,,,,maybe,maybe,,,very good,maybe,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,maybe,,,,maybe,,,maybe,,,,maybe,,,,,,,very good,very good,maybe,no,no,no,,,maybe,,,,,,no,maybe,,,,,maybe,,,\rgleaned stories,,,very good,,,,very good,,,,,,,,,,,,,,very good,,maybe,no,no,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,maybe,maybe,,,,,,,very good,,,,,very good,,,very good,,,,,,,,very good,,,,,very good,,,,,,,,very good,,,maybe,no,maybe,,,,very good,,,,,,,very good,,,,,,,very good,,,,,,,no,maybe,,,,maybe,,,,no,,,no,,,,,,,,,,,,,,maybe,maybe,maybe,,,very good,,,maybe,,,maybe,,,,,,,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\r#collectionSessions #sensemakingSessions,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rinviting via command,,,no,maybe,,,very good,no,,,,,,,,maybe,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,maybe,no,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,no,no,,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,very good,very good,,,,,very good,,,,,,,,,\rinviting via networks,,,maybe,,,maybe,maybe,maybe,,,,maybe,,,very good,very good,no,,,,maybe,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,very good,,,,,,,no,maybe,,maybe,,,,maybe,very good,,,,,,no,maybe,,,,,,maybe,maybe,,,very good,maybe,,,,maybe,,,maybe,,,,,,,,,,,maybe,maybe,,,very good,,,,,,,,,,very good,,,,,,,,,\rinviting via broadcasting,,,,,,maybe,maybe,maybe,,,,maybe,,,,,,,,,no,maybe,,,maybe,,,,no,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,,no,,,,maybe,,very good,no,,,,no,,very good,no,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,\rinviting via advertisement,,,very good,,,maybe,no,no,,,,maybe,,,,maybe,maybe,,,,no,no,maybe,,no,,,,no,maybe,,,,maybe,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,maybe,no,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,,no,,,,,,very good,no,,,,no,,very good,no,,,,maybe,,very good,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,\rinviting via spontaneous sessions,,,maybe,,,maybe,no,no,,,,very good,,,maybe,no,no,,,,maybe,maybe,,,maybe,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,maybe,maybe,,,,,,maybe,no,maybe,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,very good,very good,very good,,,,,,,very good,very good,maybe,,,,,,,,,,,,very good,,,,,,,maybe,maybe,,,,maybe,,,,maybe,,,,,,,,,,,,,,very good,very good,,,maybe,,,,no,maybe,,,,,maybe,maybe,,,,,very good,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rpaying people to come,,,maybe,maybe,,very good,maybe,maybe,,,,very good,,,,very good,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,maybe,,,,,,,maybe,no,no,,,,very good,very good,,,,,,,,maybe,very good,no,no,,,,no,,maybe,maybe,,,,,,,,,,,no,no,,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rgiving people gifts,,,very good,very good,,,,,,,,very good,very good,,,,,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,very good,very good,very good,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,very good,,,,,,,,,\rplaying background music,,,,,,maybe,maybe,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,maybe,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,no,maybe,,\rexploring fiction,,,maybe,,,,maybe,maybe,,,,no,maybe,,maybe,no,no,,,,maybe,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,no,maybe,,,,maybe,,,,no,maybe,,maybe,,,,no,,,maybe,,,,maybe,,,,,,,maybe,maybe,,,,maybe,,,,,,,,,,,very good,,,,,,,,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,,,,\rencouraging competition,,,no,maybe,,,maybe,no,,,,no,maybe,,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,no,no,no,,,,,,maybe,no,maybe,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,,,,,,,maybe,,,,,,,no,,,no,,,,maybe,,,,,,,no,no,,,,no,,,,no,,,no,,,,,,,,,,,,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,,,,\rholding virtual sessions,,,no,maybe,,,maybe,no,,,,no,maybe,,maybe,no,no,,,,,,,,,,,,no,no,maybe,,,no,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,no,maybe,,,,no,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,no,no,,\rholding long sessions,,,maybe,maybe,,maybe,no,no,,,,no,maybe,,maybe,no,no,,,,no,no,maybe,,no,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,no,no,maybe,,,no,,,,no,maybe,,no,,,,no,maybe,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rhigh facilitation,,,very good,,,,very good,,,,,very good,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,no,,,maybe,,,,,,,,,,,maybe,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,\rintermittent facilitation,,,maybe,,,,maybe,,,,,maybe,,,,maybe,maybe,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,maybe,,,,,,,,maybe,,,,,no,maybe,,,very good,,,,,maybe,,very good,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,,,,,,,,,,,\ravailable facilitation,,,maybe,,,,maybe,maybe,,,,maybe,maybe,,maybe,maybe,maybe,,,,no,maybe,,,no,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,maybe,,,,no,no,,,very good,maybe,,,,maybe,,very good,,,,,,,very good,,,,,maybe,,,,,,,,,,,,,,,,very good,,,,,,,maybe,maybe,,maybe,,,,,,,,maybe,,,,no,maybe,,,,,,,,,,,,,,\rno facilitation,,,no,maybe,,maybe,no,no,,,,no,maybe,,maybe,no,no,,,,no,maybe,,,no,,,,no,no,maybe,,,no,,,,,,maybe,maybe,maybe,,,,,,maybe,no,no,,,,,,maybe,no,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,no,no,maybe,,,no,,,,no,no,,no,,,,maybe,,,maybe,,,,no,maybe,,maybe,,,,,,,,,,,,,maybe,,,maybe,,,,no,maybe,,no,,,,,,,,maybe,,,,maybe,maybe,,,,,,,,,,,maybe,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rvideo recording,,,no,maybe,,maybe,maybe,no,,,,no,no,,,,no,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,no,,,,,,maybe,no,,,,,,,,maybe,,,,,no,maybe,,,very good,no,,,,no,,,no,,,,no,maybe,,no,,,,,,,,,,,no,,,,,no,,,,no,maybe,,no,,,,very good,,,,,,,,,,,,,,,very good,,,,,,very good,,,,,,no,no,,\raudio recording,,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,maybe,,,,,,,,,maybe,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,maybe,,\rnote taking,,,very good,,,maybe,maybe,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,no,maybe,,,,,,,,,,,very good,,,\r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rtwice-told stories,,,maybe,,,,maybe,maybe,,,,very good,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,very good,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,very good,,,,,very good,,,,,,,,,\rtimeline,,,maybe,,,,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,no,no,maybe,,very good,maybe,,,,,,,,,,,,,,,,,,\rlandscape,,,maybe,,,,maybe,maybe,,,,maybe,,,,very good,,,,,maybe,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,,,,maybe,,,,maybe,maybe,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,no,maybe,,,,,maybe,,,,,,,,,\rstory elements,,,maybe,,,,maybe,maybe,,,,maybe,,,,very good,,,,,maybe,,,,,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,maybe,,,,very good,,,,,,,,,,,,,,,,,,,maybe,,,,,,,very good,,,,,,,,,,,,,,,,very good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rcomposite stories,,,maybe,,,,maybe,maybe,,,,no,maybe,,,very good,no,,,,no,no,,,no,,,,,,,,,,,,,,,,,,,,,,,maybe,maybe,maybe,,,,,,,,,,,,,,,,,,,,,,,maybe,,,,,,,,,,,,,no,maybe,,,very good,no,,,,no,maybe,,maybe,,,,maybe,,,,,,,maybe,,,,,,,maybe,,,,,,,,,,,,,,,,maybe,,,,,,,maybe,,,,,,,,no,maybe,,,,,maybe,maybe,,,,,,,,';});


define('lib/text!recommendations/recommendations_intervention_filledin.csv',[],function () { return ',#outcomes_peopleFeltHeard,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleFeltInvolved,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleLearnedAboutCommOrg,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleWantedToTellMoreStories,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleWantedToShareMoreStoriesWithEachOther,unknown,never,occasionally,sometimes,often,mixed,#outcomes_peopleFeltStoriesNeededToBeHeard,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleFeltNobodyCares,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleFeltNobodyCanMeetNeeds,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleFeltTheyNeedNewStories,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleWantedToKeepExploring,unknown,not at all,somewhat,definitely,mixed,#outcomes_crisisPointsWereFound,unknown,not at all,somewhat,definitely,mixed,#outcomes_issuesWereBeyondWords,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleLearnedAboutTopic,unknown,never,occasionally,sometimes,often,mixed,#outcomes_issuesNewMembersStruggleWith,unknown,not at all,somewhat,definitely,mixed,#outcomes_foundInfoWithoutUnderstanding,unknown,not at all,somewhat,definitely,mixed,#outcomes_foundOverConfidence,unknown,not at all,somewhat,definitely,mixed,#outcomes_peopleCuriousAboutStoryWork,unknown,never,occasionally,sometimes,often,mixed\r#interventions,"During your project, did the people in this group say they felt heard for the first time?",,,,,,,Did they say they felt involved for the first time?,,,,,,,Did they say they learned a lot about their community or organization?,,,,,,,"During your story collection, did these people seem to want to tell more stories than you collected?",,,,,,,Did you ever feel that they wanted to share more experiences with each other than they did?,,,,,,,"Did these people feel that some of the stories you collected ""needed to be heard"" by anyone?",,,,,,"Were there any issues that these people thought ""nobody cares"" about?",,,,,,Do the people in this group have needs that nobody can meet?,,,,,,Do these people need to start telling themselves new stories?,,,,,,Were there any issues about which the people in this group seemed to want to keep exploring?,,,,,,"Did you discover any ""crisis points"" where people in this group needed help and didn\'t get it?",,,,,,"Did you find any issues for this group that were beyond words, that no amount of discussion could resolve?",,,,,,Did these people say that they learned a lot about the topic by participating in the project?,,,,,,,Did you notice that new members of the community or organization were having a harder time making sense of things?,,,,,,"Were there any issues that these people found difficult to understand, even though abundant information was available?",,,,,,Did you discover any areas in which these people had more confidence than skill?,,,,,,Did any of these participants express an interest in learning more about story work?,,,,,,\rnarrative ombudsmen,,,,,good,very good,good,,,,,good,very good,,,,,,,,,,,,,good,good,good,,,,,good,good,good,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,very good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rnarrative suggestion boxes,,,,,good,very good,good,,,,,good,good,,,,,,,,,,,,,good,good,good,,,,,good,good,good,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rstory-sharing spaces,,,,,good,very good,good,,,,,,,,,,,,,,,,,,,good,very good,good,,,,,good,very good,good,,,,good,good,good,,,,,,,,,,good,very good,good,,,,good,good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,good,good,good\rnarrative orientations,,,,,,,,,,,,,,,,,,,good,very good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,,,,\rnarrative learning resources,,,,,,,,,,,,,,,,,,,good,very good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,good,good,good,,,,,,,\rnarrative simulation,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,,,,\rnarrative presentations,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,good,good,good,,,,,,,,,,,good,good,good\rdramatic action,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,good,very good,good,,,,,,,,,,good,good,good,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rsensemaking spaces,,,,,,,,,,,,good,very good,,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,very good,good,,,,,,,,,,,,,,,,,good,good,good,,,,good,good,good,,,,good,good,good,,,,good,good,good,,,,,,,\rsensemaking pyramids,,,,,,,,,,,,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good,,,,good,very good,good,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,good,good,,,,,good,very good,good\rnarrative mentoring,,,,,good,good,good,,,,,good,good,,,,,,,,,,,,,good,good,good,,,,,good,very good,good,,,,good,good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,,good,good,good,,,,good,very good,good,,,,good,good,good,,,,good,good,good,,,,,good,good,good\rnarrative therapy,,,,,good,good,good,,,,,,,,,,,,,,,,,,,good,good,good,,,,,,,,,,,good,good,good,,,,good,very good,good,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\rparticipatory theatre,,,,,good,good,good,,,,,good,very good,,,,,,,,,,,,,good,good,good,,,,,,,,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,good,very good,good,,,,good,very good,good,,,,good,very good,good,,,,good,good,good,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,good,good,good';});

